---
top_img: /img/banners/å•æºæœ€çŸ­è·¯å¾„.jpg
cover: /img/banners/å•æºæœ€çŸ­è·¯å¾„.jpg
title: å•æºæœ€çŸ­è·¯å¾„ (Single-Source Shortest Paths)
date: 2024-05-12 18:49:00
tags: [ç®—æ³•, å›¾è®º, æœ€çŸ­è·¯å¾„, Dijkstra, Bellman-Ford]
categories: [ç®—æ³•]
description: å•æºæœ€çŸ­è·¯å¾„ç®—æ³•å­¦ä¹ ç¬”è®°ï¼Œè¯¦è§£ Dijkstra ç®—æ³•å’Œ Bellman-Ford ç®—æ³•çš„åŸç†ã€è¯æ˜ä¸å®ç°ã€‚
mathjax: true
---

# å•æºæœ€çŸ­è·¯å¾„(SSSP)

## å†™åœ¨å‰é¢

### å›¾çš„è¾“å…¥

- æ— æƒå›¾: bfs å¯ä»¥æ±‚è§£å…¶æœ€çŸ­è·¯å¾„ï¼Œæ— æƒå›¾å¯ä»¥è§†ä¸ºæ¯æ¡è¾¹çš„æƒé‡éƒ½æ˜¯å•ä½æƒé‡çš„å›¾ã€‚å‰é¢å·²åˆ†äº«è¿‡ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ï¼Œä¼ é€é—¨[here](https://ius7.qzz.io/2024/04/21/Elementary-Graph-Algorithms/)
- æœ‰å‘å¸¦æƒå›¾: ä» u åˆ° v çš„æœ€çŸ­è·¯å¾„ä¸ºä»»æ„ä¸€æ¡æ»¡è¶³$w(p)=Î´(u, v)$çš„è·¯å¾„ã€‚ç»™å®šå›¾$G=(V, E)$ï¼Œæ‰¾å‡ºä»æºç‚¹$s\in V$åˆ°æ¯ä¸€ä¸ªé¡¶ç‚¹$v\in V$çš„ä¸€æ¡æœ€çŸ­è·¯å¾„ã€‚

### æ¾å¼›(Relaxation)

å¯¹äºæ¯ä¸ªé¡¶ç‚¹ vï¼Œéœ€è¦ç»´æŠ¤ä¸€ä¸ªé¡¶ç‚¹å±æ€§ v.d è®°å½•ä» s åˆ° v çš„æœ€çŸ­è·¯å¾„çš„æƒé‡çš„ä¸Šç•Œã€‚v.d è¢«ç§°ä¸ºä» s åˆ° v çš„æœ€çŸ­è·¯å¾„ä¼°è®¡(shortest-path estimate)ã€‚åˆå§‹åŒ–å¦‚ä¸‹:
![image](https://telegraph-image-eja.pages.dev/file/b63a6ef4467d480d1b43f.png)
æ¾å¼›æ“ä½œå¦‚ä¸‹:
![image](https://telegraph-image-eja.pages.dev/file/e75f4fa06dd16a04b677d.png)

> å…¶å®å°±æ˜¯åœ¨ç»´æŠ¤ v.d è¿™ä¸ªå±æ€§ï¼Œæµ‹è¯•æ˜¯å¦å¯ä»¥åˆ©ç”¨ u å¯¹ä» s åˆ° v çš„æœ€çŸ­è·¯å¾„ä¼°è®¡è¿›è¡Œæ”¹å–„ ã€‚

### æ— è·¯å¾„æ€§è´¨

> è‹¥ä» Â ğ‘ Â  åˆ° Â ğ‘£Â  ä¸å­˜åœ¨è·¯å¾„ï¼Œåˆ™$ğ‘£.ğ‘‘=ğ›¿(ğ‘ ,ğ‘£)=âˆ$ã€‚

### ä¸Šç•Œæ€§è´¨

> å¯¹äºæ‰€æœ‰é¡¶ç‚¹$ğ‘£âˆˆğ‘‰$ï¼Œæœ‰$ğ‘£.ğ‘‘â‰¥ğ›¿(ğ‘ ,ğ‘£)$ï¼Œå¹¶ä¸”è¯¥ä¸å˜å¼åœ¨å¯¹ ğº çš„è¾¹è¿›è¡Œä»»æ„é¡ºåºçš„æ¾å¼›è¿‡ç¨‹ä¸­ä¿æŒæˆç«‹ã€‚è€Œä¸”ï¼Œä¸€æ—¦ ğ‘£.ğ‘‘ è¾¾åˆ°å…¶ä¸‹ç•Œ$ğ›¿(ğ‘ ,ğ‘£)$ï¼Œğ‘£.ğ‘‘ ä¸å†æ”¹å˜ã€‚

**Proof**

- base caseï¼šåˆå§‹åŒ–åï¼Œå¯¹äºæ‰€æœ‰$ğ‘£âˆˆğ‘‰âˆ’\{ğ‘ \}$ï¼Œæœ‰$ğ‘£.ğ‘‘=âˆ$ï¼Œåˆ™$ğ‘£.ğ‘‘â‰¥ğ›¿(ğ‘ ,ğ‘£)$æ˜¾ç„¶æˆç«‹ï¼Œè€Œå¯¹äº ğ‘ ï¼Œæœ‰$ğ‘ .ğ‘‘=0â‰¥ğ›¿(ğ‘ ,ğ‘ )$ã€‚
- inductive hypothesisï¼šåœ¨ç®—æ³•çš„æ¯æ¬¡è¿­ä»£ä¹‹å‰ï¼Œå¯¹äºæ‰€æœ‰é¡¶ç‚¹$x\in V$, æœ‰$x.d \geq \delta(s, x)$ã€‚
- inductive stepï¼šè€ƒè™‘è¾¹(u, v)çš„æ¾å¼›æ“ä½œï¼Œå”¯ä¸€èƒ½æ”¹å˜çš„åªæœ‰ ğ‘£.ğ‘‘ï¼Œè‹¥å®ƒå‘ç”Ÿæ”¹å˜ï¼Œæœ‰
  $v.d = u.d + w(u, v)$
  $\geq \delta(s, u) + w(u, v)$
  $\ge \delta(s, v)$
  å› ä¸º$ğ‘£.ğ‘‘â‰¥ğ›¿(ğ‘ ,ğ‘£)$ä¸”æ¾å¼›æ“ä½œä¸ä¼šå¢å¤§ ğ‘£.ğ‘‘ï¼Œæ‰€ä»¥ä¸€æ—¦ ğ‘£.ğ‘‘ è¾¾åˆ°å…¶ä¸‹ç•Œ$ğ›¿(ğ‘ ,ğ‘£)$ï¼Œğ‘£.ğ‘‘ ä¸å†æ”¹å˜ã€‚

### æ”¶æ•›æ€§è´¨

> è‹¥å¯¹äºæŸäº›é¡¶ç‚¹$ğ‘¢,ğ‘£âˆˆğ‘‰$ï¼Œ$ğ‘ â‡ğ‘¢â†’ğ‘£$ä¸º ğº ä¸­çš„ä¸€æ¡æœ€çŸ­è·¯å¾„ï¼Œåœ¨å¯¹(ğ‘¢, ğ‘£)è¿›è¡Œæ¾å¼›ä¹‹å‰çš„ä»»æ„æ—¶é—´æœ‰$ğ‘¢.ğ‘‘=ğ›¿(ğ‘ ,ğ‘¢)$ï¼Œåˆ™åœ¨å¯¹(ğ‘¢, ğ‘£)è¿›è¡Œæ¾å¼›ä¹‹åçš„æ—¶é—´æœ‰$ğ‘£.ğ‘‘=ğ›¿(ğ‘ ,ğ‘£)$ã€‚

æ ¹æ®ä¸Šç•Œæ€§è´¨ï¼Œè‹¥æ¾å¼›è¾¹(ğ‘¢, ğ‘£)å‰çš„æŸä¸ªæ—¶åˆ»å·²ç»æœ‰$ğ‘¢.ğ‘‘=ğ›¿(ğ‘ ,ğ‘¢)$ï¼Œåˆ™æ­¤åè¯¥ç­‰å¼ä¿æŒæˆç«‹ã€‚å½“è¾¹(ğ‘¢, ğ‘£)è¢«æ¾å¼›åï¼Œæœ‰
$v.d \leq u.d + w(u, v)$
$= \delta(s, u) + w(u, v)$
$= \delta(s, v)$
åˆæ ¹æ®ä¸Šç•Œæ€§è´¨ï¼Œæœ‰$ğ‘£.ğ‘‘â‰¥ğ›¿(ğ‘ ,ğ‘£)$ï¼Œæ­¤å$ğ‘£.ğ‘‘=ğ›¿(ğ‘ ,ğ‘£)$ä¿æŒä¸å˜

## Dijkstra ç®—æ³•

ä½ å¯ä»¥æŠŠ Dijkstra ç®—æ³•çœ‹ä½œæ˜¯å°†å¹¿åº¦ä¼˜å…ˆæœç´¢æ¨å¹¿åˆ°åŠ æƒå›¾ã€‚æ³¢ä»æºç‚¹å‘å‡ºï¼Œå½“æ³¢ç¬¬ä¸€æ¬¡åˆ°è¾¾æŸä¸ªé¡¶ç‚¹æ—¶ï¼Œè®°å½•ä»æºç‚¹åˆ°è¯¥é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œæ–°çš„æ³¢ä»è¯¥é¡¶ç‚¹å‘å‡ºï¼Œç›´åˆ°è®°å½•å®Œä»æºç‚¹åˆ°æ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚

> $DIJKSTRA(G, w, s)$
> 1 $INITIALIZE-SINGLE-SOURCE(G, s)$ //åˆå§‹åŒ–
> 2 $S = \not 0$ //åˆå§‹åŒ–é¡¶ç‚¹é›†åˆ Sï¼Œè¡¨ç¤ºä» Â ğ‘ Â  å¯è¾¾çš„æœ€ç»ˆæœ€çŸ­è·ç¦»å·²ç»ç¡®å®šçš„é¡¶ç‚¹çš„é›†åˆã€‚
> 3 $Q = \not 0$ //åˆå§‹åŒ–ä»¥ v.d ä¸º key çš„æœ€å°ä¼˜å…ˆé˜Ÿåˆ—
> 4 for each vertex $u \in G.V$
> 5 $INSERT(Q, u)$ //å°†æ‰€æœ‰é¡¶ç‚¹å…¥é˜Ÿ
> 6 while $Q \not = \not 0$ //åªè¦é˜Ÿåˆ—éç©ºç»§ç»­æ‰§è¡Œï¼Œæ˜“çŸ¥ä¸€å…±æ‰§è¡Œ V æ¬¡ï¼Œè¿‡ç¨‹ä¸­$Q = V - S$ä¸å˜
> 7 $u = EXTRACT-MIN(Q)$ //ä» Q ä¸­é€‰æ‹©å…·æœ‰æœ€å°è·¯å¾„ä¼°è®¡çš„é¡¶ç‚¹ ğ‘¢
> 8 $S = S \cup \{u\}$ //å°† u åŠ å…¥åˆ° S
> 9 for each vertex $v \in G.Adj[u]$  
> 10 RELAX(u, v, w) //æ¾å¼›æ‰€æœ‰ä» ğ‘¢ å‘å‡ºçš„è¾¹
> 11 if the call of RELAX decreased v.d
> 12 $DECREASED-KEY(Q, v, v.d)$ //æ›´æ–° Q ä¸­é¡¶ç‚¹æœ€çŸ­è·¯å¾„ä¼°è®¡

ä¸‹é¢ç»™å‡ºè¿‡ç¨‹ç¤ºä¾‹å›¾ï¼š
![image](https://telegraph-image-eja.pages.dev/file/69fa37e8cf4862d7e25ba.png)

### Theorem(Correctness of Dijkstraâ€™s algorithm)

ä¸‹é¢é‡‡ç”¨å½’çº³æ³•è¯æ˜ç®—æ³•çš„æ­£ç¡®æ€§ï¼Œæˆ‘ä»¬å°†è¦è¯æ˜åœ¨ 6-12 è¡Œçš„æ¯ä¸€æ¬¡è¿­ä»£å¼€å§‹æ—¶ï¼Œå¯¹äºæ‰€æœ‰é¡¶ç‚¹$ğ‘£\inğ‘†$ï¼Œæœ‰$ğ‘£.ğ‘‘=\delta(ğ‘ ,ğ‘£)$ã€‚ç®—æ³•ç»ˆæ­¢æ—¶ï¼Œç”±äº ğ‘† = ğ‘‰ï¼Œå› æ­¤å¯¹äºæ‰€æœ‰é¡¶ç‚¹$ğ‘£\in ğ‘‰$ï¼Œæœ‰$ğ‘£.ğ‘‘=\delta(ğ‘ ,ğ‘£)$ã€‚
**Proof**

- base cases
  - å½“$|ğ‘†|=0$æ—¶ï¼Œæœ‰$ğ‘† = âˆ…$ï¼Œæ–­è¨€ä¸ºçœŸã€‚
  - å½“$|ğ‘†|=1$æ—¶ï¼Œæœ‰$ğ‘†=\{ğ‘ \}$ä¸”$ğ‘ .ğ‘‘=ğ›¿(ğ‘ ,ğ‘ )=0$ã€‚
- inductive hypothesisï¼šå¯¹äºæ‰€æœ‰é¡¶ç‚¹$ğ‘£\in ğ‘‰$ï¼Œæœ‰$ğ‘£.ğ‘‘=ğ›¿(ğ‘ ,ğ‘£)$ã€‚
  ![image](https://telegraph-image-eja.pages.dev/file/c7f1800d8c978418f3bde.png)
- ç®—æ³•æ¯æ¬¡è¿­ä»£æ·»åŠ ä¸€ä¸ªé¡¶ç‚¹ ğ‘¢ åˆ° ğ‘† ä¸­ï¼Œæˆ‘ä»¬éœ€è¦è¯æ˜æ“ä½œç»“æŸåæœ‰$ğ‘¢.ğ‘‘=ğ›¿(ğ‘ ,ğ‘¢)$ã€‚ - è‹¥ä» ğ‘  åˆ° ğ‘¢ ä¸å­˜åœ¨è·¯å¾„ï¼Œåˆ™æ ¹æ®æ— è·¯å¾„æ€§è´¨ï¼Œè¯æ˜å®Œæ¯•ã€‚ - è‹¥ä» ğ‘  åˆ° ğ‘¢ å­˜åœ¨è·¯å¾„ï¼Œå¦‚å›¾æ‰€ç¤ºï¼Œè®¾ ğ‘¦ ä¸ºä» ğ‘  åˆ° ğ‘¢ çš„è·¯å¾„ä¸Šçš„ç¬¬ä¸€ä¸ªä¸åœ¨ ğ‘† ä¸­çš„é¡¶ç‚¹ï¼Œä»¤$ğ‘¥âˆˆğ‘†$ä¸º ğ‘¦ åœ¨è¯¥è·¯å¾„ä¸Šçš„å‰é©±ï¼Œå½“ç„¶å¯ä»¥å­˜åœ¨$ğ‘¦=ğ‘¢$æˆ–è€…$ğ‘¥=ğ‘ $çš„æƒ…å†µï¼Œç”±äºåœ¨è¯¥è·¯å¾„ä¸Š ğ‘¦ ä¸ä¼šæ™šäº ğ‘¢ å‡ºç°ä¸”æ‰€æœ‰è¾¹çš„æƒé‡éè´Ÿï¼Œæœ‰$ğ›¿(ğ‘ ,ğ‘¦)â‰¤ğ›¿(ğ‘ ,ğ‘¢)$ï¼Œåˆç”±äº EXTRACT-MIN è¿”å›äº† ğ‘‰âˆ’ğ‘† ä¸­ ğ‘‘ å€¼æœ€å°çš„é¡¶ç‚¹ï¼Œæœ‰$ğ‘¢.ğ‘‘â‰¤ğ‘¦.ğ‘‘$ï¼Œæ ¹æ®ä¸Šç•Œæ€§è´¨ï¼Œæœ‰$ğ›¿(ğ‘ ,ğ‘¢)â‰¤ğ‘¢.ğ‘‘$ã€‚ - å¯¹äº$ğ‘¥âˆˆğ‘†$ï¼Œæ ¹æ®å½’çº³å‡è®¾æœ‰$ğ‘¥.ğ‘‘=ğ›¿(ğ‘ ,ğ‘¥)$ã€‚åœ¨ while å¾ªç¯çš„æŸä¸€æ¬¡è¿­ä»£ä¸­ï¼Œğ‘¥ è¢«åŠ å…¥ ğ‘†ï¼Œè¾¹(ğ‘¥, ğ‘¦)è¢«æ¾å¼›ï¼Œæ ¹æ®æ”¶æ•›æ€§è´¨ï¼Œğ‘¦.ğ‘‘ æ­¤æ—¶å¾—åˆ°æœ€å°å€¼$ğ›¿(ğ‘ ,ğ‘¦)$ï¼Œæœ‰$ğ›¿(ğ‘ ,ğ‘¦)â‰¤ğ›¿(ğ‘ ,ğ‘¢)â‰¤ğ‘¢.ğ‘‘â‰¤ğ‘¦.ğ‘‘$ä¸”$ğ‘¦.ğ‘‘=ğ›¿(ğ‘ ,ğ‘¦)$ï¼Œå³$ğ›¿(ğ‘ ,ğ‘¦)=ğ›¿(ğ‘ ,ğ‘¢)=ğ‘¢.ğ‘‘=ğ‘¦.ğ‘‘$ã€‚å› æ­¤$ğ‘¢.ğ‘‘=ğ›¿(ğ‘ ,ğ‘¢)$ï¼Œæ ¹æ®ä¸Šç•Œæ€§è´¨ï¼Œğ‘¢.ğ‘‘ ä¸å†æ”¹å˜ï¼Œå¾—è¯ã€‚
  > ä¹Ÿå¯ä»¥ä»å¾ªç¯ä¸å˜é‡è§’åº¦ç†è§£ï¼Œåœ¨æ¯ä¸€æ¬¡è¿­ä»£ä¸­ï¼Œä»¥ä¸‹æ¡ä»¶ä¿æŒä¸å˜ï¼š
- å¯¹äºæ‰€æœ‰å·²ç¡®å®šçš„é¡¶ç‚¹ vï¼Œå³åŠ å…¥åˆ° S ä¸­çš„é¡¶ç‚¹ vï¼Œå®ƒä»¬çš„ v.d æ˜¯æ­£ç¡®çš„ï¼Œå³ä»æºç‚¹åˆ°è¿™äº›é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦å·²ç»è¢«æ‰¾åˆ°ã€‚
- å¯¹äºæ‰€æœ‰æœªç¡®å®šçš„é¡¶ç‚¹ï¼Œå­˜åœ¨ä¸€ä¸ªâ€œæ¾å¼›â€æ“ä½œï¼Œè¯¥æ“ä½œå¯ä»¥å‡å°‘æŸä¸ªé¡¶ç‚¹çš„è·ç¦»å€¼ï¼ŒåŒæ—¶ä¿æŒå…¶ä»–é¡¶ç‚¹çš„è·ç¦»å€¼ä¸å˜æˆ–å‡å°‘ã€‚
  **Proof**
- åˆå§‹åŒ–ï¼šåœ¨ç®—æ³•å¼€å§‹æ—¶ï¼Œåªæœ‰æºç‚¹çš„è·ç¦»å€¼è¢«è®¾ç½®ä¸º 0ï¼Œå…¶ä»–æ‰€æœ‰é¡¶ç‚¹çš„è·ç¦»å€¼è¢«è®¾ç½®ä¸ºæ— ç©·å¤§ã€‚è¿™æ»¡è¶³äº†å¾ªç¯ä¸å˜é‡çš„æ¡ä»¶ï¼Œå› ä¸ºæºç‚¹åˆ°è‡ªå·±çš„æœ€çŸ­è·¯å¾„é•¿åº¦æ˜¯ 0ï¼Œè€Œå…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦å°šæœªç¡®å®šã€‚
- ä¿æŒï¼šåœ¨ç®—æ³•çš„æ¯æ¬¡è¿­ä»£ä¸­ï¼Œæˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªæœªç¡®å®šçš„æœ€çŸ­è·ç¦»é¡¶ç‚¹(å³é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªé¡¶ç‚¹)ï¼Œå¹¶å°†å…¶æ ‡è®°ä¸ºå·²ç¡®å®š(å³å°†å…¶åŠ å…¥åˆ° S)ã€‚ç„¶åï¼Œæˆ‘ä»¬æ›´æ–°è¿™ä¸ªé¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹çš„è·ç¦»å€¼ã€‚è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œå·²ç¡®å®šé¡¶ç‚¹çš„è·ç¦»å€¼ä¸ä¼šæ”¹å˜(å› ä¸ºå®ƒä»¬å·²ç»å‡ºé˜Ÿ)ï¼Œè€Œæœªç¡®å®šé¡¶ç‚¹çš„è·ç¦»å€¼åªä¼šåœ¨æ‰¾åˆ°æ›´çŸ­çš„è·¯å¾„æ—¶å‡å°‘ã€‚å› æ­¤ï¼Œå¾ªç¯ä¸å˜é‡åœ¨æ¯ä¸ªè¿­ä»£ä¸­éƒ½è¢«ä¿æŒã€‚
- ç»ˆæ­¢ï¼šå½“ç®—æ³•ç»ˆæ­¢æ—¶ï¼Œæ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦éƒ½å·²ç»è¢«ç¡®å®šã€‚è¿™æ˜¯å› ä¸ºç®—æ³•åœ¨æ¯æ¬¡è¿­ä»£ä¸­éƒ½é€‰æ‹©äº†ä¸€ä¸ªæœªç¡®å®šçš„æœ€çŸ­è·ç¦»é¡¶ç‚¹ï¼Œå¹¶å°†å…¶æ ‡è®°ä¸ºå·²ç¡®å®šï¼Œç›´åˆ°æ²¡æœ‰æœªç¡®å®šçš„é¡¶ç‚¹ä¸ºæ­¢ã€‚æ ¹æ®å¾ªç¯ä¸å˜é‡ï¼Œæ‰€æœ‰å·²ç¡®å®šçš„é¡¶ç‚¹çš„è·ç¦»å€¼æ˜¯æ­£ç¡®çš„ï¼Œå› æ­¤ç®—æ³•æ‰¾åˆ°äº†ä»æºç‚¹åˆ°æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚
  > Dijkstra çš„å±€é™æ€§åœ¨äºå®ƒè¦æ±‚æ‰€æœ‰è¾¹çš„æƒé‡éƒ½å¾— â‰¥0ï¼Œå› ä¸ºå¦‚æœå­˜åœ¨è´Ÿè¾¹ï¼ŒåŸæœ¬å·²ç»è¢«åŠ å…¥åˆ° S çš„é¡¶ç‚¹è¿˜æœ‰å¯èƒ½é€šè¿‡æœ‰è´Ÿè¾¹çš„è·¯å¾„è€Œå‡å° d å€¼ï¼Œè¿™è¿åäº†å¾ªç¯ä¸å˜é‡ã€‚

### æ—¶é—´å¤æ‚åº¦åˆ†æ

> $DIJKSTRA(G, w, s)$
> 1 $INITIALIZE-SINGLE-SOURCE(G, s)$ //O(V)
> 2 $S = \not 0$ //O(1)
> 3 $Q = \not 0$ //O(1)
> 4 for each vertex $u \in G.V$ //O(V)
> 5 $INSERT(Q, u)$ //O(1)
> 6 while $Q \not = \not 0$ //O(V)
> 7 $u = EXTRACT-MIN(Q)$ //O(V) or $ğ‘‚(lgâ¡ğ‘‰)$
> 8 $S = S \cup \{u\}$ //O(1)
> 9 for each vertex $v \in G.Adj[u]$ //O(E)(å› ä¸ºæ¯æ¡è¾¹éƒ½ä¼šè¢«æ¾å¼›ä¸€æ¬¡)
> 10 RELAX(u, v, w) //O(1)
> 11 if the call of RELAX decreased v.d //O(1)
> 12 $DECREASED-KEY(Q, v, v.d)$ //O(1) or $ğ‘‚(lgâ¡ğ‘‰)$

Dijkstra ç®—æ³•çš„è¿è¡Œæ—¶é—´å–å†³äºæœ€å°ä¼˜å…ˆé˜Ÿåˆ—çš„å…·ä½“å®ç°ï¼Œä¸€ä¸ªç®€å•çš„å®ç°æ–¹å¼å°±æ˜¯å°†é¡¶ç‚¹ä» 1 åˆ° ğ‘‰ ç¼–å·ï¼Œæ„é€ ä¸€ä¸ªæ•°ç»„ Â ğ´[1 : ğ‘‰]Â ï¼Œç¼–å· ğ‘– çš„é¡¶ç‚¹ ğ‘£ çš„ ğ‘£.ğ‘‘ å­˜å‚¨åœ¨æ•°ç»„çš„ç¬¬ ğ‘– é¡¹ä¸­ï¼Œæ¯æ¬¡è°ƒç”¨ INSERT å’Œ DECREASED-KEY çš„è¿è¡Œæ—¶é—´ä¸º ğ‘‚(1)ï¼Œæ¯æ¬¡è°ƒç”¨ EXTRACT_MIN çš„è¿è¡Œæ—¶é—´ä¸º ğ‘‚(ğ‘‰)Â (ç”±äºéœ€è¦éå†æ•´ä¸ªæ•°ç»„æ‰¾åˆ°æœ€å°å€¼)ï¼Œæ€»çš„è¿è¡Œæ—¶é—´ä¸º$ğ‘‚(ğ‘‰^2+ğ¸)=ğ‘‚(ğ‘‰^2)$ã€‚

å¦‚æœå›¾è¶³å¤Ÿç¨€ç–ï¼Œç‰¹åˆ«çš„ï¼Œå¦‚æœ$ğ¸=ğ‘œ(ğ‘‰^2/lgâ¡ğ‘‰)$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æœ€å°äºŒå‰å †å®ç°æœ€å°ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå…¶ä¸­åŒ…å«å°†é¡¶ç‚¹æ˜ å°„åˆ°å¯¹åº”çš„å †ä¸­å…ƒç´ çš„å‡½æ•°ï¼Œæ¯æ¬¡è°ƒç”¨ EXTRACT_MIN çš„è¿è¡Œæ—¶é—´ä¸º$ğ‘‚(lgâ¡ğ‘‰)$ï¼Œæ„å»ºæœ€å°äºŒå‰å †çš„è¿è¡Œæ—¶é—´ä¸º ğ‘‚(ğ‘‰)ï¼Œæ€»çš„è¿è¡Œæ—¶é—´ä¸º$ğ‘‚((ğ‘‰+ğ¸)lgâ¡ğ‘‰)$ï¼Œè‹¥$E=\Omega(V)$ï¼Œåˆ™æ€»çš„è¿è¡Œæ—¶é—´ä¸º$ğ‘‚(ğ¸lgâ¡ğ‘‰)$ã€‚è‹¥$ğ¸=ğ‘œ(ğ‘‰^2/lgâ¡ğ‘‰)$ï¼Œåˆ™æ€»çš„è¿è¡Œæ—¶é—´ç›¸æ¯”$ğ‘‚(ğ‘‰^2)$æœ‰æ‰€æ”¹å–„ã€‚

### ç©ºé—´å¤æ‚åº¦åˆ†æ

> $DIJKSTRA(G, w, s)$
> 1 $INITIALIZE-SINGLE-SOURCE(G, s)$ //O(V)
> 2 $S = \not 0$ //O(V)
> 3 $Q = \not 0$ //O(V)
> 4 for each vertex $u \in G.V$  
> 5 $INSERT(Q, u)$ //O(1)
> 6 while $Q \not = \not 0$  
> 7 $u = EXTRACT-MIN(Q)$ //O(1)
> 8 $S = S \cup \{u\}$ //O(1)
> 9 for each vertex $v \in G.Adj[u]$  
> 10 RELAX(u, v, w)  
> 11 if the call of RELAX decreased v.d  
> 12 $DECREASED-KEY(Q, v, v.d)$ //O(1)

æ‰€ä»¥æ€»ç©ºé—´å¤æ‚åº¦ä¸º$O(V)$

### cpp ç®—æ³•å®ç°

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <limits>
using namespace std;
// é¡¶ç‚¹ç»“æ„ä½“
struct Vertex {
Â  Â  int index; Â  Â  Â  Â  Â // é¡¶ç‚¹ç´¢å¼•
Â  Â  int distance; Â  Â  Â  // åˆ°æºé¡¶ç‚¹çš„è·ç¦»
Â  Â  int parent; Â  Â  Â  Â  // å‰é©±èŠ‚ç‚¹ç´¢å¼•
Â  Â  Vertex(int i, int d, int p) : index(i), distance(d), parent(p) {}
Â  Â  // è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°ï¼Œç”¨äºä¼˜å…ˆé˜Ÿåˆ—
Â  Â  bool operator>(const Vertex& other) const {
Â  Â  Â  Â  return distance > other.distance;
Â  Â  }
};
// è¾¹ç»“æ„ä½“
struct Edge {
Â  Â  int from; Â  Â  Â  Â  Â  // èµ·å§‹é¡¶ç‚¹ç´¢å¼•
Â  Â  int to; Â  Â  Â  Â  Â  Â  // ç»ˆæ­¢é¡¶ç‚¹ç´¢å¼•
Â  Â  int weight; Â  Â  Â  Â  // è¾¹çš„æƒé‡
Â  Â  Edge(int f, int t, int w) : from(f), to(t), weight(w) {}
};
// å›¾ç±»
class Graph {
private:
Â  Â  int V; Â  Â  Â  Â  Â  Â  Â  Â  Â // é¡¶ç‚¹æ•°é‡
Â  Â  vector<vector<Edge>> adj; Â  // é‚»æ¥è¡¨
public:
Â  Â  Graph(int vertices) : V(vertices) {
Â  Â  Â  Â  adj.resize(V);
Â  Â  }
Â  Â  void addEdge(int from, int to, int weight) {
Â    Â  Â  adj[from].push_back(Edge(from, to, weight));
Â  Â  }
Â  Â  vector<vector<Edge>> getAdj() {
Â  Â  Â  Â  return adj;
Â  Â  }
Â  Â  int getV() {
Â  Â  Â  Â  return V;
Â  Â  }
};
// Dijkstra ç®—æ³•
class Dijkstra {
public:
Â  Â  static void initializeSingleSource(Graph& G, int s, vector<Vertex>& vertices) {
Â  Â  Â  Â  int V = G.getV();
Â  Â  Â  Â  vertices.clear();
Â  Â  Â  Â  vertices.reserve(V);
Â  Â  Â  Â  for (int i = 0; i < V; ++i) {
Â  Â  Â  Â  Â  Â  vertices.push_back(Vertex(i, numeric_limits<int>::max(), -1));
Â  Â  Â  Â  }
Â  Â  Â  Â  vertices[s].distance = 0;
Â  Â  }
Â  Â  static void relax(int u, int v, int weight, vector<Vertex>& vertices, priority_queue<Vertex, vector<Vertex>, greater<Vertex>>& Q) {
Â  Â  Â  Â  if (vertices[v].distance > vertices[u].distance + weight) {
Â  Â  Â  Â  Â  Â  vertices[v].distance = vertices[u].distance + weight;
Â  Â  Â  Â  Â  Â  vertices[v].parent = u;
Â  Â  Â  Â  Â  Â  // é‡æ–°æ„å»ºä¼˜å…ˆé˜Ÿåˆ—
Â  Â  Â  Â  Â  Â  priority_queue<Vertex, vector<Vertex>, greater<Vertex>> updatedQ;
Â  Â  Â  Â  Â  Â  while (!Q.empty()) {
Â  Â  Â  Â  Â  Â  Â  Â  updatedQ.push(Q.top());
Â  Â  Â  Â  Â  Â  Â  Â  Q.pop();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  swap(Q, updatedQ);
Â  Â  Â  Â  }
Â  Â  }
Â  Â  static void dijkstra(Graph& G, int s) {
Â  Â  Â  Â  int V = G.getV();
Â  Â  Â  Â  vector<Vertex> vertices;
Â  Â  Â  Â  priority_queue<Vertex, vector<Vertex>, greater<Vertex>> Q;
Â  Â  Â  Â  initializeSingleSource(G, s, vertices);
Â  Â  Â  Â  for (Vertex v : vertices) {
Â  Â  Â  Â  Â  Â  Q.push(v);
Â  Â  Â  Â  }
Â  Â  Â  Â  while (!Q.empty()) {
Â  Â  Â  Â  Â  Â  Vertex uVertex = Q.top();
Â  Â  Â  Â  Â  Â  Q.pop();
Â  Â  Â  Â  Â  Â  int u = uVertex.index;
Â  Â  Â  Â  Â  Â  vector<Edge> neighbors = G.getAdj()[u];
Â  Â  Â  Â  Â  Â  for (Edge edge : neighbors) {
Â  Â  Â  Â  Â  Â  Â  Â  int v = edge.to;
Â  Â  Â  Â  Â  Â  Â  Â  int weight = edge.weight;
Â  Â  Â  Â  Â  Â  Â  Â  relax(u, v, weight, vertices, Q);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  printShortestPaths(s, vertices);
Â  Â  }
Â  Â  static void printShortestPaths(int source, const vector<Vertex>& vertices) {
Â  Â  Â  Â  cout << "Shortest Paths from source vertex " << source << ":" << endl;
Â  Â  Â  Â  for (const Vertex& v : vertices) {
Â  Â  Â  Â  Â  Â  cout << "Vertex " << v.index << ": Distance = " << v.distance << ", Parent = " << v.parent << endl;
Â  Â  Â  Â  }
Â  Â  }
};

int main() {
Â  Â  // æ„å»ºå›¾
Â  Â  Graph G(5);
Â  Â  G.addEdge(0, 1, 10);
Â  Â  G.addEdge(0, 2, 5);
Â  Â  G.addEdge(1, 2, 2);
Â  Â  G.addEdge(1, 3, 1);
Â  Â  G.addEdge(2, 3, 9);
Â  Â  G.addEdge(2, 4, 2);
Â  Â  G.addEdge(3, 4, 4);
Â  Â  int source = 0;
Â  Â  Dijkstra::dijkstra(G, source);
Â  Â  return 0;
}
```

## Bellman-Ford ç®—æ³•

Bellman-Ford ç®—æ³•è§£å†³çš„æ˜¯ä¸€èˆ¬æƒ…å†µä¸‹å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œè¾¹çš„æƒé‡å¯ä»¥ä¸ºè´Ÿå€¼ã€‚Bellman-Ford ç®—æ³•è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œè¯¥å¸ƒå°”å€¼è¡¨æ˜æ˜¯å¦å­˜åœ¨ä¸€ä¸ªä»æºç‚¹å¯è¾¾çš„è´Ÿæƒé‡çš„ç¯è·¯ã€‚è‹¥å­˜åœ¨è¿™æ ·ä¸€ä¸ªç¯è·¯ï¼Œåˆ™ç®—æ³•æç¤ºä¸å­˜åœ¨è§£å†³æ–¹æ¡ˆã€‚è‹¥ä¸å­˜åœ¨è¿™æ ·ä¸€ä¸ªç¯è·¯ï¼Œåˆ™ç®—æ³•ç»™å‡ºæœ€çŸ­è·¯å¾„å’Œå®ƒä»¬çš„æƒé‡ã€‚
æ³¨æ„ï¼šè´Ÿæƒé‡ç¯è·¯æ˜¯æ€»æƒé‡ä¸ºè´Ÿçš„ç¯è·¯ï¼Œè€Œéåªè¦æœ‰è´Ÿæƒé‡çš„è¾¹æ‰€å½¢æˆçš„ç¯è·¯å°±æ˜¯è´Ÿæƒé‡ç¯è·¯ã€‚
ä¼ªä»£ç å¦‚ä¸‹ï¼š

> $BELLMAN-FORD(G, w, s)$
> 1 $INITIALIZE-SINGLE-SOURCE(G, s)$  
> 2 for $i = 1$ to $|G.V| - 1$  
> 3 for each edge $(u, v) \in G.E$  
> 4 RELAX(u, v, w)  
> 5 for each edge $(u, v) \in G.E$  
> 6 if $v.d > u.d + w(u, v)$  
> 7 return FALSE
> 8 return TRUE

ç¤ºä¾‹å›¾ï¼š
![image](https://telegraph-image-eja.pages.dev/file/4af76847af45d3632f2c2.png)
//ä»ä¸Šå›¾æˆ‘ä»¬å¯ä»¥å‘ç°åœ¨æ¯ä¸€æ¬¡è¿­ä»£ä¸­éƒ½æœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„ d å€¼è¢«ç¡®å®šï¼Œä¸å†æ”¹å˜ã€‚ä¾æ¬¡è¢«ç¡®å®šçš„èŠ‚ç‚¹æ˜¯ï¼š$<s,y,x,t,z>$ï¼Œå› ä¸ºè¿™ä¾‹å­æ¯”è¾ƒç‰¹æ®Šï¼Œæ¯æ¬¡è¿­ä»£éƒ½åªç¡®å®šä¸€ä¸ªèŠ‚ç‚¹ï¼Œä½†åœ¨å®é™…æƒ…å†µä¸­ï¼Œé€šå¸¸å°‘äº$V-1$æ¬¡è¿­ä»£å°±å¯ä»¥ç¡®å®šå®Œï¼Œå› æ­¤æ­£ç¡®çš„è¡¨è¿°æ˜¯æ¯æ¬¡è¿­ä»£éƒ½è‡³å°‘æœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„ d å€¼è¢«ç¡®å®šã€‚

#### æ—¶é—´å¤æ‚åº¦åˆ†æ(é‚»æ¥è¡¨)

> $BELLMAN-FORD(G, w, s)$
> 1 $INITIALIZE-SINGLE-SOURCE(G, s)$ //$\Theta(V)$
> 2 for $i = 1$ to $|V| - 1$  
> 3 for each vertex $u\in V$  
> 4 for each vertex $v \in G.Adj[u]$  
> 5 RELAX(u, v, w) //2-5: $\Theta(V + E)$å¾ªç¯$V-1$æ¬¡
> 6 for each vertex $u\in V$  
> 7 for each vertex $v\in G.Adj[u]$
> 8 if $v.d > u.d + w(u, v)$
> 9 return FALSE //6-9: O(V + E)
> 10 return TRUE

å› æ­¤æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(V^2 + VE)$ï¼Œè‹¥$E=\Omega(V)$ï¼Œåˆ™æ—¶é—´å¤æ‚åº¦å¯ä»¥è¡¨ç¤ºä¸º$O(VE)$ã€‚

#### ç©ºé—´å¤æ‚åº¦åˆ†æ

> $BELLMAN-FORD(G, w, s)$
> 1 $INITIALIZE-SINGLE-SOURCE(G, s)$ //O(V)
> 2 for $i = 1$ to $|V| - 1$  
> 3 for each vertex $u\in V$  
> 4 for each vertex $v \in G.Adj[u]$  
> 5 RELAX(u, v, w)  
> 6 for each vertex $u\in V$  
> 7 for each vertex $v\in G.Adj[u]$
> 8 if $v.d > u.d + w(u, v)$
> 9 return FALSE  
> 10 return TRUE

å› æ­¤æ€»çš„ç©ºé—´å¤æ‚åº¦ä¸º O(V)

#### Theorem(Correctness of the Bellman-Ford algorithm)

å‡è®¾ ğº ä¸­ä¸å­˜åœ¨ä»æºç‚¹ ğ‘  å¯è¾¾çš„è´Ÿæƒé‡çš„ç¯è·¯ï¼Œåœ¨ç®—æ³•è¿è¡Œç»“æŸæ—¶ï¼Œå¯¹äºä»»æ„ä¸€æ¡è¾¹$(ğ‘¢,ğ‘£)âˆˆğ¸$ï¼Œæœ‰
$v.d=\delta(s, v)$
$\le \delta(s, u) + w(u, v)$
$= u.d + w(u, v)$
æ­¤æ—¶ç®—æ³•ä¸€å®šè¿”å› TRUE

å‡è®¾ G ä¸­å­˜åœ¨ä»æºç‚¹ s å¯è¾¾çš„è´Ÿæƒé‡ç¯è·¯ï¼Œè®¾è¯¥ç¯è·¯ä¸º$c=<v_0,v_1,...,v_k>$ï¼Œå…¶ä¸­$v_0=v_k$ï¼Œæœ‰

$$
\sum_{i=1}^{k}w(v_{i-1},v_{i})<0
$$

æ¥ä¸‹æ¥ç”¨åè¯æ³•ï¼Œå‡è®¾ç®—æ³•è¿”å› TRUEï¼Œåˆ™å¯¹äº$i=1,2,...,k$ï¼Œæœ‰$v_i.d \le v_{i-1}.d+w(v_{i-1},v_i)$

$$
\sum_{i=1}^k v_i.d \leq\sum_{i=1}^k (v_{i-1}.d + w(v_{i-1}, v_i))
$$

$$
=\sum_{i=1}^k v_{i-1}.d +\sum_{i=1}^k w(v_{i-1}, v_i)
$$

ç”±äº$v_0=v_k$ï¼Œé‚£ä¹ˆ

$$
\sum_{i=1}^k v_i.d =\sum_{i=1}^k v_{i-1}.d
$$

è§£å¾—

$$
0\leq\sum_{i=1}^k w(v_{i-1}, v_i)
$$

ä¸ä¸Šé¢çš„ä¸ç­‰å¼çŸ›ç›¾ï¼Œå› æ­¤ç®—æ³•è¿”å›çš„æ˜¯ FALSEï¼Œæ‰€ä»¥ bellman-ford ç®—æ³•èƒ½æ£€æŸ¥è´Ÿæƒé‡ç¯è·¯ï¼Œå› æ­¤èƒ½å¤„ç†è´Ÿè¾¹ã€‚

#### cpp ç®—æ³•å®ç°

```cpp
#include <iostream>
#include <vector>
#include <limits>
#include <queue>
#include <stack>
using namespace std;
// è¾¹ç»“æ„ä½“
struct Edge {
Â  Â  int to; Â  Â  Â  Â  Â  Â  // ç»ˆæ­¢é¡¶ç‚¹ç´¢å¼•
Â  Â  int weight; Â  Â  Â  Â  // è¾¹çš„æƒé‡
Â  Â  Edge(int t, int w) : to(t), weight(w) {}
};
// å›¾ç±»
class Graph {
private:
Â  Â  int V; Â  Â  Â  Â  Â  Â  Â  Â  Â // é¡¶ç‚¹æ•°é‡
Â  Â  vector<vector<Edge>> adj; Â  // é‚»æ¥è¡¨
public:
Â  Â  Graph(int vertices) : V(vertices) {
Â  Â  Â  Â  adj.resize(V);
Â  Â  }

Â  Â  void addEdge(int from, int to, int weight) {
Â  Â  Â  Â  adj[from].push_back(Edge(to, weight));
Â  Â  }

Â  Â  vector<vector<Edge>>& getAdj() {
Â  Â  Â  Â  return adj;
Â  Â  }

Â  Â  int getV() {
Â  Â  Â  Â  return V;
Â  Â  }
};
// åˆå§‹åŒ–å•æºæœ€çŸ­è·¯å¾„
void initializeSingleSource(Graph& G, int s, vector<int>& distance, vector<int>& predecessor) {
Â  Â  int V = G.getV();
Â  Â  distance.clear();
Â  Â  distance.resize(V, numeric_limits<int>::max());
Â  Â  predecessor.clear();
Â  Â  predecessor.resize(V, -1);
Â  Â  distance[s] = 0;
}
// æ¾å¼›æ“ä½œ
void relax(int u, int v, int weight, vector<int>& distance, vector<int>& predecessor) {
Â  Â  if (distance[v] > distance[u] + weight) {
Â  Â  Â  Â  distance[v] = distance[u] + weight;
Â  Â  Â  Â  predecessor[v] = u;
Â  Â  }
}
// Bellman-Ford ç®—æ³•
bool bellmanFord(Graph& G, int s, vector<int>& distance, vector<int>& predecessor) {
Â  Â  int V = G.getV();
Â  Â  initializeSingleSource(G, s, distance, predecessor);
Â  Â  // é‡å¤ |V| - 1 æ¬¡æ¾å¼›æ“ä½œ
Â  Â  for (int i = 1; i <= V - 1; ++i) {
Â  Â  Â  Â  for (int u = 0; u < V; ++u) {
Â  Â  Â  Â  Â  Â  for (Edge edge : G.getAdj()[u]) {
Â  Â  Â  Â  Â  Â  Â  Â  int v = edge.to;
Â  Â  Â  Â  Â  Â  Â  Â  int weight = edge.weight;
Â  Â  Â  Â  Â  Â  Â  Â  relax(u, v, weight, distance, predecessor);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â  // æ£€æŸ¥æ˜¯å¦å­˜åœ¨è´Ÿæƒå›è·¯
Â  Â  for (int u = 0; u < V; ++u) {
Â  Â  Â  Â  for (Edge edge : G.getAdj()[u]) {
Â  Â  Â  Â  Â  Â  int v = edge.to;
Â  Â  Â  Â  Â  Â  int weight = edge.weight;
Â  Â  Â  Â  Â  Â  if (distance[v] > distance[u] + weight) {
Â  Â  Â  Â  Â  Â  Â  Â  return false; // å­˜åœ¨è´Ÿæƒå›è·¯
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â  return true; // ä¸å­˜åœ¨è´Ÿæƒå›è·¯
}
// è¾“å‡ºæœ€çŸ­è·¯å¾„
void printShortestPath(int s, int v, const vector<int>& predecessor) {
Â  Â  stack<int> path;
Â  Â  int current = v;
Â  Â  while (current != s) {
Â  Â  Â  Â  path.push(current);
Â  Â  Â  Â  current = predecessor[current];
Â  Â  }
Â  Â  path.push(s);
Â  Â  cout << "Shortest path from " << s << " to " << v << ": ";
Â  Â  while (!path.empty()) {
Â  Â  Â  Â  cout << path.top() << " ";
Â  Â  Â  Â  path.pop();
Â  Â  }
Â  Â  cout << endl;
}

int main() {
Â  Â  // æ„å»ºå›¾
Â  Â  Graph G(5);
Â  Â  G.addEdge(0, 1, 6);
Â  Â  G.addEdge(0, 2, 7);
Â  Â  G.addEdge(1, 2, 8);
Â  Â  G.addEdge(1, 3, -4);
Â  Â  G.addEdge(1, 4, 5);
Â  Â  G.addEdge(2, 3, 9);
Â  Â  G.addEdge(2, 4, -3);
Â  Â  G.addEdge(3, 1, 7);
Â  Â  G.addEdge(4, 0, 2);
Â  Â  G.addEdge(4, 3, 7);
Â  Â  int source = 0;
Â  Â  vector<int> distance;
Â  Â  vector<int> predecessor;
Â  Â  if (bellmanFord(G, source, distance, predecessor)) {
Â  Â  Â  Â  cout << "No negative weight cycle detected." << endl;
Â  Â  Â  Â  for (int v = 0; v < G.getV(); ++v) {
Â  Â  Â  Â  Â  Â  if (v != source) {
Â  Â  Â  Â  Â  Â  Â  Â  printShortestPath(source, v, predecessor);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  Â  cout << "Negative weight cycle detected." << endl;
Â  Â  }
 Â  return 0;
}
```
