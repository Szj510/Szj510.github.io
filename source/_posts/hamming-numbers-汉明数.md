---
title: 汉明数 (Hamming Numbers)
date: 2024-05-27 10:00:00
tags: [算法, 刷题, codewars]
categories: [codewars]
description: 介绍汉明数的定义与求法，包含用三指针法生成汉明数序列的思路与 Python 实现示例。
mathjax: true
---

# codewars-汉明数

[(codewars 传送门)]([Hamming Numbers | Codewars](https://www.codewars.com/kata/526d84b98f428f14a60008da/))

## 引入

汉明数是形如$2^i3^j5^k$的正整数，`i, j, k`是非负整数，题目要求写一个函数计算出第 n 个最小汉明数
特别地：

- 第一个最小汉明数是 $1 = 2^03^05^0$
- 第二个最小汉明数是 $2 = 2^13^05^0$
- 第三个最小汉明数是 $3 = 2^03^15^0$
- 第四个最小汉明数是 $4 = 2^23^05^0$
- 第五个最小汉明数是 $5 = 2^03^05^1$
- 第六个最小汉明数是 $6 = 2^13^15^0$
  首先容易想到的就是暴力解法咯，套三层循环，同时也容易想到必定超时，因此需要设计。

## 思路

第一个问题我觉得就是要考虑汉明数是用数组存着每一个最小汉明数，还是用一个变量存着然后一直更新变量的值。通过观察发现每一个最小汉明数都是由前面的某一个最小汉明数进行乘 2 或乘 3 或乘 5 得到的，因而可以知道的是每一个最小汉明数都得存起来，排除了只用一个变量存储的可能。

现在就得想如何知道进行什么操作才能做到每一次都是最小的。首先，我们先假设现在前面已经有若干个最小汉明数存着了，现在要求第 n 个，这第 n 个最小汉明数是由 2 或 3 或 5 乘以前面某一个最小汉明数得到，这里有两个未知的量，因此我们先假设某个量是定的，比如假设要进行的是乘 2 操作，接下来就要从前面的最小汉明数中找一个与之相乘，使其乘积最小，那么很显然，我们要找的那个最小汉明数肯定是越前越好，所以就引出关键问题了，我们得知道前面的最小汉明数有没有被用过，或者说有没有被乘 2 这个操作用过，被用过的话就代表着在第 n 个前面肯定是有一个最小汉明数是对其进行乘 2 操作得到的，因此第 n 个就得在后面找第一个没有被用过的，因此我们需要东西去记录用过的汉明数，不难发现只用一个标记就够了，通过右移来更新标记，在标记前面的最小汉明数都是被用过的。因为前面假设的是乘 2 操作，那么乘 3 或乘 5 是同样的情况，所以需要三个标记去记录，这里把标记记为`i, j, k`分别代表着 2，3，5 ，这里的标记其实就是最小汉明数数组的索引，注意此`ijk`跟题目定义的`ijk`不是一个东西，切勿混淆。

下一步就得考虑一下初始状态了，存储最小汉明数的数组初始化首先得搞个数字存进去吧，那么是存 0 好呢还是把第一个最小汉明数丢进去呢。假设先存个 0，那么`i, j, k`初始化都得是 0，毕竟数组里暂时只有 0 这个索引有数字，那么第一个最小汉明数按上面的操作的话就求不出来了，因为 0 乘任何数都是 0。假设先存个 1，然后从第二个最小汉明数开始按照上面分析的操作进行，2,3,5 分别乘 1，得出 2 最小，接着把 2 加在最小汉明数数组中，然后还得更新 2 所对应的 i 标记右移一个单位，这时`i == 1`，此时 i 指向的是数组中索引为 1 的数，即 2，其它两个标记还是 0，为了验证并理解，再举两个例子推演。下面到第三个最小汉明数，为了方便叙述，我把数组实际化为 nums，那么第三个最小汉明数就要在$nums[i] * 2=4$ ，$nums[j]*3=3$，$nums[k]*5=5$中的最小值取得，即是中间的 3，把它加入到 nums 中，并把 j 右移一位，现在 i 和 j 都是 1，k 是 0,。接着第四个最小汉明数就要从$nums[i] * 2=4$ ，$nums[j]*3=6$，$nums[k]*5=5$中取得，即是 4，把 4 加入到 nums，i 再次右移一位，后面的同理。

可能说的还是有点模糊，下面用一张图来进行具象化：
![image](https://telegraph-image-eja.pages.dev/file/12bb4c8ae58643b244279.jpg)
那就直接上代码

```python
def hamming(n):
    i, j, k = 0, 0, 0
    nums = [1]
    while len(nums) < n:
        nums.append(min(nums[i]*2, nums[j]*3, nums[k]*5))
        if nums[-1] == nums[i]*2: i += 1
        if nums[-1] == nums[j]*3: j += 1
        if nums[-1] == nums[k]*5: k += 1
    return nums[-1]
```

没想到做完两题就直接从 8kyu 到 6kyu 了
