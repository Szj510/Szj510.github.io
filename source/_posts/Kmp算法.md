---
title: KMP 字符串匹配算法
date: 2024-06-11 22:03:00
tags: [算法, 字符串, KMP, 模式匹配]
categories: [算法]
description: KMP字符串匹配算法详解，包括算法原理、前缀函数、时间复杂度分析与实现。
mathjax: true
---

# 字符串匹配问题

## 写在前面

首先字符串匹配问题是什么很容易知道,如下图
![image](https://telegraph-image-eja.pages.dev/file/f6379e3c35441555f747d.png)
这在搜索引擎,文本编辑器等都有其身影。

> 字符串匹配问题可以正式地表述如下：

给定文本是一个长度为  𝑛  的数组  𝑇[1 : 𝑛] ，模式(串)是一个长度为  𝑚(𝑚≤𝑛) 的数组  𝑃[1 : 𝑚]，𝑃  和  𝑇  中的所有元素都是来自一个有限字母集$\Sigma$的字符。例如，$\Sigma$可以是$\{0, 1\}$，也可以是$\{a, b, ... , z\}$。字符数组  𝑃  和  𝑇  通常称为字符串。如上图所示，模式 P 伴随着 T 中的偏移量 s 出现(或者，等价地，模式 P 从文本 T 中的 s + 1 位置开始)。
若$0\le 𝑠\le 𝑛−𝑚$且$𝑇[𝑠+1:𝑠+𝑚]=𝑃[1:𝑚]$，即$𝑇[𝑠+𝑗]=𝑃[𝑗]$，其中$1≤𝑗≤𝑚$，那么模式  𝑃  在文本  𝑇  偏移  𝑠  后出现，称  𝑠  是有效偏移，否则 𝑠  就是无效偏移，而字符串匹配问题就是要找出模式  𝑃  出现在给定的文本  𝑇  中所有的有效偏移的问题。
为了方便，我们将$𝑃[1:𝑚]$的前  𝑘  个字符组成的前缀$𝑃[1:𝑘]$记作$𝑃[:𝑘]$，与 python 类似。特别地，有$𝑃[:0]=𝜀$和$𝑃[:𝑚]=𝑃=𝑃[1:𝑚]$。于是，字符串匹配问题可以表述为找出所有偏移$0≤𝑠≤𝑛−𝑚$，使得$𝑃⊐𝑇[:𝑠+𝑚]$。

### 术语与符号

在进入正式介绍前，需要引入一些术语和符号，以便形式化表示。

- $\Sigma ^*$：所有使用$\Sigma$中的字符所构成的有限长度的字符串的集合。
- $\varepsilon$：长度为零的字符串，$\varepsilon \in \Sigma ^*$。
- |x|：字符串 x 的长度。
- xy：字符串 x 和字符串 y 的连结(concatenation)，反正就是把 y 填补到 x 的后面形成新的字符串。
- $w⊏x$：w 是 x 的前缀，对于某个字符串$𝑦\in \Sigma ^*$，  有$𝑥=𝑤𝑦$，显然$|𝑤|\le|𝑥|$，若$|𝑤|<|𝑥|$，则称 w 是真前缀。
- $𝑤⊐𝑥$：w 是 x 的后缀，对于某个字符串$𝑦\in \Sigma ^*$，  有$𝑥=yw$，显然$|𝑤|\le|𝑥|$，若$|𝑤|<|𝑥|$，则称 w 是真后缀，把 ⊐ 当做>箭头就行，箭头朝前就是前缀，朝后就是后缀。
  注：
- $\varepsilon$是所有字符串的前缀和后缀。
- 对于任意字符串  𝑥，𝑦 ，任意字符  𝑎 ，$𝑥⊐𝑦$当且仅当$𝑥𝑎⊐𝑦𝑎$。
- $⊏和⊐$关系具有传递性。

### 引理

Overlapping-suffix lemma
假设  𝑥，𝑦 ，𝑧  是字符串，且满足$𝑥⊐𝑧和𝑦⊐𝑧$。若$|𝑥|≤|𝑦|$，则$𝑥⊐𝑦$。若$|𝑥|≥|𝑦|$，则$𝑦⊐𝑥$。若$|𝑥|=|𝑦|$，则$𝑥=𝑦$，这在直觉上也很正确，下图示例：
![image](https://telegraph-image-eja.pages.dev/file/f583587ea80b1db76708c.png)
当然也有 Overlapping-prefix lemma 与之对应，不再赘述。

## 朴素字符串匹配算法(The naive string-matching algorithm)

字符串匹配问题容易想到的就是暴力解法了，如下图：
![image](https://telegraph-image-eja.pages.dev/file/473bf783a0d0eaa638e9b.png)
伪代码如下：
![image](https://telegraph-image-eja.pages.dev/file/2f7b3445f88cd844aedba.png)
cpp 代码示例：

```cpp
void Naive_String_Matcher(string T, string P, int n, int m) {
    bool found;
    for(int s = 0; s < n - m; s++) {
        found = true;
        for(int i = 0; i < m; i++) {
            if(T[s + i] != P[i]) {
                found = false;
                break;
            }
        }
        if(found) {
            cout << s << endl;
        }
    }
}
```

容易得到时间复杂度为$\Theta((n - m + 1)m)$，当然这也远远不是解决这个问题的最优方法，因为它没有利用前面比较过的有用的信息。

## Rabin-Karp 算法

在介绍著名的 kmp 算法前，我们先来了解一下 Rabin-Karp 算法。
Rabin 和 Karp 提出了一种字符串匹配算法，它在实践中表现良好，也可以推广到其他相关问题的算法，如二维模式匹配。Rabin-Karp 算法使用$\Theta(m)$预处理时间，其最坏情况下的运行时间为$\Theta((n - m + 1)m)$，没错，和朴素算法一样，然而，基于某些假设，它的平均情况运行时间更好。

在一般情况下，我们可以假设每个字符都是一个以基数 d 表示的数字，因此它有 d 个数值在范围为 0 到 d - 1，，其中$d=|\Sigma|$，然后，我们可以用长度为  𝑘  的  𝑑  进制数来表示由  𝑘  个连续的字符组成的字符串。为了简单说明，让我们假设$\Sigma=\{0,1,2,...,9\}$，例如，由 5 个连续的字符组成的字符串 31415，可以用长度为 5 的十进制数 31,415 来表示(为了区分字符串和数字，在这里数字采用逗号作为千位分隔符)。因为我们将输入字符同时解释为图形符号和数字，所以在本节中可以方便地将它们表示为数字。

给定模式$𝑃[1:𝑚]$，设其对应的十进制数为  𝑝 。给定文本$𝑇[1:𝑛]$，设其子字符串$𝑇[𝑠+1:𝑠+𝑚]$对应的十进制数为$𝑡_𝑠(s = 0,1,...,n-m)$。当且仅当$𝑇[𝑠+1:𝑠+𝑚]=𝑃[1:𝑚]$时，有$t_s=p$，此时的 s 为一个有效偏移。

那么 p 怎么求呢？可以先从我们熟知的二进制数入手，就是$\Sigma=\{0,1\}$的情况，那么字符串 100101 对应的二进制数即为 37，相信怎么计算已然熟悉，但我们要设计尽可能快的算法来计算，这里使用霍纳规则(Horner's rule)：

$$
𝑝=𝑃[𝑚]+𝑑(𝑃[𝑚−1]+𝑑(𝑃[𝑚−2]+⋯+𝑑(𝑃[2]+𝑑𝑃[1])⋯))
$$

```cpp
double hornerRule(const std::vector<double>& coefficients, double x) {
    double result = 0.0;
    for (int i = 0; i < coefficients.size(); ++i) {
        result = result * x + coefficients[i];
    }
    return result;
}
```

这样就可以在$\Theta(m)$内求出 p，求$t_0$同理，但后面的$t_s$就不再用这种求法了，还是有点慢，因此我们可以找出$t_{s+1}和t_s$之间的关系：
$t_s=T[𝑚+s]+𝑑(T[𝑚+s−1]+𝑑(T[𝑚+s−2]+⋯+𝑑(T[s+2]+𝑑T[s+1])⋯))$
$t_{s+1}=T[𝑚+s+1]+𝑑(T[𝑚+s]+𝑑(T[𝑚+s−1]+⋯+𝑑(T[s+3]+𝑑T[s+2])⋯))$
观察相同的式子并进行进一步配凑：
$dt_s=d(T[𝑚+s]+𝑑(T[𝑚+s−1]+𝑑(T[𝑚+s−2]+⋯+𝑑(T[s+2]+𝑑T[s+1])⋯))$
$dt_s-d^mT[s+1]=d(T[𝑚+s]+𝑑(T[𝑚+s−1]+𝑑(T[𝑚+s−2]+⋯+𝑑(T[s+2])⋯))$
因此有：
$t_{s+1}=T[m+s+1]+d(t_s-d^{m-1}T[s+1])$

容易得到$d^{m-1}$是一个常数，因此我们可以预先计算它，如果用简单循环的话时间为$O(m)$，而用[快速幂算法](https://oi-wiki.org/math/binary-exponentiation/)的时间是$O(logm)$。这样一来，执行一次$t_{s+1}和t_s$的等式只需要$\Theta(1)$时间。因此，我们可以在求出$t_0$后在$\Theta(n-m)$时间内依次求出$t_1,...,t_{n-m}$。所以，我们可以在$\Theta(m)$的预处理时间和$\Theta(n-m+1)$的匹配时间内找出模式$𝑃[1:𝑚]$在文本$𝑇[1:𝑛]$中的所有出现的位置。

当  𝑃  足够短且$\Sigma$足够小时，对 p 和$t_s$的算术运算只需要常数时间，这个方案效果很好。但如果  𝑃  很长，或者$\Sigma$很大导致转化为数字的基数 d 很大，那么就无法在常数时间内计算出  𝑝  或$𝑡_𝑠$。幸运的是，这个问题可以解决。
![image](https://telegraph-image-eja.pages.dev/file/aa3fb3c206ce349a6dfb2.png)
如图，可以通过选取合适的模 q 来解决，使得  𝑑𝑞  在一个计算字长内，满足进行单精度计算的条件。通常，我们会选择一个形式简单的素数，比如形如$2^k−1$(费马素数)或者$2^k +1$(梅森素数)的数，因为这样的数在二进制计算机中可以通过位移操作和加法快速进行模运算。

所以等式相应地变为：
$t_{s+1}=(T[m+s+1]+d(t_s-T[s+1]h))$ mod q，其中$h=d^{m-1}$ mod q
为了好看 c 图，改一下位置：
$t_{s+1}=((t_s-T[s+1]h)d+T[m+s+1])$ mod q

但是模  𝑞  后的结果并不完美，因为$𝑡_𝑠=𝑝$ (mod 𝑞)并不意味着$𝑡_𝑠=𝑝$，它只是必要条件，因此，若$𝑡_𝑠≠𝑝$ (mod 𝑞)，则$𝑡_𝑠≠𝑝$肯定成立。因此可以把测试$𝑡_𝑠=𝑝$ (mod 𝑞)是否成立作为一种快速的方法来排除无效偏移  𝑠 。当$𝑡_𝑠=𝑝$ (mod 𝑞)成立时，称为一个命中(hit)，然后我们还需要进一步测试此时$𝑡_𝑠=𝑝$是否成立，即检查$𝑃[1:𝑚]=𝑇[𝑠+1:𝑠+𝑚]$是否成立。若$𝑡_𝑠=𝑝$，则  𝑠  是一个有效偏移，若$𝑡_𝑠≠𝑝$，则是一个假命中(spurious hit)。若  𝑞  足够大，则出现假命中的期望次数会更少，从而降低额外检查的代价。

下面给出伪代码：
![image](https://telegraph-image-eja.pages.dev/file/00850934615eb00424f2a.png)
t 的下标仅仅是为了逻辑清晰，去掉下标也能正确运行。
最坏情况下的匹配时间是$\Theta((n-m+1)m)$，因为如果$P=a^m,T=a^n$，这样每个偏移都是有效的，就都得检查一遍。
所以为什么说该算法在实践中表现良好呢？
在许多应用中，我们希望少一些有效偏移，比如只有常数  𝑐  个。在这样的应用中，加上处理假命中所需时间，该算法的期望匹配时间为$𝑂((𝑛−𝑚+1)+𝑐𝑚)=𝑂(𝑛+𝑚)$，又因为$m\le n$，则期望匹配时间为$O(n)$。

## 用有限自动机进行字符串匹配(String matching with finite automata)

### 有限自动机(Finite automata)

一个有限自动机  𝑀  是一个 5 元组$(𝑄,𝑞_0,𝐴,\Sigma,\delta)$：

- Q 是一个有限状态集。
- $𝑞_0\in 𝑄$是起始状态。
- $𝐴⊆𝑄$是一个接受状态集。
- $\Sigma$是一个有限输入字母表。
- $\delta$是一个从$𝑄\times \Sigma$到  𝑄  的函数，称为  𝑀  的转移函数。
  ![image](https://telegraph-image-eja.pages.dev/file/a6d4558c65809f64f66c7.png)
  说实话我第一眼看到这图就想到了数字逻辑电路里面的状态转化表和状态转化图
