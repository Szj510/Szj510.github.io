<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Elementary Graph Algorithms</title>
    <url>/2024/04/21/Elementary-Graph-Algorithms/</url>
    <content><![CDATA[<h1 id="Elementary-Graph-Algorithms"><a href="#Elementary-Graph-Algorithms" class="headerlink" title="Elementary Graph Algorithms"></a>Elementary Graph Algorithms</h1><h2 id="Representations-of-graphs"><a href="#Representations-of-graphs" class="headerlink" title="Representations of graphs"></a>Representations of graphs</h2><p>$$<br>G = (V, E)<br>$$<br>$G \to Graph, V \to Vertex, E \to Edge$, 式子说明图是由顶点和边这两个元素组成，那么只要把顶点和边表示出来，图就表示出来了。其中有两种方法，一种是邻接表表示，一种是用矩阵表示，根据不同的情景需要会选取不同的表示方法。</p>
<h3 id="adjacency-list"><a href="#adjacency-list" class="headerlink" title="adjacency-list"></a>adjacency-list</h3><p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_list.png" alt="list"><br>// 邻接表可用链表，也可用哈希表</p>
<blockquote>
<p>If $G$ is a directed graph, the sum of the lengths of all the adjacency lists is |E|.<br>If $G$ is an undirected graph, the sum of the lengths of all the adjacency lists is 2|E|.</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//下面是无向图的示例，有向图需要修改部分method代码</span></span><br><span class="line"><span class="comment">//为了方便添加与删除顶点，以及简化代码，这里使用列表（动态数组）来代替链表。</span></span><br><span class="line"><span class="comment">//使用哈希表来存储邻接表，key为顶点实例，value为该顶点的邻接顶点列表（链表）。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="type">int</span> value) : <span class="built_in">val</span>(value) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjList</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::unordered_map&lt;Vertex *, std::vector&lt;Vertex *&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(std::vector&lt;Vertex *&gt; &amp;vec, Vertex *vet)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (vec[i] == vet) {</span><br><span class="line">                vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GraphAdjList</span>(<span class="type">const</span> std::vector&lt;std::vector&lt;Vertex *&gt;&gt; &amp;edges) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> std::vector&lt;Vertex *&gt; &amp;edge : edges) {</span><br><span class="line">            <span class="built_in">addVertex</span>(edge[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">addVertex</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">addEdge</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> adjList.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(Vertex *vet1, Vertex *vet2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1 == vet2)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">"不存在顶点"</span>);</span><br><span class="line">        adjList[vet1].<span class="built_in">push_back</span>(vet2);</span><br><span class="line">        adjList[vet2].<span class="built_in">push_back</span>(vet1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(Vertex *vet1, Vertex *vet2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1 == vet2)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">"不存在顶点"</span>);</span><br><span class="line">        <span class="built_in">remove</span>(adjList[vet1], vet2);</span><br><span class="line">        <span class="built_in">remove</span>(adjList[vet2], vet1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(Vertex *vet)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        adjList[vet] = std::<span class="built_in">vector</span>&lt;Vertex *&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(Vertex *vet)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">"不存在顶点"</span>);</span><br><span class="line">        adjList.<span class="built_in">erase</span>(vet);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;adj : adjList) {</span><br><span class="line">            <span class="built_in">remove</span>(adj.second, vet);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"邻接表 ="</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;adj : adjList) {</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> &amp;key = adj.first;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> &amp;vec = adj.second;</span><br><span class="line">            std::cout &lt;&lt; key-&gt;val &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="built_in">printVector</span>(<span class="built_in">vetsToVals</span>(vec));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vetsToVals</span><span class="params">(<span class="type">const</span> std::vector&lt;Vertex *&gt; &amp;vec)</span> </span>{</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> Vertex *vet : vec) {</span><br><span class="line">            vals.<span class="built_in">push_back</span>(vet-&gt;val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vals;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vec) {</span><br><span class="line">            std::cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h4 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h4><blockquote>
<p>加权图即边是有权值的，可添加 Edge 类来实现</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> { </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	Vertex *destination; </span><br><span class="line">	<span class="type">int</span> weight; </span><br><span class="line">	<span class="built_in">Edge</span>(Vertex *dest, <span class="type">int</span> w) : <span class="built_in">destination</span>(dest), <span class="built_in">weight</span>(w) {} </span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> { </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> val; <span class="comment">// 顶点的值 </span></span><br><span class="line">	std::vector&lt;Edge*&gt; adjList; <span class="comment">// 邻接列表 </span></span><br><span class="line">	<span class="built_in">Vertex</span>(<span class="type">int</span> v) : <span class="built_in">val</span>(v) {} </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>The adjacency-list representation is quite robust in that you can modify it to support many other graph variants.<br>// 上方的代码顶点都是唯一的实例，还可以往其添加属性，这就体现了邻接表的灵活性，加上它的动态性以及内存效率等的优势，共同构建了其健壮性，使其能够支持很多其它的图变体。</p>
</blockquote>
<blockquote>
<p>邻接表查询边的存在性较慢，邻接矩阵表示较快</p>
</blockquote>
<h3 id="adjacency-matrix"><a href="#adjacency-matrix" class="headerlink" title="adjacency-matrix"></a>adjacency-matrix</h3><p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_matrix.png" alt="matrix"></p>
<blockquote>
<p>in an undirected graph, the adjacency matrix A of an undirected graph is its own transpose: $A = A^T$<br>// 正是因为有这一性质，在一些应用中，只选择存储对角线以上的元素来提高内存效率。</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjMat</span> {</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vertices;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; adjMat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphAdjMat</span>(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vertices, <span class="type">const</span> std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vertices) {</span><br><span class="line">            <span class="built_in">addVertex</span>(val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;edge : edges) {</span><br><span class="line">            <span class="built_in">addEdge</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> vertices.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">size</span>();</span><br><span class="line">        vertices.<span class="built_in">push_back</span>(val);</span><br><span class="line">        adjMat.<span class="built_in">emplace_back</span>(std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt; &amp;row : adjMat) {</span><br><span class="line">            row.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"顶点不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">        vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + index);</span><br><span class="line">        adjMat.<span class="built_in">erase</span>(adjMat.<span class="built_in">begin</span>() + index);</span><br><span class="line">        <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt; &amp;row : adjMat) {</span><br><span class="line">            row.<span class="built_in">erase</span>(row.<span class="built_in">begin</span>() + index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= <span class="built_in">size</span>() || j &gt;= <span class="built_in">size</span>() || i == j) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"顶点不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">        adjMat[i][j] = <span class="number">1</span>;</span><br><span class="line">        adjMat[j][i] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= <span class="built_in">size</span>() || j &gt;= <span class="built_in">size</span>() || i == j) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"顶点不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">        adjMat[i][j] = <span class="number">0</span>;</span><br><span class="line">        adjMat[j][i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"顶点列表 = "</span>;</span><br><span class="line">        <span class="built_in">printVector</span>(vertices);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"邻接矩阵 ="</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">printVectorMatrix</span>(adjMat);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vec) {</span><br><span class="line">            std::cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVectorMatrix</span><span class="params">(<span class="type">const</span> std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;row : matrix) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> val : row) {</span><br><span class="line">                std::cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            }</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>邻接矩阵也可表示有权图，但空间浪费明显，无论稀疏还是密集：<br>在稀疏图中，尽管边的数量很少，但邻接矩阵仍然需要为每个可能的顶点对（即矩阵中的每个元素）分配空间。大多数这些顶点对之间实际上是没有边的，因此这些空间是浪费的。<br>   在密集图中，虽然边的数量很多，但邻接矩阵仍然需要为每个顶点对分配空间，即使某些顶点对之间可能有多个边。例如，如果图中有两个顶点之间有 5 条边，邻接矩阵中的对应元素就需要存储这 5 条边的权重信息，而实际上只需要存储一个权重信息就足够了。</p>
</blockquote>
<blockquote>
<p>图规模较小时倾向于使用邻接矩阵</p>
</blockquote>
<h3 id="效率对比"><a href="#效率对比" class="headerlink" title="效率对比"></a>效率对比</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">adjacency-matrix</th>
<th align="center">adjacency-list(ll)</th>
<th align="center">adjacency-list(hash)</th>
</tr>
</thead>
<tbody><tr>
<td align="center"> 边的存在性</td>
<td align="center"> $O(1)$</td>
<td align="center">$O(E)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center"> 添加边</td>
<td align="center"> $O(1)$</td>
<td align="center">$O(1)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center"> 删除边</td>
<td align="center"> $O(1)$</td>
<td align="center">$O(E)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center"> 添加顶点</td>
<td align="center"> $O(V)$</td>
<td align="center">$O(1)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center"> 删除顶点</td>
<td align="center"> $O(V^2)$</td>
<td align="center">$O(V+E)$</td>
<td align="center">$O(V)$</td>
</tr>
<tr>
<td align="center"> 内存空间占用</td>
<td align="center"> $O(V^2)$</td>
<td align="center">$O(V+E)$</td>
<td align="center">$O(V+E)$</td>
</tr>
</tbody></table>
<h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><div class="callout question">
  Given an adjacency-list representation of a directed graph, how long does it take
  to compute the out-degree of every vertex? How long does it take to compute the
  in-degrees?
</div>
   
<blockquote>
<p>题目是求基于邻接表表示的有向图，计算每个顶点的出度，入度的时间复杂度分别是多少。<br>   顶点的出度很容易，每个顶点的邻接表存储的就是其指向的顶点，故直接计算每个顶点的邻接表<br>   长度即为其出度，可知要遍历整个图，因此时间复杂度为 O (V+E)。<br>顶点的入度的话，邻接表里存储的每个顶点都是被指向的顶点，也就是说在邻接表里的顶点每出现一次就表明其被指向一次，即入度 + 1，因此时间复杂度也为 O (V+E)。</p>
</blockquote>
<div class="callout question">
  The transpose of a directed graph $G = (V, E)$ is the graph $G^T = (V, E^T)$, where $E^T = \{(v, u) \in V \times V : (u, v) \in E\}$. That is, $G^T$ is $G$ with all its edges reversed.
   Describe efficient algorithms for computing $G^T$ from $G$, for both the adjacency-
   list and adjacency-matrix representations of $G$. Analyze the running times of your
   algorithms.
</div>

<blockquote>
<p>这题说的是有向图的转置，即把边的方向都反过来，描述计算 $G^T$ 的算法。<br>伪代码如下</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">transposeAdjList</span><span class="params">(G)</span>:  //时间复杂度：O(V+E)</span></span><br><span class="line"><span class="function">    GT =</span> empty adjacency list <span class="keyword">for</span> each vertex in G</span><br><span class="line">    <span class="keyword">for</span> each vertex u in G:</span><br><span class="line">        <span class="keyword">for</span> each vertex v in adjacency list of u:</span><br><span class="line">            <span class="function">add u to adjacency list of v in GT</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> GT</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">function <span class="title">transposeAdjMatrix</span><span class="params">(G)</span>:  //时间复杂度：O(V^<span class="number">2</span>)</span></span><br><span class="line"><span class="function">    GT =</span> empty matrix of same size as G</span><br><span class="line">    <span class="keyword">for</span> each vertex u in G:</span><br><span class="line">        <span class="keyword">for</span> each vertex v in G:</span><br><span class="line">            <span class="keyword">if</span> G[u][v] == <span class="number">1</span>:</span><br><span class="line">                GT[v][u] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> GT</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>equivalent undirected graph 等效无向图</p>
</blockquote>
<blockquote>
<p>大概就是保留原有向图所有顶点，边的方向被忽略，不包含任何自环</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">convertToUndirectedGraph</span><span class="params">(G)</span>:</span></span><br><span class="line"><span class="function">    G0 =</span> <span class="keyword">new</span> adjacency list <span class="keyword">for</span> each vertex in G</span><br><span class="line">    <span class="keyword">for</span> each vertex u in G:</span><br><span class="line">        <span class="keyword">for</span> each vertex v in adjacency list of u:</span><br><span class="line">            <span class="keyword">if</span> u ≠ v <span class="built_in">and</span> (u, v) <span class="keyword">not</span> in G0 <span class="built_in">and</span> (v, u) <span class="keyword">not</span> in G0:<span class="comment">//忽略方向</span></span><br><span class="line">                <span class="built_in">add</span> (u, v) to G0</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> u = v:<span class="comment">//排除自环</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> G0</span><br></pre></td></tr></tbody></table></figure>

<div class="callout question">
  The square of a directed graph $G = (V, E)$ is the graph $G^2 = (V, E)$ such that
   $(u, v) \in E^2$ if and only if $G$ contains a path with at most two edges between
   u and v. Describe efficient algorithms for computing $G^2$ from $G$ for both the
   adjacency-list and adjacency-matrix representations of $G$. Analyze the running
   times of your algorithms.
</div>

<p>// 这题提出了平方有向图的定义，就是边 (u, v) 在 $G^2$ 中当且仅当在 $G$ 中包含了 $u \to v$ 不超过两条边的路径，换句话说，$G^2$ 包含了 $G$ 中所有顶点对之间长度不超过 2 的路径，要求描述计算 $G^2$ 的算法。(原图中有自环的话平方图也会有，如果想排除自环就添加控制条件约束即可)</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度：O(|V|^2+|V|E).</span></span><br><span class="line"><span class="function">Algorithm <span class="title">computeSquareAdjList</span><span class="params">(G)</span>:</span></span><br><span class="line"><span class="function">    // Initialize the adjacency list for the square graph G^<span class="number">2</span></span></span><br><span class="line"><span class="function">    G2 =</span> empty adjacency list <span class="keyword">for</span> each node in V</span><br><span class="line">    <span class="comment">// Iterate over each node u in the graph</span></span><br><span class="line">    <span class="keyword">for</span> each u in V:</span><br><span class="line">        <span class="comment">// Set of nodes reachable from u within one step</span></span><br><span class="line">        direct_neighbors = <span class="built_in">set</span>(G[u])</span><br><span class="line">        <span class="comment">// Set of nodes reachable from u within two steps</span></span><br><span class="line">        two_step_neighbors = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment">// Iterate over each direct neighbor v of u</span></span><br><span class="line">        <span class="keyword">for</span> each v in direct_neighbors:</span><br><span class="line">            <span class="comment">// Add direct neighbors to G^2</span></span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> in G2[u]:</span><br><span class="line">                G2[u].<span class="built_in">append</span>(v)</span><br><span class="line">            <span class="comment">// Iterate over each neighbor w of v</span></span><br><span class="line">            <span class="keyword">for</span> each w in G[v]:</span><br><span class="line">                <span class="comment">// Add w as a two-step neighbor of u if not already added</span></span><br><span class="line">                <span class="keyword">if</span> w != u <span class="keyword">and</span> w <span class="keyword">not</span> in direct_neighbors <span class="keyword">and</span> w <span class="keyword">not</span> in two_step_neighbors:</span><br><span class="line">                    two_step_neighbors.<span class="built_in">add</span>(w)</span><br><span class="line">                    G2[u].<span class="built_in">append</span>(w)</span><br><span class="line">    <span class="keyword">return</span> G2</span><br><span class="line"><span class="comment">//时间复杂度：(|V|^3)</span></span><br><span class="line">Algorithm <span class="built_in">computeSquareAdjMatrix</span>(G):</span><br><span class="line">    <span class="comment">// Initialize the adjacency matrix for the square graph G^2</span></span><br><span class="line">    n = number of nodes in V</span><br><span class="line">    A2 = <span class="keyword">new</span> matrix of size n x n filled with <span class="number">0</span>s</span><br><span class="line">    <span class="comment">// Calculate the square of the adjacency matrix</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">0</span> to n - <span class="number">1</span>:</span><br><span class="line">            <span class="comment">// A2[i][j] is 1 if there is a path of length at most 2 from i to j</span></span><br><span class="line">            <span class="keyword">if</span> A[i][j] == <span class="number">1</span>:</span><br><span class="line">                A2[i][j] = <span class="number">1</span>  <span class="comment">// Direct edge (i, j)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> k = <span class="number">0</span> to n - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> A[i][k] == <span class="number">1</span> <span class="keyword">and</span> A[k][j] == <span class="number">1</span>:</span><br><span class="line">                        A2[i][j] = <span class="number">1</span>  <span class="comment">// Path of length 2 from i to j</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A2</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>此题拓展：$G^k$ 包含了 $G$ 中所有顶点对之间长度不超过 $k$ 的路径</p>
</blockquote>
<div class="callout question">
  Most graph algorithms that take an adjacency-matrix representation as input require $\Omega (V^2)$ time, but there are some exceptions. Show how to determine whether a directed graph $G$ contains a universal sink--a vertex with in-degree |V| - 1 and out-degree 0--in $O(V)$ time, given an adjacency matrix for $G$.
</div>

<p>// 这题说的是很多基于邻接矩阵的图算法都需要 $\Omega (V^2)$ 的时间复杂度，但也有一些例外，比如查看一个有向图是否含有全局汇点（入度为 | V| - 1，出度为 0）。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">findUniversalSink</span><span class="params">(G)</span>:</span></span><br><span class="line"><span class="function">    candidate =</span> <span class="number">1</span>  <span class="comment">//这里索引从1开始，candidate为候选全局汇点</span></span><br><span class="line">    <span class="keyword">for</span> v from <span class="number">2</span> to |V|:</span><br><span class="line">        <span class="keyword">if</span> G[candidate][v] == <span class="number">1</span>: <span class="comment">//找到第一个出度为0的点作为最终的候选点</span></span><br><span class="line">            candidate = v</span><br><span class="line"></span><br><span class="line">    inDegree = <span class="number">0</span></span><br><span class="line">    outDegree = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> u from <span class="number">1</span> to |V|:</span><br><span class="line">        inDegree += G[u][candidate]</span><br><span class="line">        outDegree += G[candidate][u]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> inDegree == |V| - <span class="number">1</span> <span class="keyword">and</span> outDegree == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> candidate</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"No universal sink found"</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>这里确定候选汇点的形式很讲究，首先主对角线上元素都为 0，因此无参考价值，故只在其上方查找。只要遇到一个 1，就换到下一行（即下一个顶点），因为全局汇点没有出边，只要是 0，就在该行一直往后验证。到这里可能就有疑问（其实就是我的疑问罢了）：假设候选汇点一直都是 1，那么就只检查了第一行，其它行都没检查呢，为啥只要这候选汇点不是真的全局汇点，整个图就没有全局汇点。其实每检查一条边就相当于检查了一个顶点，比如，如果 $G [1][2] == 0$ 的话，就说明第二个顶点没有接受第一个顶点的入边，这同样是不符合全局汇点定义的，因为全局汇点是除了它自身，其它顶点都会指向它，因此该次检查排除了第二个顶点。如果 $G [1][3]$ 也 == 0 的话，那就排除了第三个顶点，以此类推。所以无论 $G [candidate][v]$ 等于 0 还是 1，都是有价值的，这使得定位候选汇点是固定地检查 | V| - 1 遍即可。</p>
</blockquote>
<div class="callout question">
 The incidence matrix of a directed graph $G = (V, E)$ with no self-loops is a $|V| \times |E|$ matrix $B = (b_{ij})$ such that
 $$
 b_{ij} = 
 \begin{cases} 
 -1, &amp; \text{ if edge j leaves vertex i}  \\ 
 1, &amp; \text{ if edge j enters vertex i} \\
 0, &amp; \text{ otherwise}  
 \end{cases} 
 $$
   Describe what the entries of the matrix product $B B^T$ represent, where $B^T$ is the
   transpose of B.
</div>

<blockquote>
<p>这题说的是有向无环图的关联矩阵，直接建立顶点与每条边的对应关系，出边就是 - 1，入边就是 1，没有关系就是 0。题目要求描述 $B B^T$ 矩阵的元素都代表什么。</p>
</blockquote>
<ol>
<li>对角线元素 $c_{ii}$​表示顶点 i 的度数，即与该顶点相关联的边的数量，包括入度和出度的边。<blockquote>
<ol start="2">
<li>非对角线元素 $c_{ij}$​（其中 i≠j）表示顶点 i 和 j 之间共享的边的数量，经计算我们可以发现 $B B^T$ 矩阵的元素要么是 0，要么是负数，没有正数。所以如果 $c_{ij}​=0$，则表示顶点 i 和 j 之间没有共享的边，而非零值则表示它们之间存在共享的边，如果是有多重边 (multiple edges) 的话，这个非零值就不只是 - 1 了。这里没直接说多重图 (multigraphs)，是因为多重图是包括了自环和多重边的，但题目说的是有向无环图。</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="Breadth-first-search"><a href="#Breadth-first-search" class="headerlink" title="Breadth-first search"></a>Breadth-first search</h2><blockquote>
<p>// 时间复杂度：O (V + E)<br>$BFS(G, s)$<br>    for each vertex u $\in G.V - {s}$      // 初始化<br>        u.color = WHITE<br>        $u.d = \infty$                              //d 是距离<br>        u.$\pi$ = NIL                            //$\pi$ 是前驱<br>    s.color = $GRAY$<br>    s.d = 0<br>    s.$\pi$ = NIL<br>    $Q = \not 0$                                        // 初始化队列<br>    ENQUEUE(Q, s)<br>    while Q $\not = \not 0$<br>        u = DEQUEUE(Q)<br>        for each vertex v in $G$.Adj[u]<br>            if v.color = WHITE<br>                v.color = $GRAY$<br>                v.d = u.d + 1<br>                v.$\pi$ = u<br>                ENQUEUE (Q, v)      // 可以发现队列里的顶点都是灰色的<br>        u.color = BLACK</p>
</blockquote>
<p>// 图的广搜使用了颜色标记方法，白色表示顶点未被发现，灰色表示该顶点已被发现，但其邻接顶点可能还有未被发现的顶点，黑色则表示其邻接顶点全被发现。<br><img src="https://telegraph-image-eja.pages.dev/file/68170db1c351c1c1154fb.png" alt="bfs"><br>// 该图展示了广搜全过程，广搜的结果可能不一样，这取决于 for each vertex v in $G$.Adj [u] 的遍历顺序。</p>
<h3 id="Shortest-paths"><a href="#Shortest-paths" class="headerlink" title="Shortest paths"></a>Shortest paths</h3><blockquote>
<p>定义 $\delta (s, v)$ 为从 s 到 v 的所有路径中的最少的边数</p>
</blockquote>
<h4 id="Lemma"><a href="#Lemma" class="headerlink" title="Lemma"></a>Lemma</h4><ul>
<li><p>(1) Let $G = (V, E)$ be a directed or undirected graph, and let $s \in V$ be an arbitrary<br>vertex. Then, for any edge $(u, v) \in E$,<br>$$<br>\delta(s, v) \leq \delta(s, u) + 1<br>$$<br><img src="https://telegraph-image-eja.pages.dev/file/40f16ccf9c4b758354fd3.png" alt="image"></p>
<blockquote>
<p>对于该引理有个方便记忆的描述，即三角形两边之和大于第三边，见 A 图，公式中的 1 就是 (u, v) 这条确定的边。</p>
<p>我一开始的想法是，(u, v) 这条边有 A, B, C 三种情况 (不严谨)，A 表示顶点 u, v 是同级的，对应 $\delta (s, v) = \delta (s, u)$ 的情况；B 表示顶点 u 相对于 s 的位置来说在 v 前面，对应 $\delta (s, v) = \delta (s, u) + 1$ 的情况；C 表示顶点 v 相对于 s 的位置来说在 u 前面，对应 $\delta (s, v) &lt; \delta (s, u)$ 的情况，特别地，C 中的蓝色曲线代表了 s 到 u 的其他路径，所以说 A 是 C 的特殊情况，因此也可以分成两种情况，上面都是建立在 u 是从 s 可以到达的情况，不可以到达的情况参照下面的解释。<br>// 上面纯属主观想法描述，可能存在纰漏以及说法不严谨的地方。</p>
<p>CLRS 里面的解释：<br>① 如果 u 是从 s 可以到达的顶点，那么 v 也是可达的，这种情况下从 $s \to v$ 的最短路径不可能比从 $s \to u$ 的最短路径再加上边 (u, v) 更长，因此不等式成立。// 这是原话，看到这句我觉得我上面的想法貌似就是想表达这个意思。反正就是因为 $\delta (s, u)$ 本身就是最短的，然后与顶点 v 再连一条边的话，那么 $\delta (s, v)$ 的路径要么不经过 u，要么经过 u。不经过的话就必定有 $\delta (s, v) \leq \delta (s, u) + 1$，因为如果不等号为 &gt;，那么 $\delta (s, u) + 1$ 这条路径才应该是 $\delta (s, v)$ 真正的路径，因为它更短；经过 u 的话就说明 u 是 $\delta (s, v)$ 路径的一部分，此时在无向图中 $\delta (s, v)$ 不仅有上限 $\delta (s, u) + 1$，还有 $\delta (s, u) - 1$ 这个下限。<br>② 如果 u 是从 s 不可以到达的顶点，那么在上面伪代码算法中可知，$\delta (s, u) = \infty$，等式显然成立。</p>
</blockquote>
</li>
<li><p>(2) Let $G = (V, E)$ be a directed or undirected graph, and suppose that BFS is run<br>on $G$ from a given source vertex $s \in V$ . Then, for each vertex $v \in V$ , the value v.d<br>computed by BFS satisfies $v.d \geq \delta (s, v)$ at all times, including at termination.</p>
</li>
</ul>
<blockquote>
<p>这里是用归纳法进行证明：归纳假设即为 $v.d \geq \delta (s, v)$ 对于所有 $v \in V$ 都成立<br>① 基本情况：在把源点 s 入队后，$s.d = 0 = \delta (s, s)$ 并且对于所有除 s 外的顶点 v 都有 $v.d = \infty \geq \delta (s, v)$，因此等式成立。<br>② 归纳：考虑到一个白色顶点 v 是在对顶点 u 的邻接表搜索中被发现的，因此 $v.d = u.d + 1$（可见伪代码），基于归纳假设，有 $v.d \geq \delta (s, u) + 1$，由引理 (1) 可知 $\delta (s, u) + 1 \geq \delta (s,v)$，因此等式成立。</p>
</blockquote>
<ul>
<li>(3) Suppose that during the execution of BFS on a graph $G = (V, E)$, the queue Q<br>contains the vertices $&lt;v_1, v_2, . . . , v_r&gt;$, where $v_1$ is the head of Q and $v_r$ is the tail.<br>Then, $v_r.d \leq v_1.d + 1$ and $v_i.d \leq v_{i + 1}.d$ for i = 1, 2, . . . , r - 1.</li>
</ul>
<blockquote>
<p>这里也是用归纳法进行证明，但直接理解好像更容易。首先，假设队列里只能有不超过两种距离不同的顶点，如果是只有一种距离，假设为 d，那么队列里肯定都是上一次出队的那个顶点 (距离为 d - 1) 的邻接表 (假设为 u) 里的，假设还没遍历完，那就继续添加，此时队列里顶点距离都是 d。遍历完后就又要把当前队列第一个顶点出队，如果其邻接表为空，那就下一个继续出队操作，此时队列还是一种距离的情况，如果不为空，那就开始遍历其邻接表，只要是对邻接表 u 里面的元素执行出队，之后入队的顶点的距离都会是 d+1，在此过程中距离就有两种情况，这种情况持续到 u 的所有顶点都出队了，那么此时队列里就只有 d+1 的顶点了，就又变回一种距离的情况了，以此类推，因此队列里不可能有超过两种距离，且从过程可知，跨度不超过 1，因此 $v_r.d \leq v_1.d + 1$ 成立，又因为代码中 d 的计算只有加没有减，因此在后面入队的肯定 $\geq$ 在前面入队的，因此，$v_i.d \leq v_{i + 1}.d$ 也成立。</p>
</blockquote>
<h4 id="Corollary"><a href="#Corollary" class="headerlink" title="Corollary"></a>Corollary</h4><ul>
<li>Suppose that vertices $v_i$ and $v_j$ are enqueued during the execution of BFS, and that $v_i$ is enqueued before $v_j$. Then $v_i.d \leq v_j.d$ at the time that $v_j$ is enqueued.</li>
</ul>
<h4 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h4><ul>
<li>Let $G = (V, E)$ be a directed or undirected graph, and suppose that BFS is run<br>on $G$ from a given source vertex $s \in V$ . Then, during its execution, BFS discovers<br>every vertex $v \in V$ that is reachable from the source s, and upon termination,<br>$v.d = \delta (s, v)$ for all $v \in V$ . Moreover, for any vertex $v \not = s$ that is reachable from s, one of the shortest paths from s to v is a shortest path from s to $v.\pi$ followed by the edge $(v.\pi, v)$.</li>
</ul>
<blockquote>
<p>这里定理其实主要表达的就是 $v.d = \delta (s, v)$，这就使得广搜可以用来求最短路径问题。<br>这个定理的证明采用反证法：<br>假设存在顶点的 d 值不等于它最短路径的距离。对于所有的这种顶点，设顶点 v 的最短距离为 $\delta (s, v)$，通过引理 (2) 可知，$v.d \geq \delta (s, v)$，因此在这里的顶点 v 有 $v.d &gt; \delta (s, v)$①，当然不能有 $v \not = s$，因为 s.d = 0 并且 $\delta (s, s) = 0$。而且，顶点 v 必须是从 s 可达的，否则我们将有 $\delta (s, v) = \infty \geq v.d$。设 u 是从 s 到 v 的最短路径上紧邻 v 前面的顶点 (因为 $v \not = s$，所以顶点 u 必须存在)，这样就有 $\delta (s, v) = \delta (s, u) + 1$②了。因此 $\delta (s, u) &lt; \delta (s, v)$，又因为我们设 u 的方式，所以有 $u.d = \delta (s, u)$③。<br>结合①②③，就有了下图的公式，然后对 v 的所有情况进行讨论，推出矛盾，证明 $v.d = \delta (s, v)$ 成立。具体看下图：</p>
</blockquote>
<p><img src="https://telegraph-image-eja.pages.dev/file/a9bfbbf9fc07d7969e851.png" alt="?"></p>
<h3 id="Breadth-first-trees"><a href="#Breadth-first-trees" class="headerlink" title="Breadth-first trees"></a>Breadth-first trees</h3><p>上面广搜全过程图片中的蓝色边正展示了广度优先树在 BFS 过程中被建立，这个树对应着 $\pi$ 属性。<br>形式化的定义即是：对于有源点 s 的图 $G = (V, E)$，定义 $G$ 的前驱子图 (predecessor subgraph) $G_\pi = (V_\pi, E_\pi)$，其中 $V_\pi = {v \in V: v.\pi \not = NIL} \cup {s}$，$E_\pi = {(v.\pi, v): v \in V_\pi - {s}}$。这样的 $G_\pi$ 就是广度优先树，$E_\pi$ 为树边。</p>
<h2 id="Depth-first-search"><a href="#Depth-first-search" class="headerlink" title="Depth-first search"></a>Depth-first search</h2><ul>
<li>与广搜不同，深搜的前驱子图可能包含多个树，因为深搜可能从多个源点进行。<br>它对 $G_\pi$ 的定义是：$G_\pi = (V, E_\pi)$，其中 $E_\pi = {(v.\pi, v): v \in V \wedge v.\pi \not = NIL}$。<br>深度优先搜索的前驱子图形成了包含多个深度优先树的深度优先森林。</li>
<li>深度优先搜索着色方法与广搜一样，该方法在这里保证了每个顶点只在一棵深度优先树中出现，因此这些树都是不相交的。</li>
<li>与广搜不一样的是，深搜过程还提供了时间戳，每个顶点有两个时间戳，第一个时间戳 v.d 记录了 v 什么时候第一次被发现，第二个时间戳 v.f 记录了什么时候完成了对 v 的邻接表的遍历。因为每个顶点都有两个时间戳，因此时间戳范围是 $1 \to 2|V|$ 的整数，并且 $v.d &lt; v.f$。v 在 v.d 之前为白色，在 v.d 到 v.f 之间为灰色，在 v.f 之后为黑色。下面是深搜伪代码：</li>
</ul>
<blockquote>
<p>// 时间复杂度：O (V + E)<br>$DFS(G)$<br>       for each vertex $u \in G.V$                  // 初始化<br>           u.color = WHITE<br>           u.$\pi$ = NIL<br>       time  = 0<br>       for each vertex $u \in G.V$<br>           if u.color == WHITE<br>               DFS-VISIT $(G, u)$<br>DFS-VISIT $(G, u)$<br>       time = time + 1<br>       u.d = time<br>       u.color =$GRAY$<br>       for each vertex v in $G.Adj[u]$<br>           if v.color == WHITE<br>               v.$\pi$ = u<br>               DFS-VISIT $(G, v)$               // 体现了深度优先<br>       time = time + 1<br>       u.f = time<br>       u.color = BLACK</p>
</blockquote>
<p><img src="https://telegraph-image-eja.pages.dev/file/275c9f0fa7b28c8b16770.png" alt="dfs"><br>// 这是深搜全过程图</p>
<h3 id="Properties-of-depth-first-search"><a href="#Properties-of-depth-first-search" class="headerlink" title="Properties of depth-first search"></a>Properties of depth-first search</h3><ul>
<li>(1) 深度优先搜索生成的前驱子图 $G_\pi$ 为一个有若干棵树的森林，因为深度优先树的结构与&nbsp;DFS-VISIT&nbsp;递归调用的结构完全对应，也就是说，$u = v.\pi$ 当且仅当&nbsp;DFS-VISIT (G, v)&nbsp;在搜索&nbsp;u&nbsp;的邻接表时被调用，此外，在深度优先森林中，顶点 v 是顶点 u 的后代当且仅当顶点 v 在顶点 u 为灰色的时间段里被发现。<br><img src="https://telegraph-image-eja.pages.dev/file/b2b7493044770da13ffa1.png" alt="image"></li>
<li>(2) 顶点的发现时间和完成的时间具有括号化结构，与此对应的是括号化定理。</li>
</ul>
<h3 id="Parenthesis-theorem"><a href="#Parenthesis-theorem" class="headerlink" title="Parenthesis theorem"></a>Parenthesis theorem</h3><p>在对有向图或无向图&nbsp;$G=(V, E)$ 的深度优先搜索中，对于任意两个顶点&nbsp;u&nbsp;和&nbsp;v&nbsp;，以下三种情况只有一种成立：</p>
<ul>
<li>若&nbsp;$[u.d, u.f]∩[v.d, v.f] = ∅$&nbsp;，则在深度优先森林中，u 不是 v 的后代，v 也不是 u 的后代。</li>
<li>若 $[u.d, u.f]⊂[v.d, v.f]$，则在深度优先森林中，u 是 v 的后代。</li>
<li>若 $[v.d, v.f]⊂[u.d, u.f]$，则在深度优先森林中，v 是 u 是后代。<br><img src="https://telegraph-image-eja.pages.dev/file/26624ae22bfd773c415fa.png" alt="image"></li>
</ul>
<h3 id="Corollary-Nesting-of-descendants’-intervals"><a href="#Corollary-Nesting-of-descendants’-intervals" class="headerlink" title="Corollary(Nesting of descendants’ intervals)"></a>Corollary(Nesting of descendants’ intervals)</h3><p>在有向图或无向图 $G = (V, E)$ 的深度优先森林中，顶点 v 是顶点 u 的真后代当且仅当 $u.d &lt; v.d &lt; v.f &lt; u.f$。</p>
<h3 id="White-path-theorem"><a href="#White-path-theorem" class="headerlink" title="White-path theorem"></a>White-path theorem</h3><p>在有向图或无向图 $G=(V, E)$ 的深度优先森林中，顶点 v 是顶点 u 的后代当且仅当在搜索发现 u 的时刻 u.d&nbsp;，存在一条从 u 到 v 的全部由白色顶点构成的路径。</p>
<ul>
<li>$\Rightarrow$：如果 v = u，那么从 u 到 v 路径上只有一个顶点 u，当 u.d = time 时刻，u 还是白色；如果 v 是 u 的真后代，根据推论，有 $u.d &lt; v.d$， 因此 v 是白色。由于 v 可以是 u 的任意后代，所以在深度优先森林中从 u 到 v 的唯一简单路径上的所有顶点在时间 u.d 时为白色。</li>
<li>$\Leftarrow$：若在时刻 u.d，存在一条从 u 到 v 的全部由白色顶点构成的路径，先假设在深度优先森林中 v 不是 u 的后代。不失一般性，假设路径上除 v 以外的每个顶点都成为 u 的后代。(否则，假设 v 是在没有成为 u 的后代的路径上离 u 最近的顶点。) 设 w 是 v 在路径上的前驱，那么 w 就是 u 的后代 (w 和 u 实际上可能是同一个顶点)。由推论可知，$w.f  \leq u.f$。又因为 v 必须在 u 被发现之后被发现，但在 w 完成的时间戳之前，则有 $u.d &lt; v.d &lt; w.f \leq u.f$。根据括号化定理可知，$[v.d, v.f]⊂[u.d, u.f]$。由推论可知，v 必须为 u 的后代</li>
</ul>
<h3 id="Classification-of-edges"><a href="#Classification-of-edges" class="headerlink" title="Classification of edges"></a>Classification of edges</h3><ul>
<li>树边 (Tree edges)：$G_\pi$ 上的边，若顶点 v 是通过边 (u, v) 第一次被发现，则 (u,  v) 是一条树边。</li>
<li>后向边 (Back edges)：若边 (u, v) 为连接 u 和它在深度优先树中的一个祖先 v 的边，包括自环 (即 u = v)，则 (u, v) 是一条后向边。</li>
<li>前向边 (Forward edges)：若边 (u, v) 为连接 u 和它的一个真后代 v 的非树边，则 (u, v) 是一条前向边。</li>
<li>横向边 (Cross edges)：其它所有边，它们可以连接同一深度优先树中的顶点，只要其中一个顶点不是另一个顶点的祖先；它们也可以连接不同深度优先树中的顶点。</li>
</ul>
<h2 id="Topological-sort"><a href="#Topological-sort" class="headerlink" title="Topological sort"></a>Topological sort</h2><p>对象是有向无环图 (directed acyclic graphs)，因此拓扑排序可以用来判断一个图有没有环，很多实际应用都需要使用有向无环图来指明时间的先后顺序。<br>拓扑排序是一种针对有向无环图（DAG）的排序算法，它不是基于元素之间的比较，而是基于它们之间的依赖关系。原理上，拓扑排序是对有向无环图进行深度优先搜索（DFS）或广度优先搜索（BFS）的一种应用。它通过这些搜索算法来确定图中节点的线性序列，这个序列满足：对于图中的每一条有向边 (u, v)（从节点 u 指向节点 v），u 在序列中都出现在 v 之前。这样的序列满足了图中节点间的所有依赖关系。</p>
<ul>
<li><strong>依赖关系</strong>：<br>  图中的每个节点代表一个任务或活动，有向边代表一个任务必须在另一个任务之后完成。拓扑排序能够确保对于任何节点，它的所有前驱节点（即所有指向它的节点）都在它之前被访问。<blockquote>
<p>伪代码：<br>TOPOLOGICAL-SORT$(G)$<br>     call $DFS(G)$ to compute finish times v.f for each vertex v<br>     as each vertex is finished, insert it onto the front of a linked list<br>     return the linked list of vertices</p>
</blockquote>
</li>
</ul>
<h2 id="Strongly-connected-components"><a href="#Strongly-connected-components" class="headerlink" title="Strongly connected components"></a>Strongly connected components</h2><ul>
<li>有向图 $G = (V, E)$ 的一个强连通分量是一个最大顶点集 $C \subseteq V$，对于每一对顶点 $u, v \in C$，那么 u, v 相互可达。</li>
<li>$G 和 G^T$ 有完全相同的强连通分量。</li>
<li>分量图 $G^{SCC} = (V^{SCC},E^{SCC})$，为简化后的有向图，把每个强连通分量压缩成一个顶点，以便研究它们之间的关系。<br><img src="https://telegraph-image-eja.pages.dev/file/f02f4a1572ce744d646b2.png" alt="image"></li>
</ul>
<blockquote>
<p>伪代码：<br>$STRONGLY-CONNECTED-COMPONENTS(G)$<br>1	call DFS(G) to compute finish times u.f for each vertex u<br>2	create $G^T$<br>3	call DFS($G^T$) , but in the main loop of DFS, consider the vertices<br>    in order of decreasing u.f (as computed in line 1)<br>4	output the vertices of each tree in the depth-ûrst forest formed in line 3 as a<br>        separate strongly connected component</p>
</blockquote>
]]></content>
      <categories>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimum Spanning Trees</title>
    <url>/2024/04/25/Minimum%20Spanning%20Trees/</url>
    <content><![CDATA[<h1 id="Minimum-Spanning-Trees"><a href="#Minimum-Spanning-Trees" class="headerlink" title="Minimum Spanning Trees"></a>Minimum Spanning Trees</h1><p>对于无向图 $𝐺=(𝑉,𝐸)$，存在一个能够连接所有顶点的无环子集 $𝑇⊆𝐸$，由于&nbsp;𝑇&nbsp;无环且连接所有顶点，因此&nbsp;𝑇&nbsp;一定为一棵树 (树是特殊的图，为无环连通图)，被称为生成树 (spanning tree)。无向图 $𝐺=(𝑉,𝐸)$ 的所有生成树都恰有 $|𝑉|−1$ 条边。</p>
<p>设边 $(𝑢,𝑣)∈𝐸$ 的权重为 $𝑤(𝑢,𝑣)$，生成树权重为 $𝑤(𝑇) = \sum_{(𝑢,𝑣)∈𝑇} 𝑤(𝑢,𝑣)$，所有生成树中权重最小的生成树被称为最小权重生成树 (minimum-weight spanning tree)，简称最小生成树 (minimum spanning tree)。</p>
<h2 id="Growing-a-minimum-spanning-tree"><a href="#Growing-a-minimum-spanning-tree" class="headerlink" title="Growing a minimum spanning tree"></a>Growing a minimum spanning tree</h2><p>最小生成树问题的输入为一个无向连通图&nbsp;$𝐺=(𝑉,𝐸)$, 伪代码如下：</p>
<blockquote>
<p>$GENERIC-MST(G, w)$<br>1    $A = \not 0$<br>2    while A does not form a spanning tree<br>3        find an edge (u, v) that is safe for A<br>4        $A = A \cup {(u, v)}$<br>5    return A</p>
</blockquote>
<p>能够被加入&nbsp;𝐴&nbsp;的边&nbsp;(𝑢,𝑣)&nbsp;被称为&nbsp;𝐴&nbsp;的安全边 (safe edge)。通过&nbsp;𝐴&nbsp;维持了循环不变量可证明过程&nbsp;GENERIC-MST&nbsp;的正确性。在讨论如何识别安全边之前，我们需要了解一些定义。<br><img src="https://telegraph-image-eja.pages.dev/file/d85f5a52655f0d41a977d.png" alt="image"></p>
<ul>
<li>$cut$：无向图 $𝐺=(𝑉,𝐸)$ 的一个切割 (cut)&nbsp;$(𝑆,𝑉−𝑆)$ 是对顶点𝑉的一个划分，分成两个区域</li>
<li> $cross$：若边 $(𝑢,𝑣)∈𝐸$ 的一个端点属于&nbsp;𝑆&nbsp;，另一个端点属于𝑉−𝑆&nbsp;，则称边 (𝑢,𝑣)&nbsp;横跨 (cross) cut (𝑆,𝑉−𝑆)，看图的话就是跟红色分割线相交的边都是 cross 的边</li>
<li> $respect$：若集合&nbsp;𝐴&nbsp;中不存在横跨切割&nbsp;(𝑆,𝑉−𝑆)&nbsp;的边，则称该切割不影响 (respect)&nbsp;𝐴</li>
<li>$light\ edge$：权重最小的 cross 边即是轻量边 (light edge)<br>原文如下：<br><img src="https://telegraph-image-eja.pages.dev/file/1833dbc2edcac6e9a8fb9.png" alt="image"><br>当然最好还得知道树的性质：添加一条边就会构成环，删除一条边就会分裂成两棵树。</li>
</ul>
<h3 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h3><blockquote>
<p>设&nbsp;𝐺=(𝑉, 𝐸)&nbsp;为一个无向连通图，其权重函数为&nbsp;𝑤: $𝐸\to𝑅$&nbsp;，设&nbsp;𝐴⊆𝐸&nbsp;，且&nbsp;𝐴&nbsp;包含于&nbsp;𝐺&nbsp;的一棵最小生成树中。设&nbsp;(𝑆, 𝑉−𝑆)&nbsp;为&nbsp;𝐺&nbsp;中不影响&nbsp;𝐴&nbsp;的任意一个切割，若&nbsp;(𝑢, 𝑣)&nbsp;为横跨&nbsp;(𝑆, 𝑉−𝑆)&nbsp;的一条轻量边，则对于&nbsp;𝐴&nbsp;，(𝑢, 𝑣)&nbsp;是安全的。</p>
</blockquote>
<p><img src="https://telegraph-image-eja.pages.dev/file/bd123ede0b571e7df22aa.png" alt="image"></p>
<p>// 图中橙色顶点属于 S，其它顶点属于 V-S，蓝色边就是 A 中的边</p>
<p>证明如下：</p>
<ul>
<li>首先假设 T 是包含 A 的最小生成树，并假设 T 不包含轻量边 (u, v)，因为如果包含了，我们就不用证了。接着我们可以通过构造另一棵最小生成树 T’，其中 $A \cup {(u, v)} ⊆ T’$, 从而表明，边&nbsp;(𝑢, 𝑣)&nbsp;对于&nbsp;𝐴&nbsp;是安全的。</li>
<li>由图可知边 (u, v) 与 $u \to v$ 的简单路径构成环路。因为 u, v 在 cut (𝑆, 𝑉−𝑆) 下分属两边，因此&nbsp;𝑇&nbsp;中至少有一条边属于简单路径&nbsp;𝑝&nbsp;并且横跨该切割，设&nbsp;(𝑥, 𝑦)&nbsp;为这样一条边。因为切割&nbsp;(𝑆, 𝑉−𝑆)&nbsp;不影响𝐴&nbsp;，所以&nbsp;(𝑥, 𝑦) ∉ 𝐴。又因为边&nbsp;(𝑥, 𝑦)&nbsp;位于&nbsp;𝑇&nbsp;中从&nbsp;𝑢&nbsp;到&nbsp;𝑣&nbsp;的唯一的简单路径上，所以移除&nbsp;(𝑥, 𝑦)&nbsp;会导致&nbsp;𝑇&nbsp;分裂成两部分。此时添加&nbsp;(𝑢, 𝑣)&nbsp;将这两部分重新连接成一棵新的生成树 ：𝑇′=(𝑇−{(𝑥,𝑦)})∪{(𝑢,𝑣)}&nbsp;。</li>
<li>我们接下来要证明 T’是最小生成树。由于&nbsp;(𝑢, 𝑣)&nbsp;为横跨&nbsp;(𝑆, 𝑉−𝑆)&nbsp;的一条轻量边且&nbsp;(𝑥, 𝑦)&nbsp;为横跨&nbsp;(𝑆, 𝑉−𝑆)&nbsp;的一条边，即&nbsp;𝑤(𝑢, 𝑣)≤𝑤(𝑥, 𝑦)&nbsp;，因此：<br>$w(T’) = w(T) - w(x, y) + w(u, v)$<br> $\leq w(T)$<br>但是&nbsp;𝑇&nbsp;为一棵最小生成树，有&nbsp;𝑤(𝑇)≤𝑤(𝑇′)&nbsp;。因此，有&nbsp;𝑤(𝑇) = 𝑤(𝑇′)&nbsp;，所以&nbsp;𝑇′&nbsp;也是一棵最小生成树。</li>
<li>最后，我们还需要说明边&nbsp;(𝑢, 𝑣)&nbsp;对于&nbsp;𝐴&nbsp;是安全的。因为&nbsp;𝐴⊆𝑇&nbsp;且&nbsp;(𝑥, 𝑦)∉𝐴&nbsp;，所以&nbsp;𝐴⊆𝑇′&nbsp;，所以&nbsp;(𝐴∪{(𝑢,𝑣)})⊆𝑇′&nbsp;。由于&nbsp;𝑇′&nbsp;是一棵最小生成树，因此对于&nbsp;𝐴&nbsp;，(𝑢, 𝑣)&nbsp;是安全的。</li>
</ul>
<p>感觉有点难咀嚼的话可以看看下面的另一种证明 (算法 4)：<br><img src="https://telegraph-image-eja.pages.dev/file/ef60c9e50f8c87db41f0d.png" alt="image"></p>
<blockquote>
<p>在算法执行的任何时候，图 $G_A = (V, A)$ 是一个森林，$G_A$ 中每一个连通分量都是一棵树 (一些树可能只包含一个顶点，例如在算法开始时，A 是空的，因为还没开始加入安全边，并且此时森林包含了 | V | 棵树，每棵树都只有一个顶点)。此外，因为 $A \cup {(u, v)}$ 必须是无环的，因此每一条安全边 (u, v) 都连接着 $G_A$ 中的不同分量。</p>
</blockquote>
<h3 id="Corollary"><a href="#Corollary" class="headerlink" title="Corollary"></a>Corollary</h3><p>设&nbsp;𝐺=(𝑉, 𝐸)&nbsp;为一个无向连通图，其权重函数为 $𝑤:𝐸\to𝑅$，设&nbsp;𝐴⊆𝐸&nbsp;，且&nbsp;𝐴&nbsp;包含于&nbsp;𝐺&nbsp;的一棵最小生成树中。设 $𝐶=(𝑉_𝐶, 𝐸_𝐶)$ 为森林 $𝐺_𝐴=(𝑉,𝐴)$ 中的一个连通分量（一棵树）。若&nbsp;(𝑢,𝑣)&nbsp;是连接&nbsp;𝐶&nbsp;和 $𝐺_𝐴$ 中某一个其它的连通分量的一条轻量边，则对于&nbsp;𝐴&nbsp;，(𝑢, 𝑣)&nbsp;是安全边。</p>
<blockquote>
<p>Proof：<br>切割 $(V_C,V-V_C)$ 不影响 A，又因为 (u, v) 是该切割的轻量边，因此，对于 A，(u, v) 是安全的。</p>
</blockquote>
<h2 id="The-algorithms-of-Kruskal-and-Prim"><a href="#The-algorithms-of-Kruskal-and-Prim" class="headerlink" title="The algorithms of Kruskal and Prim"></a>The algorithms of Kruskal and Prim</h2><p>这里描述的两种最小生成树算法详细介绍了上面的通用方法。它们各自使用一个特殊的规则来确定 $GENERIC-MST (G, w)$ 的第 3 行中的 find an edge (u, v) that is safe for A。在 Kruskal 算法中，集合 A 是一个森林，其顶点都是给定图的顶点。添加到 A 中的安全边总是图中连接两个不同分量的最低权重边。在 Prim 算法中，集合 A 形成了一棵树，算法执行过程中始终为一棵树。添加到 A 中的安全边始终是连接树和树中以外的顶点的最低权重边。下面的介绍中，两种算法都假设输入图是连通的，并由邻接列表表示。</p>
<h3 id="Kruskal’s-algorithm"><a href="#Kruskal’s-algorithm" class="headerlink" title="Kruskal’s algorithm"></a>Kruskal’s algorithm</h3><p><img src="https://telegraph-image-eja.pages.dev/file/a9d9c05f942462df59992.png" alt="image"><br><img src="https://telegraph-image-eja.pages.dev/file/f2dcf3043bd0577717a43.png" alt="image"></p>
<blockquote>
<p>大家可以先通过上图感受一下该算法，蓝色边属于森林 A，透过上图我们还可以观察到被添加到 A 中的安全边的权重是从小到大的，所以容易发现 Kruskal 算法是贪心算法，每次都加入权重最小的安全边，以此来保证总权重最小。该算法以按权重排序的顺序来考虑每条边，因此正在考虑的那条边已经是当前未加入生成树的边中的轻量边，只需再判断是否产生环而决定是否将它加入 A，红色的箭头则指向在算法的每一步中所考虑的边。如果边 (u, v) 连接森林中两棵不同的树 (注意单一的顶点也是树），则将其添加到森林中，从而合并两棵树。</p>
</blockquote>
<ul>
<li>设 $C_1$ 和 $C_2$ 表示由 (u, v) 连接的两棵树。因为 (u, v) 必须是连接 $C_1$ 和其他树的轻量边，根据推论 (Corollary)，&nbsp;(𝑢, 𝑣)&nbsp;是 $𝐶_1$ 的一条安全边。<br>伪代码如下：<blockquote>
<p>// 时间复杂度：𝑂(𝐸 lg⁡ 𝑉)<br>$MST-KRUSKAL(G, w)$<br>1     A = $\not 0$       // 初始化空集合<br>2     for each vertex $v \in G.V$<br>3          MAKE-SET (v)    // 使用并查集 (disjoint-set) 的数据结构来维护几个不相交的元素集，               每个集合都包含当前林的一棵树中的顶点，初始化即一个顶点一棵树<br>4     create a single list of the edges in G.E<br>5     sort the list of edges into monotonically increasing order by weight w<br>6     for each edge (u, v) taken from the sorted list in order<br>7            if FIND-SET (u) $\not =$ FIND-SET (v)    // 确定两个顶点是否属于同一棵树，同一棵树就会                                                                  成环<br>8                 $A = A \cup {(u, v)}$      // 把边 (u, v) 加入到 A<br>9                 UNION (u, v)       // 合并树<br>10     return A</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>上面说到了并查集数据结构，下面简要说一下，已掌握可跳过。</p>
</blockquote>
<h4 id="Disjoint-set"><a href="#Disjoint-set" class="headerlink" title="Disjoint-set"></a>Disjoint-set</h4><p>首先并查集用数组来实现，数组的值代表其父节点的位置，在上面代码中的初始化中，一个顶点就是一棵树，因此没有父节点，可以把所有顶点的数组值标为 - 1。<br>并查集支持两个操作：</p>
<ul>
<li>查找 (Find)：确定某个元素属于哪个子集，它可以用来确定两个元素是否属于同一个子集。</li>
<li>合并 (Union)：将两个子集合并成一个集合<br>上面代码中的 FIND-SET 即是查找操作，对某个顶点 i 查找，即循环查找当前位置 i 的父节点，直到 arr [i] = -1 为止，返回 i，如果两个顶点的 FIND-SET 返回结果一样，即两个顶点属于同一棵树。<br>合并操作即是先分别找到 u，v 的根节点，然后将其中一个根节点的父节点设为另一个顶点。这是最基础的并查集实现，要提高效率的话就要进行路径压缩和按秩合并。</li>
<li>路径压缩：在 Find 过程中在返回之前，路径中的顶点的父节点直接设为根节点，毕竟 Find 返回的就是根节点，这有利于下一次查询的效率。</li>
<li>按秩合并：上面所说的合并操作是将其中一个根节点的父节点设为另一个顶点，这未免有点随便。比如现在有一棵简单的树，一棵复杂的树，那么是将简单的往复杂的合并好还是复杂的往简单的合并好？答案是前者，如果把复杂的往简单的合并，那么原来在复杂树中的每个元素到根节点的距离都变长了，影响后面 Find 的效率；而如果把简单的往复杂的合并，到根节点距离变长的节点个数比较少。所以就引入秩，初始时每个顶点的秩设为 1，那么什么时候秩会增加呢？这发生在合并时，如果两棵树深度相同，则新的根节点的秩 + 1。秩越高，树 (或子树) 就越复杂。</li>
</ul>
<h3 id="Prim’s-algorithm"><a href="#Prim’s-algorithm" class="headerlink" title="Prim’s algorithm"></a>Prim’s algorithm</h3><p>跟上面一样，我们可以先通过过程图感受一下：<br><img src="https://telegraph-image-eja.pages.dev/file/0149f1a64ebab26f61bdd.png" alt="image"><br>// 从上图可以明显感受到与 Kruskal 算法不一样的是，蓝色边之间都是连通的，这里就揭露了 Prim 算法具有的一个性质是&nbsp;𝐴&nbsp;中的边总是构成一棵树，我们还可以发现添加边的权重是没有像 Kruskal 算法一样按权重排序的。</p>
<p>如图所示，这棵树以任意一个顶点&nbsp;𝑟&nbsp;为根节点，不断生长直到包含&nbsp;𝑉&nbsp;中所有顶点。每次加入到&nbsp;𝐴&nbsp;中的安全边永远是 (𝐴, 𝑉−𝐴) 切割的轻量边。根据 Corollary，每次加入&nbsp;𝐴&nbsp;的边一定是安全边。该算法也满足贪心性质，因为在每一步它向树添加的一条边，都为树的权重贡献可能的最小量。</p>
<p>伪代码如下：</p>
<blockquote>
<p>$MST-PRIM(G, w, r)$<br>1     for each vertex $u \in G.V$<br>2          $u.key = \infty$             //&nbsp;u.𝑘𝑒𝑦保存连接 u 和树中任一其它节点的所有边中最小的边的权                                               重，若不存在这样的边，即设为 $\infty$，初始化时都设为 $\infty$。<br>3          $u.\pi = NIL$            //u.𝜋&nbsp;保存 u 在树中的父节点<br>4     $r.key = 0$                   // 把根节点 r 的 key 设为 0，方便第 9 行第一个处理 r<br>5     $Q = \not 0$                        // 创建基于&nbsp;𝑘𝑒𝑦&nbsp;属性的优先队列<br>6     for each vertex $u \in G.V$<br>7           INSERT (Q, u)<br>8     while $Q \not = \not 0$               // 只要队列非空<br>9          u = EXTRACT-MIN (Q)        // 把 u 加到树 (A) 中<br>10        for each vertex v in $G.Adj [u]$        // 更新 u 的非树邻居的 key<br>11              if $v \in Q$ and w(u, v) &lt; v.key<br>12                    $v.\pi = u$<br>13                    v.key = w(u, v)<br>14                    DECREASE-KEY (Q, v, w (u, v))        // 调整 Q 中 v 的 key 值</p>
</blockquote>
<p>该算法保持以下三个循环不变量：</p>
<ul>
<li>$𝐴={(𝑣, 𝑣.𝜋): 𝑣∈𝑉−{𝑟}−𝑄}$，(算法终止时，&nbsp;𝑄=∅，因此 G 的最小生成树 $𝐴={(𝑣, 𝑣.𝜋): 𝑣∈𝑉−{𝑟}}$。)</li>
<li> 已经放在最小生成树中的顶点都是 V - Q 中的顶点。</li>
<li>对于图中所有的顶点 v∈Q，如果 $v.\pi$ 不等于 NIL，那么 v.key 小于正无穷大，v.key 是连接 v 到已经放置在最小生成树中的某个顶点的轻量边 $(v,v.\pi)$ 的权重。</li>
</ul>
<p>Prim 算法的运行时间取决于最小优先级队列 Q 的实现：</p>
<ul>
<li>二叉堆：时间复杂度：$𝑂(𝐸lg⁡𝑉)$</li>
<li> 斐波那契堆：时间复杂度：$O (E+V lg V)$</li>
</ul>
]]></content>
      <categories>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
</search>
