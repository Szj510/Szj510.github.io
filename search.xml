<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cpp 智能指针</title>
    <url>/2024/09/28/Cpp-Smart-Pointer/</url>
    <content><![CDATA[<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">[OuterVar](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> {</span><br><span class="line">	<span class="keyword">return</span> OuterVar + x + y;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> {</span><br><span class="line">	<span class="keyword">return</span>  + B;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//返回类型 -&gt; int 可以省略，编译器会自行推断其类型</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="变量捕获-Capture-clause"><a href="#变量捕获-Capture-clause" class="headerlink" title="变量捕获(Capture clause)"></a>变量捕获 (Capture clause)</h3><p>特殊：<code>[&amp;] [=] [&amp;, =N]</code><br>可以在捕获语句中定义新的变量并初始化：<code>[n, &amp;m, k = 4]</code><br>还支持 <code>[](auto a, auto b) { return a + b }</code></p>
<h2 id="共享指针-shared-ptr"><a href="#共享指针-shared-ptr" class="headerlink" title="共享指针(shared_ptr)"></a>共享指针 (shared_ptr)</h2><p>首先 <code>include &lt;memory&gt;</code></p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p {<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>)};</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p {<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>)};<span class="comment">//效率更高更安全</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="自动管理内存"><a href="#自动管理内存" class="headerlink" title="自动管理内存"></a>自动管理内存</h3><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>指向某个 item 的共享指针个数，当这个 item 的引用计数为 0 时，程序就会自动释放这个 item。<br>考虑一下这种情况：当你函数参数必须要传一个裸指针时，你使用 <code>T* rp = p.get()</code> 来获取，其中 p 是共享指针。<br>如果有一块资源，同时有裸指针和共享指针指向它，当所有共享指针被摧毁，但是裸指针仍然存在时，这块资源仍然会被释放，这个时候再用裸指针去访问那块资源就会发生未定义行为，因此，用共享指针的时候最好避免跟裸指针混用。</p>
<h4 id="杂识"><a href="#杂识" class="headerlink" title="杂识"></a>杂识</h4><ul>
<li>我们常见的 <code>p.reset()</code> 是无参时释放，<code>reset</code> 其实还可以接受参数 <code>eg:p.reset(new T)</code>，那么旧的 item T 的引用计数减 1，p 则指向新的 T。</li>
<li>默认情况下共享指针使用 <code>delete</code> 释放资源，但是你也可以自定义删除函数，例如：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_file</span><span class="params">(FILE* fp)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">	cout &lt;&lt; <span class="string">"File closed."</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mian</span><span class="params">()</span> </span>{</span><br><span class="line">	FILE* fp = <span class="built_in">fopen</span>(<span class="string">"data.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">	shared_ptr&lt;FILE&gt; sfp {fp, close_file};</span><br><span class="line">	<span class="keyword">if</span> (sfp == <span class="literal">nullptr</span>)</span><br><span class="line">		cerr &lt;&lt; <span class="string">"Error opening file."</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">"File opened."</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>别名 (Aliasing)：<br>下面代码 <code>b</code> 的命名就是别名，注意到 <code>f</code> 指向的 item 的引用计数加了 1，那么意味着只要 <code>b</code> 还在，<code>f</code> 指向的资源就不会被删除。但是这里 <code>b</code> 的数据指针指向的是 <code>bar</code>(代码最后一行也能看出)，仅是 <code>f</code> 的一个成员，通常这个技巧用于访问类的成员变量，我们希望在访问实例的成员时，不希望实例本身被删除。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span> { <span class="type">int</span> i = <span class="number">123</span>; };</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> { Bar bar; };</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	shared_ptr&lt;Foo&gt; f = <span class="built_in">make_shared</span>&lt;Foo&gt;();</span><br><span class="line">	cout &lt;&lt; f.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// prints 1</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Bar&gt; <span class="title">b</span><span class="params">(f, &amp;(f-&gt;bar))</span></span>;</span><br><span class="line">	cout &lt;&lt; f.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// prints 2</span></span><br><span class="line">	cout &lt;&lt; b-&gt;i &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>Undefined Behavior<ul>
<li> 手动 delete</li>
</ul>
</li>
<li> 额外性能开销</li>
</ul>
<h2 id="独享指针-unique-ptr"><a href="#独享指针-unique-ptr" class="headerlink" title="独享指针(unique_ptr)"></a>独享指针 (unique_ptr)</h2><blockquote>
<p>零开销，不能有两个独享指针同时指向同一块资源，当独享指针被销毁，其绑定的资源就会自动释放。</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>{</span><br><span class="line">	Object* p = <span class="keyword">new</span> Object;</span><br><span class="line">	p-&gt;<span class="built_in">foo</span>();</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>{</span><br><span class="line">	unique_ptr&lt;Object&gt; up { <span class="built_in">make_unique</span>&lt;Object&gt;() };</span><br><span class="line">	up-&gt;<span class="built_in">foo</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>考虑 <code>func1</code>，可能会发生内存泄漏，比如如果 <code>p-&gt;foo()</code> 抛出异常，<code>delete p</code> 就不会被执行，从而造成内存泄漏。而 <code>func2</code> 就不用担心这个问题，即便抛出异常，资源最后也会释放。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">up.<span class="built_in">reset</span>(); <span class="comment">//释放up下的资源，把up设置为nullptr</span></span><br><span class="line">up.<span class="built_in">reset</span>(<span class="keyword">new</span> Object{}); <span class="comment">//释放的同时指向另外一份资源</span></span><br><span class="line"></span><br><span class="line">Object* object = up.<span class="built_in">release</span>(); <span class="comment">//把up和资源解绑，返回资源的裸指针，同时把up设置为nullptr</span></span><br><span class="line">up = <span class="literal">nullptr</span>; <span class="comment">//也会释放up下的资源</span></span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up2</span><span class="params">(up1)</span></span>; <span class="comment">//error</span></span><br><span class="line">up2 = up1; <span class="comment">//error</span></span><br><span class="line"><span class="comment">//这两行会报错是因为unique_ptr独占一段内存的控制权</span></span><br><span class="line"><span class="comment">//我们不能复制控制权，但是可以转移控制权，如下：</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; up1 = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up2</span><span class="params">(up1.release())</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; up2 = <span class="built_in">move</span>(up1); <span class="comment">//与上句相同的转移效果</span></span><br></pre></td></tr></tbody></table></figure>

<p>独享指针也可以自定义删除函数，但是比共享指针复杂：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">my_alloc</span><span class="params">(<span class="type">int</span> v)</span> </span>{}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_dealloc</span><span class="params">(<span class="type">int</span> *p)</span> </span>{}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	unique_ptr&lt;<span class="type">int</span>, <span class="keyword">decltype</span>(&amp;my_dealloc)&gt; cup {<span class="built_in">my_alloc</span>(<span class="number">100</span>), my_dealloc};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>复杂性是由于独享指针绑定释放函数在编译期，避免了运行时绑定的时间损耗，这与其零开销特性有关；而共享指针在运行时绑定，由于共享指针在引用计数上的性能开销，那么再增加一点也就无所谓了。</p>
<p>由于 <code>unique_ptr</code> 禁止复制操作，因此在函数间传递的时候需要注意方法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_up</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; up)</span> </span>{}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_up1</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>{}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_up2</span><span class="params">(<span class="type">int</span>* p)</span> </span>{}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_up3</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt;&amp; up)</span> </span>{}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_up4</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; up)</span> </span>{}</span><br><span class="line"><span class="comment">//返回up</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">return_uptr</span><span class="params">(<span class="type">int</span> value)</span> </span>{</span><br><span class="line">	unique_ptr&lt;<span class="type">int</span>&gt; up = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(value);</span><br><span class="line">	<span class="keyword">return</span> up;</span><br><span class="line">	<span class="comment">//return move(up);</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mian</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">auto</span> up = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">123</span>);</span><br><span class="line">	<span class="built_in">pass_up</span>(up); <span class="comment">//编译错误</span></span><br><span class="line">	<span class="built_in">pass_up1</span>(*up);</span><br><span class="line">	<span class="built_in">pass_up2</span>(up.<span class="built_in">get</span>());</span><br><span class="line">	<span class="comment">//改变up本身</span></span><br><span class="line">	<span class="built_in">pass_up3</span>(up);</span><br><span class="line">	<span class="built_in">pass_up4</span>(<span class="built_in">move</span>(up));</span><br><span class="line">	unique_ptr&lt;<span class="type">int</span>&gt; up = <span class="built_in">return_uptr</span>(<span class="number">321</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="弱指针-weak-ptr"><a href="#弱指针-weak-ptr" class="headerlink" title="弱指针(weak_ptr)"></a>弱指针 (weak_ptr)</h2><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>weak_ptr 是一种伴随着 shared_ptr 而生的智能指针，它可以建模对象的临时管理权，可以用来解决环形依赖的问题。<br>在不想额外控制资源，但又想检查资源是否存在的时候，可以用弱指针。</p>
<ul>
<li><code>std::weak_ptr</code> 不增加引用计数，不会参与对象生命周期的管理。</li>
<li>它只是一种弱引用，不影响 <code>shared_ptr</code> 的引用计数。</li>
<li>只有当我们需要访问对象时，可以通过 <code>weak_ptr.lock()</code> 临时获取一个 <code>shared_ptr</code>，以确保对象没有被销毁。</li>
</ul>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><h4 id="环形依赖"><a href="#环形依赖" class="headerlink" title="环形依赖"></a>环形依赖</h4><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; bPtr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; aPtr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;bPtr = b;</span><br><span class="line">    b-&gt;aPtr = a;</span><br><span class="line">    <span class="comment">// 到此，a 和 b 都超出了作用域，但它们无法被释放，因为存在环形引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，两个对象间形成了一个<strong>循环引用</strong>：</p>
<ol>
<li><code>a</code> 持有 <code>b</code> 的 <code>shared_ptr</code>，<code>b</code> 的引用计数增加到 2。</li>
<li><code>b</code> 持有 <code>a</code> 的 <code>shared_ptr</code>，<code>a</code> 的引用计数也增加到 2。<br>当 <code>main</code> 函数结束时，<code>a</code> 和 <code>b</code> 超出了作用域，<code>shared_ptr</code> 应该开始析构。然而：</li>
</ol>
<ul>
<li>当 <code>a</code> 超出作用域时，<code>a</code> 的 <code>shared_ptr</code> 会被销毁，<code>a</code> 的引用计数减 1，变为 1（因为 <code>b</code> 还持有 <code>a</code> 的 <code>shared_ptr</code>）。</li>
<li>同样地，当 <code>b</code> 超出作用域时，<code>b</code> 的引用计数减 1，变为 1（因为 <code>a</code> 还持有 <code>b</code> 的 <code>shared_ptr</code>）。<br>结果是：</li>
<li><code>a</code> 和 <code>b</code> 都无法被销毁，因为它们的引用计数都不是 0。</li>
<li><strong>循环引用</strong>导致它们的引用计数永远不会归零，内存无法释放，形成了<strong>内存泄漏</strong>。</li>
</ul>
<h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::weak_ptr&lt;A&gt; aPtr; <span class="comment">// B 持有 A 的 weak_ptr</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>解决方案</strong>：通过使用 <code>std::weak_ptr</code> 打破其中一个引用链，不再增加引用计数，从而避免循环引用的发生，确保对象能够被正常释放。<br><strong>分析</strong>：</p>
<ol>
<li>**<code>a</code> 持有 <code>b</code> 的 <code>shared_ptr</code>**：当 <code>a</code> 对象持有 <code>b</code> 的 <code>shared_ptr</code> 时，<code>b</code> 的引用计数从 1 增加到 2，因为 <code>a-&gt;bPtr</code> 是一个 <code>shared_ptr</code>。</li>
<li><strong><code>b</code> 持有 <code>a</code> 的 <code>weak_ptr</code><strong>：<code>b</code> 持有的 <code>a-&gt;aPtr</code> 是一个 <code>weak_ptr</code>，</strong>不会增加 <code>a</code> 的引用计数</strong>，因此 <code>a</code> 的引用计数保持为 1。<br><strong>结束时的析构行为</strong>：</li>
</ol>
<ul>
<li><strong>当 <code>a</code> 超出作用域时</strong>：<ul>
<li><code>a</code> 的 <code>shared_ptr</code> 被销毁，<code>a</code> 的引用计数减少 1，变为 0，因为此时没有其他 <code>shared_ptr</code> 指向 <code>a</code>。</li>
<li>由于 <code>a</code> 的引用计数归零，<code>a</code> 对象被销毁，<code>a</code> 持有的 <code>bPtr</code> 也被销毁，<code>b</code> 的引用计数减 1，变为 1。</li>
</ul>
</li>
<li><strong>当 <code>b</code> 超出作用域时</strong>：<ul>
<li><code>b</code> 的 <code>shared_ptr</code> 被销毁，<code>b</code> 的引用计数减 1，变为 0，因为此时没有其他 <code>shared_ptr</code> 指向 <code>b</code>。</li>
<li>由于 <code>b</code> 的引用计数归零，<code>b</code> 对象也被销毁。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>智能指针</tag>
        <tag>lambda</tag>
        <tag>编程</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Elementary Graph Algorithms</title>
    <url>/2024/04/21/Elementary-Graph-Algorithms/</url>
    <content><![CDATA[<h1 id="Elementary-Graph-Algorithms"><a href="#Elementary-Graph-Algorithms" class="headerlink" title="Elementary Graph Algorithms"></a>Elementary Graph Algorithms</h1><h2 id="Representations-of-graphs"><a href="#Representations-of-graphs" class="headerlink" title="Representations of graphs"></a>Representations of graphs</h2><p>$$<br>G = (V, E)<br>$$</p>
<p>$G \to Graph, V \to Vertex, E \to Edge$, 式子说明图是由顶点和边这两个元素组成，那么只要把顶点和边表示出来，图就表示出来了。其中有两种方法，一种是邻接表表示，一种是用矩阵表示，根据不同的情景需要会选取不同的表示方法。</p>
<h3 id="adjacency-list"><a href="#adjacency-list" class="headerlink" title="adjacency-list"></a>adjacency-list</h3><p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_list.png" alt="list"><br>// 邻接表可用链表，也可用哈希表</p>
<blockquote>
<p>If $G$ is a directed graph, the sum of the lengths of all the adjacency lists is |E|.<br>If $G$ is an undirected graph, the sum of the lengths of all the adjacency lists is 2|E|.</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//下面是无向图的示例，有向图需要修改部分method代码</span></span><br><span class="line"><span class="comment">//为了方便添加与删除顶点，以及简化代码，这里使用列表（动态数组）来代替链表。</span></span><br><span class="line"><span class="comment">//使用哈希表来存储邻接表，key为顶点实例，value为该顶点的邻接顶点列表（链表）。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="type">int</span> value) : <span class="built_in">val</span>(value) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjList</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::unordered_map&lt;Vertex *, std::vector&lt;Vertex *&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(std::vector&lt;Vertex *&gt; &amp;vec, Vertex *vet)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (vec[i] == vet) {</span><br><span class="line">                vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GraphAdjList</span>(<span class="type">const</span> std::vector&lt;std::vector&lt;Vertex *&gt;&gt; &amp;edges) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> std::vector&lt;Vertex *&gt; &amp;edge : edges) {</span><br><span class="line">            <span class="built_in">addVertex</span>(edge[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">addVertex</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">addEdge</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> adjList.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(Vertex *vet1, Vertex *vet2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1 == vet2)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">"不存在顶点"</span>);</span><br><span class="line">        adjList[vet1].<span class="built_in">push_back</span>(vet2);</span><br><span class="line">        adjList[vet2].<span class="built_in">push_back</span>(vet1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(Vertex *vet1, Vertex *vet2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1 == vet2)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">"不存在顶点"</span>);</span><br><span class="line">        <span class="built_in">remove</span>(adjList[vet1], vet2);</span><br><span class="line">        <span class="built_in">remove</span>(adjList[vet2], vet1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(Vertex *vet)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        adjList[vet] = std::<span class="built_in">vector</span>&lt;Vertex *&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(Vertex *vet)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">"不存在顶点"</span>);</span><br><span class="line">        adjList.<span class="built_in">erase</span>(vet);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;adj : adjList) {</span><br><span class="line">            <span class="built_in">remove</span>(adj.second, vet);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"邻接表 ="</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;adj : adjList) {</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> &amp;key = adj.first;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> &amp;vec = adj.second;</span><br><span class="line">            std::cout &lt;&lt; key-&gt;val &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="built_in">printVector</span>(<span class="built_in">vetsToVals</span>(vec));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vetsToVals</span><span class="params">(<span class="type">const</span> std::vector&lt;Vertex *&gt; &amp;vec)</span> </span>{</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> Vertex *vet : vec) {</span><br><span class="line">            vals.<span class="built_in">push_back</span>(vet-&gt;val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vals;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vec) {</span><br><span class="line">            std::cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h4><blockquote>
<p>加权图即边是有权值的，可添加 Edge 类来实现</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Vertex *destination;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	<span class="built_in">Edge</span>(Vertex *dest, <span class="type">int</span> w) : <span class="built_in">destination</span>(dest), <span class="built_in">weight</span>(w) {}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> val; <span class="comment">// 顶点的值</span></span><br><span class="line">	std::vector&lt;Edge*&gt; adjList; <span class="comment">// 邻接列表</span></span><br><span class="line">	<span class="built_in">Vertex</span>(<span class="type">int</span> v) : <span class="built_in">val</span>(v) {}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>The adjacency-list representation is quite robust in that you can modify it to support many other graph variants.<br>// 上方的代码顶点都是唯一的实例，还可以往其添加属性，这就体现了邻接表的灵活性，加上它的动态性以及内存效率等的优势，共同构建了其健壮性，使其能够支持很多其它的图变体。</p>
</blockquote>
<blockquote>
<p>邻接表查询边的存在性较慢，邻接矩阵表示较快</p>
</blockquote>
<h3 id="adjacency-matrix"><a href="#adjacency-matrix" class="headerlink" title="adjacency-matrix"></a>adjacency-matrix</h3><p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_matrix.png" alt="matrix"></p>
<blockquote>
<p>in an undirected graph, the adjacency matrix A of an undirected graph is its own transpose: $A = A^T$<br>// 正是因为有这一性质，在一些应用中，只选择存储对角线以上的元素来提高内存效率。</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjMat</span> {</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vertices;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; adjMat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphAdjMat</span>(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vertices, <span class="type">const</span> std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vertices) {</span><br><span class="line">            <span class="built_in">addVertex</span>(val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;edge : edges) {</span><br><span class="line">            <span class="built_in">addEdge</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> vertices.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">size</span>();</span><br><span class="line">        vertices.<span class="built_in">push_back</span>(val);</span><br><span class="line">        adjMat.<span class="built_in">emplace_back</span>(std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt; &amp;row : adjMat) {</span><br><span class="line">            row.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"顶点不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">        vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + index);</span><br><span class="line">        adjMat.<span class="built_in">erase</span>(adjMat.<span class="built_in">begin</span>() + index);</span><br><span class="line">        <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt; &amp;row : adjMat) {</span><br><span class="line">            row.<span class="built_in">erase</span>(row.<span class="built_in">begin</span>() + index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= <span class="built_in">size</span>() || j &gt;= <span class="built_in">size</span>() || i == j) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"顶点不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">        adjMat[i][j] = <span class="number">1</span>;</span><br><span class="line">        adjMat[j][i] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= <span class="built_in">size</span>() || j &gt;= <span class="built_in">size</span>() || i == j) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"顶点不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">        adjMat[i][j] = <span class="number">0</span>;</span><br><span class="line">        adjMat[j][i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"顶点列表 = "</span>;</span><br><span class="line">        <span class="built_in">printVector</span>(vertices);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"邻接矩阵 ="</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">printVectorMatrix</span>(adjMat);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vec) {</span><br><span class="line">            std::cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVectorMatrix</span><span class="params">(<span class="type">const</span> std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;row : matrix) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> val : row) {</span><br><span class="line">                std::cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            }</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>邻接矩阵也可表示有权图，但空间浪费明显，无论稀疏还是密集：<br>在稀疏图中，尽管边的数量很少，但邻接矩阵仍然需要为每个可能的顶点对（即矩阵中的每个元素）分配空间。大多数这些顶点对之间实际上是没有边的，因此这些空间是浪费的。<br>在密集图中，虽然边的数量很多，但邻接矩阵仍然需要为每个顶点对分配空间，即使某些顶点对之间可能有多个边。例如，如果图中有两个顶点之间有 5 条边，邻接矩阵中的对应元素就需要存储这 5 条边的权重信息，而实际上只需要存储一个权重信息就足够了。</p>
</blockquote>
<blockquote>
<p>图规模较小时倾向于使用邻接矩阵</p>
</blockquote>
<h3 id="效率对比"><a href="#效率对比" class="headerlink" title="效率对比"></a>效率对比</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">adjacency-matrix</th>
<th align="center">adjacency-list(ll)</th>
<th align="center">adjacency-list(hash)</th>
</tr>
</thead>
<tbody><tr>
<td align="center"> 边的存在性</td>
<td align="center"> $O(1)$</td>
<td align="center">$O(E)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center"> 添加边</td>
<td align="center"> $O(1)$</td>
<td align="center">$O(1)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center"> 删除边</td>
<td align="center"> $O(1)$</td>
<td align="center">$O(E)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center"> 添加顶点</td>
<td align="center"> $O(V)$</td>
<td align="center">$O(1)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center"> 删除顶点</td>
<td align="center"> $O(V^2)$</td>
<td align="center">$O(V+E)$</td>
<td align="center">$O(V)$</td>
</tr>
<tr>
<td align="center"> 内存空间占用</td>
<td align="center"> $O(V^2)$</td>
<td align="center">$O(V+E)$</td>
<td align="center">$O(V+E)$</td>
</tr>
</tbody></table>
<h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><div class="callout question">
  Given an adjacency-list representation of a directed graph, how long does it take
  to compute the out-degree of every vertex? How long does it take to compute the
  in-degrees?
</div>
   
<blockquote>
<p>题目是求基于邻接表表示的有向图，计算每个顶点的出度，入度的时间复杂度分别是多少。<br>   顶点的出度很容易，每个顶点的邻接表存储的就是其指向的顶点，故直接计算每个顶点的邻接表<br>   长度即为其出度，可知要遍历整个图，因此时间复杂度为 O (V+E)。<br>顶点的入度的话，邻接表里存储的每个顶点都是被指向的顶点，也就是说在邻接表里的顶点每出现一次就表明其被指向一次，即入度 + 1，因此时间复杂度也为 O (V+E)。</p>
</blockquote>
<div class="callout question">
  The transpose of a directed graph $G = (V, E)$ is the graph $G^T = (V, E^T)$, where $E^T = \{(v, u) \in V \times V : (u, v) \in E\}$. That is, $G^T$ is $G$ with all its edges reversed.
   Describe efficient algorithms for computing $G^T$ from $G$, for both the adjacency-
   list and adjacency-matrix representations of $G$. Analyze the running times of your
   algorithms.
</div>

<blockquote>
<p>这题说的是有向图的转置，即把边的方向都反过来，描述计算 $G^T$ 的算法。<br>伪代码如下</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">transposeAdjList</span><span class="params">(G)</span>:  //时间复杂度：O(V+E)</span></span><br><span class="line"><span class="function">    GT =</span> empty adjacency list <span class="keyword">for</span> each vertex in G</span><br><span class="line">    <span class="keyword">for</span> each vertex u in G:</span><br><span class="line">        <span class="keyword">for</span> each vertex v in adjacency list of u:</span><br><span class="line">            <span class="function">add u to adjacency list of v in GT</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> GT</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">function <span class="title">transposeAdjMatrix</span><span class="params">(G)</span>:  //时间复杂度：O(V^<span class="number">2</span>)</span></span><br><span class="line"><span class="function">    GT =</span> empty matrix of same size as G</span><br><span class="line">    <span class="keyword">for</span> each vertex u in G:</span><br><span class="line">        <span class="keyword">for</span> each vertex v in G:</span><br><span class="line">            <span class="keyword">if</span> G[u][v] == <span class="number">1</span>:</span><br><span class="line">                GT[v][u] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> GT</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>equivalent undirected graph 等效无向图</p>
</blockquote>
<blockquote>
<p>大概就是保留原有向图所有顶点，边的方向被忽略，不包含任何自环</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">convertToUndirectedGraph</span><span class="params">(G)</span>:</span></span><br><span class="line"><span class="function">    G0 =</span> <span class="keyword">new</span> adjacency list <span class="keyword">for</span> each vertex in G</span><br><span class="line">    <span class="keyword">for</span> each vertex u in G:</span><br><span class="line">        <span class="keyword">for</span> each vertex v in adjacency list of u:</span><br><span class="line">            <span class="keyword">if</span> u ≠ v <span class="built_in">and</span> (u, v) <span class="keyword">not</span> in G0 <span class="built_in">and</span> (v, u) <span class="keyword">not</span> in G0:<span class="comment">//忽略方向</span></span><br><span class="line">                <span class="built_in">add</span> (u, v) to G0</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> u = v:<span class="comment">//排除自环</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> G0</span><br></pre></td></tr></tbody></table></figure>

<div class="callout question">
  The square of a directed graph $G = (V, E)$ is the graph $G^2 = (V, E)$ such that
   $(u, v) \in E^2$ if and only if $G$ contains a path with at most two edges between
   u and v. Describe efficient algorithms for computing $G^2$ from $G$ for both the
   adjacency-list and adjacency-matrix representations of $G$. Analyze the running
   times of your algorithms.
</div>

<p>// 这题提出了平方有向图的定义，就是边 (u, v) 在 $G^2$ 中当且仅当在 $G$ 中包含了 $u \to v$ 不超过两条边的路径，换句话说，$G^2$ 包含了 $G$ 中所有顶点对之间长度不超过 2 的路径，要求描述计算 $G^2$ 的算法。(原图中有自环的话平方图也会有，如果想排除自环就添加控制条件约束即可)</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度：O(|V|^2+|V|E).</span></span><br><span class="line"><span class="function">Algorithm <span class="title">computeSquareAdjList</span><span class="params">(G)</span>:</span></span><br><span class="line"><span class="function">    // Initialize the adjacency list for the square graph G^<span class="number">2</span></span></span><br><span class="line"><span class="function">    G2 =</span> empty adjacency list <span class="keyword">for</span> each node in V</span><br><span class="line">    <span class="comment">// Iterate over each node u in the graph</span></span><br><span class="line">    <span class="keyword">for</span> each u in V:</span><br><span class="line">        <span class="comment">// Set of nodes reachable from u within one step</span></span><br><span class="line">        direct_neighbors = <span class="built_in">set</span>(G[u])</span><br><span class="line">        <span class="comment">// Set of nodes reachable from u within two steps</span></span><br><span class="line">        two_step_neighbors = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment">// Iterate over each direct neighbor v of u</span></span><br><span class="line">        <span class="keyword">for</span> each v in direct_neighbors:</span><br><span class="line">            <span class="comment">// Add direct neighbors to G^2</span></span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> in G2[u]:</span><br><span class="line">                G2[u].<span class="built_in">append</span>(v)</span><br><span class="line">            <span class="comment">// Iterate over each neighbor w of v</span></span><br><span class="line">            <span class="keyword">for</span> each w in G[v]:</span><br><span class="line">                <span class="comment">// Add w as a two-step neighbor of u if not already added</span></span><br><span class="line">                <span class="keyword">if</span> w != u <span class="keyword">and</span> w <span class="keyword">not</span> in direct_neighbors <span class="keyword">and</span> w <span class="keyword">not</span> in two_step_neighbors:</span><br><span class="line">                    two_step_neighbors.<span class="built_in">add</span>(w)</span><br><span class="line">                    G2[u].<span class="built_in">append</span>(w)</span><br><span class="line">    <span class="keyword">return</span> G2</span><br><span class="line"><span class="comment">//时间复杂度：(|V|^3)</span></span><br><span class="line">Algorithm <span class="built_in">computeSquareAdjMatrix</span>(G):</span><br><span class="line">    <span class="comment">// Initialize the adjacency matrix for the square graph G^2</span></span><br><span class="line">    n = number of nodes in V</span><br><span class="line">    A2 = <span class="keyword">new</span> matrix of size n x n filled with <span class="number">0</span>s</span><br><span class="line">    <span class="comment">// Calculate the square of the adjacency matrix</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">0</span> to n - <span class="number">1</span>:</span><br><span class="line">            <span class="comment">// A2[i][j] is 1 if there is a path of length at most 2 from i to j</span></span><br><span class="line">            <span class="keyword">if</span> A[i][j] == <span class="number">1</span>:</span><br><span class="line">                A2[i][j] = <span class="number">1</span>  <span class="comment">// Direct edge (i, j)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> k = <span class="number">0</span> to n - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> A[i][k] == <span class="number">1</span> <span class="keyword">and</span> A[k][j] == <span class="number">1</span>:</span><br><span class="line">                        A2[i][j] = <span class="number">1</span>  <span class="comment">// Path of length 2 from i to j</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A2</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>此题拓展：$G^k$ 包含了 $G$ 中所有顶点对之间长度不超过 $k$ 的路径</p>
</blockquote>
<div class="callout question">
  Most graph algorithms that take an adjacency-matrix representation as input require $\Omega (V^2)$ time, but there are some exceptions. Show how to determine whether a directed graph $G$ contains a universal sink--a vertex with in-degree |V| - 1 and out-degree 0--in $O(V)$ time, given an adjacency matrix for $G$.
</div>

<p>// 这题说的是很多基于邻接矩阵的图算法都需要 $\Omega (V^2)$ 的时间复杂度，但也有一些例外，比如查看一个有向图是否含有全局汇点（入度为 | V| - 1，出度为 0）。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">findUniversalSink</span><span class="params">(G)</span>:</span></span><br><span class="line"><span class="function">    candidate =</span> <span class="number">1</span>  <span class="comment">//这里索引从1开始，candidate为候选全局汇点</span></span><br><span class="line">    <span class="keyword">for</span> v from <span class="number">2</span> to |V|:</span><br><span class="line">        <span class="keyword">if</span> G[candidate][v] == <span class="number">1</span>: <span class="comment">//找到第一个出度为0的点作为最终的候选点</span></span><br><span class="line">            candidate = v</span><br><span class="line"></span><br><span class="line">    inDegree = <span class="number">0</span></span><br><span class="line">    outDegree = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> u from <span class="number">1</span> to |V|:</span><br><span class="line">        inDegree += G[u][candidate]</span><br><span class="line">        outDegree += G[candidate][u]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> inDegree == |V| - <span class="number">1</span> <span class="keyword">and</span> outDegree == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> candidate</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"No universal sink found"</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>这里确定候选汇点的形式很讲究，首先主对角线上元素都为 0，因此无参考价值，故只在其上方查找。只要遇到一个 1，就换到下一行（即下一个顶点），因为全局汇点没有出边，只要是 0，就在该行一直往后验证。到这里可能就有疑问（其实就是我的疑问罢了）：假设候选汇点一直都是 1，那么就只检查了第一行，其它行都没检查呢，为啥只要这候选汇点不是真的全局汇点，整个图就没有全局汇点。其实每检查一条边就相当于检查了一个顶点，比如，如果 $G [1][2] == 0$ 的话，就说明第二个顶点没有接受第一个顶点的入边，这同样是不符合全局汇点定义的，因为全局汇点是除了它自身，其它顶点都会指向它，因此该次检查排除了第二个顶点。如果 $G [1][3]$ 也 == 0 的话，那就排除了第三个顶点，以此类推。所以无论 $G [candidate][v]$ 等于 0 还是 1，都是有价值的，这使得定位候选汇点是固定地检查 | V| - 1 遍即可。</p>
</blockquote>
<div class="callout question">
 The incidence matrix of a directed graph $G = (V, E)$ with no self-loops is a $|V| \times |E|$ matrix $B = (b_{ij})$ such that
 $$
 b_{ij} = 
 \begin{cases} 
 -1, &amp; \text{ if edge j leaves vertex i}  \\ 
 1, &amp; \text{ if edge j enters vertex i} \\
 0, &amp; \text{ otherwise}  
 \end{cases} 
 $$
   Describe what the entries of the matrix product $B B^T$ represent, where $B^T$ is the
   transpose of B.
</div>

<blockquote>
<p>这题说的是有向无环图的关联矩阵，直接建立顶点与每条边的对应关系，出边就是 - 1，入边就是 1，没有关系就是 0。题目要求描述 $B B^T$ 矩阵的元素都代表什么。</p>
</blockquote>
<ol>
<li>对角线元素 $c_{ii}$​ 表示顶点 i 的度数，即与该顶点相关联的边的数量，包括入度和出度的边。<blockquote>
<ol start="2">
<li>非对角线元素 $c_{ij}$​（其中 i≠j）表示顶点 i 和 j 之间共享的边的数量，经计算我们可以发现 $B B^T$ 矩阵的元素要么是 0，要么是负数，没有正数。所以如果 $c_{ij}​=0$，则表示顶点 i 和 j 之间没有共享的边，而非零值则表示它们之间存在共享的边，如果是有多重边 (multiple edges) 的话，这个非零值就不只是 - 1 了。这里没直接说多重图 (multigraphs)，是因为多重图是包括了自环和多重边的，但题目说的是有向无环图。</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="Breadth-first-search"><a href="#Breadth-first-search" class="headerlink" title="Breadth-first search"></a>Breadth-first search</h2><blockquote>
<p>// 时间复杂度：O (V + E)<br>$BFS(G, s)$</p>
</blockquote>
<pre><code>for each vertex u $\in G.V - \{s\}$      //初始化
    u.color = WHITE
    $u.d = \infty$                              //d是距离
    u.$\pi$ = NIL                            //$\pi$是前驱
s.color = $GRAY$
s.d = 0
s.$\pi$ = NIL
$Q = \not 0$                                        //初始化队列
ENQUEUE(Q, s)
while Q $\not = \not 0$
    u = DEQUEUE(Q)
    for each vertex v in $G$.Adj[u]
        if v.color = WHITE
            v.color = $GRAY$
            v.d = u.d + 1
            v.$\pi$ = u
            ENQUEUE(Q, v)      //可以发现队列里的顶点都是灰色的
    u.color = BLACK
</code></pre>
<p>// 图的广搜使用了颜色标记方法，白色表示顶点未被发现，灰色表示该顶点已被发现，但其邻接顶点可能还有未被发现的顶点，黑色则表示其邻接顶点全被发现。<br><img src="https://telegraph-image-eja.pages.dev/file/68170db1c351c1c1154fb.png" alt="bfs"><br>// 该图展示了广搜全过程，广搜的结果可能不一样，这取决于 for each vertex v in $G$.Adj [u] 的遍历顺序。</p>
<h3 id="Shortest-paths"><a href="#Shortest-paths" class="headerlink" title="Shortest paths"></a>Shortest paths</h3><blockquote>
<p>定义 $\delta (s, v)$ 为从 s 到 v 的所有路径中的最少的边数</p>
</blockquote>
<h4 id="Lemma"><a href="#Lemma" class="headerlink" title="Lemma"></a>Lemma</h4><ul>
<li><p>(1) Let $G = (V, E)$ be a directed or undirected graph, and let $s \in V$ be an arbitrary<br>vertex. Then, for any edge $(u, v) \in E$,</p>
<p>$$<br>\delta(s, v) \leq \delta(s, u) + 1<br>$$</p>
<p><img src="https://telegraph-image-eja.pages.dev/file/40f16ccf9c4b758354fd3.png" alt="image"></p>
<blockquote>
<p>对于该引理有个方便记忆的描述，即三角形两边之和大于第三边，见 A 图，公式中的 1 就是 (u, v) 这条确定的边。</p>
<p>我一开始的想法是，(u, v) 这条边有 A, B, C 三种情况 (不严谨)，A 表示顶点 u, v 是同级的，对应 $\delta (s, v) = \delta (s, u)$ 的情况；B 表示顶点 u 相对于 s 的位置来说在 v 前面，对应 $\delta (s, v) = \delta (s, u) + 1$ 的情况；C 表示顶点 v 相对于 s 的位置来说在 u 前面，对应 $\delta (s, v) &lt; \delta (s, u)$ 的情况，特别地，C 中的蓝色曲线代表了 s 到 u 的其他路径，所以说 A 是 C 的特殊情况，因此也可以分成两种情况，上面都是建立在 u 是从 s 可以到达的情况，不可以到达的情况参照下面的解释。<br>// 上面纯属主观想法描述，可能存在纰漏以及说法不严谨的地方。</p>
<p>CLRS 里面的解释：<br>① 如果 u 是从 s 可以到达的顶点，那么 v 也是可达的，这种情况下从 $s \to v$ 的最短路径不可能比从 $s \to u$ 的最短路径再加上边 (u, v) 更长，因此不等式成立。// 这是原话，看到这句我觉得我上面的想法貌似就是想表达这个意思。反正就是因为 $\delta (s, u)$ 本身就是最短的，然后与顶点 v 再连一条边的话，那么 $\delta (s, v)$ 的路径要么不经过 u，要么经过 u。不经过的话就必定有 $\delta (s, v) \leq \delta (s, u) + 1$，因为如果不等号为 &gt;，那么 $\delta (s, u) + 1$ 这条路径才应该是 $\delta (s, v)$ 真正的路径，因为它更短；经过 u 的话就说明 u 是 $\delta (s, v)$ 路径的一部分，此时在无向图中 $\delta (s, v)$ 不仅有上限 $\delta (s, u) + 1$，还有 $\delta (s, u) - 1$ 这个下限。<br>② 如果 u 是从 s 不可以到达的顶点，那么在上面伪代码算法中可知，$\delta (s, u) = \infty$，等式显然成立。</p>
</blockquote>
</li>
<li><p>(2) Let $G = (V, E)$ be a directed or undirected graph, and suppose that BFS is run<br>on $G$ from a given source vertex $s \in V$ . Then, for each vertex $v \in V$ , the value v.d<br>computed by BFS satisfies $v.d \geq \delta (s, v)$ at all times, including at termination.</p>
</li>
</ul>
<blockquote>
<p>这里是用归纳法进行证明：归纳假设即为 $v.d \geq \delta (s, v)$ 对于所有 $v \in V$ 都成立<br>① 基本情况：在把源点 s 入队后，$s.d = 0 = \delta (s, s)$ 并且对于所有除 s 外的顶点 v 都有 $v.d = \infty \geq \delta (s, v)$，因此等式成立。<br>② 归纳：考虑到一个白色顶点 v 是在对顶点 u 的邻接表搜索中被发现的，因此 $v.d = u.d + 1$（可见伪代码），基于归纳假设，有 $v.d \geq \delta (s, u) + 1$，由引理 (1) 可知 $\delta (s, u) + 1 \geq \delta (s,v)$，因此等式成立。</p>
</blockquote>
<ul>
<li>(3) Suppose that during the execution of BFS on a graph $G = (V, E)$, the queue Q<br>contains the vertices $&lt;v_1, v_2, . . . , v_r&gt;$, where $v_1$ is the head of Q and $v_r$ is the tail.<br>Then, $v_r.d \leq v_1.d + 1$ and $v_i.d \leq v_{i + 1}.d$ for i = 1, 2, . . . , r - 1.</li>
</ul>
<blockquote>
<p>这里也是用归纳法进行证明，但直接理解好像更容易。首先，假设队列里只能有不超过两种距离不同的顶点，如果是只有一种距离，假设为 d，那么队列里肯定都是上一次出队的那个顶点 (距离为 d - 1) 的邻接表 (假设为 u) 里的，假设还没遍历完，那就继续添加，此时队列里顶点距离都是 d。遍历完后就又要把当前队列第一个顶点出队，如果其邻接表为空，那就下一个继续出队操作，此时队列还是一种距离的情况，如果不为空，那就开始遍历其邻接表，只要是对邻接表 u 里面的元素执行出队，之后入队的顶点的距离都会是 d+1，在此过程中距离就有两种情况，这种情况持续到 u 的所有顶点都出队了，那么此时队列里就只有 d+1 的顶点了，就又变回一种距离的情况了，以此类推，因此队列里不可能有超过两种距离，且从过程可知，跨度不超过 1，因此 $v_r.d \leq v_1.d + 1$ 成立，又因为代码中 d 的计算只有加没有减，因此在后面入队的肯定 $\geq$ 在前面入队的，因此，$v_i.d \leq v_{i + 1}.d$ 也成立。</p>
</blockquote>
<h4 id="Corollary"><a href="#Corollary" class="headerlink" title="Corollary"></a>Corollary</h4><ul>
<li>Suppose that vertices $v_i$ and $v_j$ are enqueued during the execution of BFS, and that $v_i$ is enqueued before $v_j$. Then $v_i.d \leq v_j.d$ at the time that $v_j$ is enqueued.</li>
</ul>
<h4 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h4><ul>
<li>Let $G = (V, E)$ be a directed or undirected graph, and suppose that BFS is run<br>on $G$ from a given source vertex $s \in V$ . Then, during its execution, BFS discovers<br>every vertex $v \in V$ that is reachable from the source s, and upon termination,<br>$v.d = \delta (s, v)$ for all $v \in V$ . Moreover, for any vertex $v \not = s$ that is reachable from s, one of the shortest paths from s to v is a shortest path from s to $v.\pi$ followed by the edge $(v.\pi, v)$.</li>
</ul>
<blockquote>
<p>这里定理其实主要表达的就是 $v.d = \delta (s, v)$，这就使得广搜可以用来求最短路径问题。<br>这个定理的证明采用反证法：<br>假设存在顶点的 d 值不等于它最短路径的距离。对于所有的这种顶点，设顶点 v 的最短距离为 $\delta (s, v)$，通过引理 (2) 可知，$v.d \geq \delta (s, v)$，因此在这里的顶点 v 有 $v.d &gt; \delta (s, v)$①，当然不能有 $v \not = s$，因为 s.d = 0 并且 $\delta (s, s) = 0$。而且，顶点 v 必须是从 s 可达的，否则我们将有 $\delta (s, v) = \infty \geq v.d$。设 u 是从 s 到 v 的最短路径上紧邻 v 前面的顶点 (因为 $v \not = s$，所以顶点 u 必须存在)，这样就有 $\delta (s, v) = \delta (s, u) + 1$② 了。因此 $\delta (s, u) &lt; \delta (s, v)$，又因为我们设 u 的方式，所以有 $u.d = \delta (s, u)$③。<br>结合 ①②③，就有了下图的公式，然后对 v 的所有情况进行讨论，推出矛盾，证明 $v.d = \delta (s, v)$ 成立。具体看下图：</p>
</blockquote>
<p><img src="https://telegraph-image-eja.pages.dev/file/a9bfbbf9fc07d7969e851.png" alt="?"></p>
<h3 id="Breadth-first-trees"><a href="#Breadth-first-trees" class="headerlink" title="Breadth-first trees"></a>Breadth-first trees</h3><p>上面广搜全过程图片中的蓝色边正展示了广度优先树在 BFS 过程中被建立，这个树对应着 $\pi$ 属性。<br>形式化的定义即是：对于有源点 s 的图 $G = (V, E)$，定义 $G$ 的前驱子图 (predecessor subgraph) $G_\pi = (V_\pi, E_\pi)$，其中 $V_\pi = {v \in V: v.\pi \not = NIL} \cup {s}$，$E_\pi = {(v.\pi, v): v \in V_\pi - {s}}$。这样的 $G_\pi$ 就是广度优先树，$E_\pi$ 为树边。</p>
<h2 id="Depth-first-search"><a href="#Depth-first-search" class="headerlink" title="Depth-first search"></a>Depth-first search</h2><ul>
<li>与广搜不同，深搜的前驱子图可能包含多个树，因为深搜可能从多个源点进行。<br>它对 $G_\pi$ 的定义是：$G_\pi = (V, E_\pi)$，其中 $E_\pi = {(v.\pi, v): v \in V \wedge v.\pi \not = NIL}$。<br>深度优先搜索的前驱子图形成了包含多个深度优先树的深度优先森林。</li>
<li>深度优先搜索着色方法与广搜一样，该方法在这里保证了每个顶点只在一棵深度优先树中出现，因此这些树都是不相交的。</li>
<li>与广搜不一样的是，深搜过程还提供了时间戳，每个顶点有两个时间戳，第一个时间戳 v.d 记录了 v 什么时候第一次被发现，第二个时间戳 v.f 记录了什么时候完成了对 v 的邻接表的遍历。因为每个顶点都有两个时间戳，因此时间戳范围是 $1 \to 2|V|$ 的整数，并且 $v.d &lt; v.f$。v 在 v.d 之前为白色，在 v.d 到 v.f 之间为灰色，在 v.f 之后为黑色。下面是深搜伪代码：</li>
</ul>
<blockquote>
<p>// 时间复杂度：O (V + E)<br>$DFS(G)$</p>
</blockquote>
<pre><code>   for each vertex $u \in G.V$                  //初始化
       u.color = WHITE
       u.$\pi$ = NIL
   time  = 0
   for each vertex $u \in G.V$
       if u.color == WHITE
           DFS-VISIT $(G, u)$
</code></pre>
<blockquote>
<p>DFS-VISIT $(G, u)$</p>
</blockquote>
<pre><code>   time = time + 1
   u.d = time
   u.color =$GRAY$
   for each vertex v in $G.Adj[u]$
       if v.color == WHITE
           v.$\pi$ = u
           DFS-VISIT $(G, v)$               //体现了深度优先
   time = time + 1
   u.f = time
   u.color = BLACK
</code></pre>
<p><img src="https://telegraph-image-eja.pages.dev/file/275c9f0fa7b28c8b16770.png" alt="dfs"><br>// 这是深搜全过程图</p>
<h3 id="Properties-of-depth-first-search"><a href="#Properties-of-depth-first-search" class="headerlink" title="Properties of depth-first search"></a>Properties of depth-first search</h3><ul>
<li>(1) 深度优先搜索生成的前驱子图 $G_\pi$ 为一个有若干棵树的森林，因为深度优先树的结构与 &nbsp;DFS-VISIT&nbsp; 递归调用的结构完全对应，也就是说，$u = v.\pi$ 当且仅当 &nbsp;DFS-VISIT (G, v)&nbsp; 在搜索 &nbsp;u&nbsp; 的邻接表时被调用，此外，在深度优先森林中，顶点 v 是顶点 u 的后代当且仅当顶点 v 在顶点 u 为灰色的时间段里被发现。<br><img src="https://telegraph-image-eja.pages.dev/file/b2b7493044770da13ffa1.png" alt="image"></li>
<li>(2) 顶点的发现时间和完成的时间具有括号化结构，与此对应的是括号化定理。</li>
</ul>
<h3 id="Parenthesis-theorem"><a href="#Parenthesis-theorem" class="headerlink" title="Parenthesis theorem"></a>Parenthesis theorem</h3><p>在对有向图或无向图 &nbsp;$G=(V, E)$ 的深度优先搜索中，对于任意两个顶点 &nbsp;u&nbsp; 和 &nbsp;v&nbsp;，以下三种情况只有一种成立：</p>
<ul>
<li>若 &nbsp;$[u.d, u.f]∩[v.d, v.f] = ∅$&nbsp;，则在深度优先森林中，u 不是 v 的后代，v 也不是 u 的后代。</li>
<li>若 $[u.d, u.f]⊂[v.d, v.f]$，则在深度优先森林中，u 是 v 的后代。</li>
<li>若 $[v.d, v.f]⊂[u.d, u.f]$，则在深度优先森林中，v 是 u 是后代。<br><img src="https://telegraph-image-eja.pages.dev/file/26624ae22bfd773c415fa.png" alt="image"></li>
</ul>
<h3 id="Corollary-Nesting-of-descendants’-intervals"><a href="#Corollary-Nesting-of-descendants’-intervals" class="headerlink" title="Corollary(Nesting of descendants’ intervals)"></a>Corollary(Nesting of descendants’ intervals)</h3><p>在有向图或无向图 $G = (V, E)$ 的深度优先森林中，顶点 v 是顶点 u 的真后代当且仅当 $u.d &lt; v.d &lt; v.f &lt; u.f$。</p>
<h3 id="White-path-theorem"><a href="#White-path-theorem" class="headerlink" title="White-path theorem"></a>White-path theorem</h3><p>在有向图或无向图 $G=(V, E)$ 的深度优先森林中，顶点 v 是顶点 u 的后代当且仅当在搜索发现 u 的时刻 u.d&nbsp;，存在一条从 u 到 v 的全部由白色顶点构成的路径。</p>
<ul>
<li>$\Rightarrow$：如果 v = u，那么从 u 到 v 路径上只有一个顶点 u，当 u.d = time 时刻，u 还是白色；如果 v 是 u 的真后代，根据推论，有 $u.d &lt; v.d$， 因此 v 是白色。由于 v 可以是 u 的任意后代，所以在深度优先森林中从 u 到 v 的唯一简单路径上的所有顶点在时间 u.d 时为白色。</li>
<li>$\Leftarrow$：若在时刻 u.d，存在一条从 u 到 v 的全部由白色顶点构成的路径，先假设在深度优先森林中 v 不是 u 的后代。不失一般性，假设路径上除 v 以外的每个顶点都成为 u 的后代。(否则，假设 v 是在没有成为 u 的后代的路径上离 u 最近的顶点。) 设 w 是 v 在路径上的前驱，那么 w 就是 u 的后代 (w 和 u 实际上可能是同一个顶点)。由推论可知，$w.f  \leq u.f$。又因为 v 必须在 u 被发现之后被发现，但在 w 完成的时间戳之前，则有 $u.d &lt; v.d &lt; w.f \leq u.f$。根据括号化定理可知，$[v.d, v.f]⊂[u.d, u.f]$。由推论可知，v 必须为 u 的后代</li>
</ul>
<h3 id="Classification-of-edges"><a href="#Classification-of-edges" class="headerlink" title="Classification of edges"></a>Classification of edges</h3><ul>
<li>树边 (Tree edges)：$G_\pi$ 上的边，若顶点 v 是通过边 (u, v) 第一次被发现，则 (u, v) 是一条树边。</li>
<li>后向边 (Back edges)：若边 (u, v) 为连接 u 和它在深度优先树中的一个祖先 v 的边，包括自环 (即 u = v)，则 (u, v) 是一条后向边。</li>
<li>前向边 (Forward edges)：若边 (u, v) 为连接 u 和它的一个真后代 v 的非树边，则 (u, v) 是一条前向边。</li>
<li>横向边 (Cross edges)：其它所有边，它们可以连接同一深度优先树中的顶点，只要其中一个顶点不是另一个顶点的祖先；它们也可以连接不同深度优先树中的顶点。</li>
</ul>
<h2 id="Topological-sort"><a href="#Topological-sort" class="headerlink" title="Topological sort"></a>Topological sort</h2><p>对象是有向无环图 (directed acyclic graphs)，因此拓扑排序可以用来判断一个图有没有环，很多实际应用都需要使用有向无环图来指明时间的先后顺序。<br>拓扑排序是一种针对有向无环图（DAG）的排序算法，它不是基于元素之间的比较，而是基于它们之间的依赖关系。原理上，拓扑排序是对有向无环图进行深度优先搜索（DFS）或广度优先搜索（BFS）的一种应用。它通过这些搜索算法来确定图中节点的线性序列，这个序列满足：对于图中的每一条有向边 (u, v)（从节点 u 指向节点 v），u 在序列中都出现在 v 之前。这样的序列满足了图中节点间的所有依赖关系。</p>
<ul>
<li><strong>依赖关系</strong>：<br>图中的每个节点代表一个任务或活动，有向边代表一个任务必须在另一个任务之后完成。拓扑排序能够确保对于任何节点，它的所有前驱节点（即所有指向它的节点）都在它之前被访问。<blockquote>
<p>伪代码：<br>TOPOLOGICAL-SORT$(G)$<br>       call $DFS(G)$ to compute finish times v.f for each vertex v<br>       as each vertex is finished, insert it onto the front of a linked list<br>       return the linked list of vertices</p>
</blockquote>
</li>
</ul>
<h2 id="Strongly-connected-components"><a href="#Strongly-connected-components" class="headerlink" title="Strongly connected components"></a>Strongly connected components</h2><ul>
<li>有向图 $G = (V, E)$ 的一个强连通分量是一个最大顶点集 $C \subseteq V$，对于每一对顶点 $u, v \in C$，那么 u, v 相互可达。</li>
<li>$G 和 G^T$ 有完全相同的强连通分量。</li>
<li>分量图 $G^{SCC} = (V^{SCC},E^{SCC})$，为简化后的有向图，把每个强连通分量压缩成一个顶点，以便研究它们之间的关系。<br><img src="https://telegraph-image-eja.pages.dev/file/f02f4a1572ce744d646b2.png" alt="image"></li>
</ul>
<blockquote>
<p>伪代码：<br>$STRONGLY-CONNECTED-COMPONENTS(G)$<br>1 call DFS(G) to compute finish times u.f for each vertex u<br>2 create $G^T$<br>3 call DFS($G^T$) , but in the main loop of DFS, consider the vertices<br>in order of decreasing u.f (as computed in line 1)<br>4 output the vertices of each tree in the depth-ûrst forest formed in line 3 as a</p>
</blockquote>
<pre><code>    separate strongly connected component
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Command 自用</title>
    <url>/2025/08/06/Git-Command/</url>
    <content><![CDATA[<h2 id="项目模拟场景"><a href="#项目模拟场景" class="headerlink" title="项目模拟场景"></a>项目模拟场景</h2><h3 id="项目初始化阶段"><a href="#项目初始化阶段" class="headerlink" title="项目初始化阶段"></a>项目初始化阶段</h3><h4 id="1-创建远程仓库"><a href="#1-创建远程仓库" class="headerlink" title="1. 创建远程仓库"></a>1. 创建远程仓库</h4><ul>
<li>在 GitHub 创建 private 仓库</li>
<li>邀请协作者</li>
</ul>
<h4 id="2-初始化本地项目"><a href="#2-初始化本地项目" class="headerlink" title="2. 初始化本地项目"></a>2. 初始化本地项目</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mkdir ProjectName &amp;&amp; cd ProjectName</span><br><span class="line">echo "# ProjectName - 项目描述" &gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m "chore: initial project setup"</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建基础分支结构</span></span><br><span class="line">git switch -c develop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建初始目录结构</span></span><br><span class="line">mkdir -p backend frontend docs</span><br><span class="line">echo "后端服务" &gt; backend/README.md</span><br><span class="line">echo "前端应用" &gt; frontend/README.md</span><br><span class="line">echo "项目文档" &gt; docs/README.md</span><br><span class="line">git add .</span><br><span class="line">git commit -m "build: create project structure"</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送到远程</span></span><br><span class="line">git remote add origin https://github.com/username/ProjectName.git</span><br><span class="line">git push -u origin main develop</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-设置分支保护-仓库-settings"><a href="#3-设置分支保护-仓库-settings" class="headerlink" title="3. 设置分支保护(仓库 settings)"></a>3. 设置分支保护 (仓库 settings)</h4><ul>
<li><code>main</code> 分支：Require pull request, Require 1 approval, Require status checks</li>
<li><code>develop</code> 分支：Require pull request, Require status checks</li>
</ul>
<h3 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有团队成员克隆仓库</span></span><br><span class="line">git clone https://github.com/username/ProjectName.git</span><br><span class="line">cd ProjectName</span><br><span class="line">git switch develop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化后端项目</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 后端成员操作</span></span></span><br><span class="line">git pull origin develop</span><br><span class="line">cd backend</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具体技术栈初始化命令示例:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">spring init --dependencies=web,data-jpa,mysql,security --build=gradle -n BackendProject</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> BackendProject/* . &amp;&amp; <span class="built_in">rmdir</span> BackendProject</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m "build: initialize backend"</span><br><span class="line">git push origin develop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化前端项目</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 前端成员操作</span></span></span><br><span class="line">git pull origin develop</span><br><span class="line">cd frontend</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具体技术栈初始化命令示例:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm init vue@latest -- --projectName=<span class="string">"FrontendProject"</span> --typescript --pinia --vitest</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> FrontendProject/* . &amp;&amp; <span class="built_in">rmdir</span> FrontendProject</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m "build: initialize frontend"</span><br><span class="line">git push origin develop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果develop设置了分支保护，该push会失败，可以采用以下方法：</span></span><br><span class="line">git pull origin develop</span><br><span class="line">git switch -c feature/init-frontend</span><br><span class="line">cd frontend</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行前端初始化命令</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m "build: initialize frontend"</span><br><span class="line">git push -u origin feature/init-frontend</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前端成员去github网页创建PR，reviewer在网页处理PR，接着前端成员同步最新的develop</span></span><br><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line">git branch -d feature/init-frontend   # 删掉本地功能分支</span><br></pre></td></tr></tbody></table></figure>

<h2 id="项目开发阶段"><a href="#项目开发阶段" class="headerlink" title="项目开发阶段"></a>项目开发阶段</h2><h3 id="迭代-1：用户认证系统"><a href="#迭代-1：用户认证系统" class="headerlink" title="迭代 1：用户认证系统"></a>迭代 1：用户认证系统</h3><h4 id="后端成员开发认证-API"><a href="#后端成员开发认证-API" class="headerlink" title="后端成员开发认证 API"></a>后端成员开发认证 API</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line">git switch -c feature/backend-auth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发认证功能</span></span><br><span class="line"><span class="comment"># ... 编写JWT认证逻辑 ...</span></span><br><span class="line">git add backend/src/main/java/com/project/auth/**</span><br><span class="line">git commit -m <span class="string">"feat(auth): implement JWT authentication"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发API文档</span></span><br><span class="line"><span class="comment"># ... 添加Swagger注解 ...</span></span><br><span class="line">git add backend/src/main/java/com/project/controller/AuthController.java</span><br><span class="line">git commit -m <span class="string">"docs(auth): add swagger API documentation"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程</span></span><br><span class="line">git push -u origin feature/backend-auth</span><br></pre></td></tr></tbody></table></figure>

<h4 id="前端成员开发登录界面"><a href="#前端成员开发登录界面" class="headerlink" title="前端成员开发登录界面"></a>前端成员开发登录界面</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line">git switch -c feature/frontend-login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于后端Swagger生成TS类型</span></span><br><span class="line">npx openapi-typescript http://localhost:8080/v3/api-docs -o src/api-types.d.ts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发登录组件</span></span><br><span class="line"><span class="comment"># ... 创建Login.vue ...</span></span><br><span class="line">git add frontend/src/views/Login.vue</span><br><span class="line">git commit -m <span class="string">"feat(login): implement login page UI"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发认证逻辑</span></span><br><span class="line"><span class="comment"># ... 实现axios拦截器 ...</span></span><br><span class="line">git add frontend/src/services/auth.ts</span><br><span class="line">git commit -m <span class="string">"feat(auth): implement token management"</span></span><br><span class="line"></span><br><span class="line">git push -u origin feature/frontend-login</span><br></pre></td></tr></tbody></table></figure>

<h4 id="代码审查与合并"><a href="#代码审查与合并" class="headerlink" title="代码审查与合并"></a>代码审查与合并</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 后端成员创建PR: feature/backend-auth → develop</span></span><br><span class="line"><span class="comment"># 前端成员创建PR: feature/frontend-login → develop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 审查过程：</span></span><br><span class="line"><span class="comment">## 1. 前端成员验证后端API文档</span></span><br><span class="line"><span class="comment">## 2. 后端成员检查前端token处理逻辑</span></span><br><span class="line"><span class="comment">## 3. 项目经理批准合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并后操作（项目经理）：</span></span><br><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line"><span class="comment"># 如果不走网页PR，可在本地合并</span></span><br><span class="line">git merge --no-ff feature/backend-auth</span><br><span class="line">git merge --no-ff feature/frontend-login</span><br><span class="line">git push origin develop</span><br></pre></td></tr></tbody></table></figure>

<h3 id="迭代-2：数据分析看板"><a href="#迭代-2：数据分析看板" class="headerlink" title="迭代 2：数据分析看板"></a>迭代 2：数据分析看板</h3><h4 id="后端成员开发分析-API"><a href="#后端成员开发分析-API" class="headerlink" title="后端成员开发分析 API"></a>后端成员开发分析 API</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line">git switch -c feature/backend-analysis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库迁移脚本</span></span><br><span class="line"><span class="comment"># ... 使用Liquibase/Flyway等 ...</span></span><br><span class="line">git add backend/src/main/resources/db/changelog/v1.1__analysis_tables.xml</span><br><span class="line">git commit -m <span class="string">"db: add analysis tables"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发分析算法</span></span><br><span class="line"><span class="comment"># ... 集成数据分析模型 ...</span></span><br><span class="line">git add backend/src/main/java/com/project/service/AnalysisService.java</span><br><span class="line">git commit -m <span class="string">"feat(analysis): implement data analysis model"</span></span><br><span class="line"></span><br><span class="line">git push -u origin feature/backend-analysis</span><br></pre></td></tr></tbody></table></figure>

<h4 id="前端成员开发可视化看板"><a href="#前端成员开发可视化看板" class="headerlink" title="前端成员开发可视化看板"></a>前端成员开发可视化看板</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line">git switch -c feature/frontend-dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装可视化库</span></span><br><span class="line">npm install echarts vue-echarts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发看板组件</span></span><br><span class="line"><span class="comment"># ... 创建Dashboard.vue ...</span></span><br><span class="line">git add frontend/src/views/Dashboard.vue</span><br><span class="line">git commit -m <span class="string">"feat(dashboard): implement analysis charts"</span></span><br><span class="line"></span><br><span class="line">git push -u origin feature/frontend-dashboard</span><br></pre></td></tr></tbody></table></figure>

<h4 id="遇到问题：API-变更冲突"><a href="#遇到问题：API-变更冲突" class="headerlink" title="遇到问题：API 变更冲突"></a>遇到问题：API 变更冲突</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 后端成员修改了API响应格式</span></span><br><span class="line">git add backend/src/main/java/com/project/controller/DataController.java</span><br><span class="line">git commit -m <span class="string">"refactor(api): update response format for frontend"</span></span><br><span class="line">git push origin feature/backend-analysis --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前端成员需要同步变更</span></span><br><span class="line">git switch feature/frontend-dashboard</span><br><span class="line">git fetch origin</span><br><span class="line">git rebase origin/develop  <span class="comment"># 获取最新API变更</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决前端适配问题</span></span><br><span class="line"><span class="comment"># ... 更新数据处理逻辑 ...</span></span><br><span class="line">git add frontend/src/views/Dashboard.vue</span><br><span class="line">git commit -m <span class="string">"fix(dashboard): adapt to new API response format"</span></span><br><span class="line">git push origin feature/frontend-dashboard --force</span><br></pre></td></tr></tbody></table></figure>

<h3 id="迭代-3：推荐系统"><a href="#迭代-3：推荐系统" class="headerlink" title="迭代 3：推荐系统"></a>迭代 3：推荐系统</h3><h4 id="多人协作开发"><a href="#多人协作开发" class="headerlink" title="多人协作开发"></a>多人协作开发</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 后端成员A开发数据管理</span></span><br><span class="line">git switch develop</span><br><span class="line">git switch -c feature/backend-data-mgmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前端成员开发推荐界面</span></span><br><span class="line">git switch develop</span><br><span class="line">git switch -c feature/frontend-recommendation</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后端成员B开发推荐算法</span></span><br><span class="line">git switch develop</span><br><span class="line">git switch -c feature/backend-recommend-engine</span><br></pre></td></tr></tbody></table></figure>

<h4 id="遇到数据库冲突"><a href="#遇到数据库冲突" class="headerlink" title="遇到数据库冲突"></a>遇到数据库冲突</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 后端成员A提交了数据表变更</span></span><br><span class="line">git add backend/src/main/resources/db/changelog/v1.2__data_tables.xml</span><br><span class="line">git commit -m <span class="string">"db: add data tables"</span></span><br><span class="line">git push origin feature/backend-data-mgmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后端成员B也需要修改数据库</span></span><br><span class="line">git switch feature/backend-recommend-engine</span><br><span class="line">git fetch origin</span><br><span class="line">git rebase origin/develop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遇到冲突：db/changelog/changelog-master.yaml</span></span><br><span class="line"><span class="comment"># 解决冲突后</span></span><br><span class="line">git add backend/src/main/resources/db/changelog/</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line">git push origin feature/backend-recommend-engine --force</span><br></pre></td></tr></tbody></table></figure>

<h2 id="测试与发布阶段"><a href="#测试与发布阶段" class="headerlink" title="测试与发布阶段"></a>测试与发布阶段</h2><h3 id="预发布准备"><a href="#预发布准备" class="headerlink" title="预发布准备"></a>预发布准备</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 创建发布分支</span></span><br><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line">git switch -c release/v1.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新版本号</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1.0.0"</span> &gt; VERSION</span><br><span class="line">git add VERSION</span><br><span class="line">git commit -m <span class="string">"chore: prepare release v1.0.0"</span></span><br><span class="line">git push -u origin release/v1.0.0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="测试问题修复"><a href="#测试问题修复" class="headerlink" title="测试问题修复"></a>测试问题修复</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 发现权限问题</span></span><br><span class="line">git switch release/v1.0.0</span><br><span class="line">git switch -c fix/permission-issue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复后端权限验证</span></span><br><span class="line"><span class="comment"># ... 修改SecurityConfig等 ...</span></span><br><span class="line">git add backend/src/main/java/com/project/config/SecurityConfig.java</span><br><span class="line">git commit -m <span class="string">"fix(auth): correct role permissions"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并回发布分支</span></span><br><span class="line">git switch release/v1.0.0</span><br><span class="line">git merge --no-ff fix/permission-issue</span><br><span class="line">git push origin release/v1.0.0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="正式发布"><a href="#正式发布" class="headerlink" title="正式发布"></a>正式发布</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 合并到main分支</span></span><br><span class="line">git switch main</span><br><span class="line">git pull origin main</span><br><span class="line">git merge --no-ff release/v1.0.0</span><br><span class="line">git tag -a v1.0.0 -m <span class="string">"Initial release with core features"</span></span><br><span class="line">git push origin main --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新develop分支</span></span><br><span class="line">git switch develop</span><br><span class="line">git merge release/v1.0.0</span><br><span class="line">git push origin develop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除发布分支</span></span><br><span class="line">git branch -d release/v1.0.0</span><br><span class="line">git push origin --delete release/v1.0.0</span><br></pre></td></tr></tbody></table></figure>

<h2 id="生产环境问题处理"><a href="#生产环境问题处理" class="headerlink" title="生产环境问题处理"></a>生产环境问题处理</h2><h3 id="紧急修复示例"><a href="#紧急修复示例" class="headerlink" title="紧急修复示例"></a>紧急修复示例</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 从main创建热修复分支</span></span><br><span class="line">git switch main</span><br><span class="line">git pull origin main</span><br><span class="line">git switch -c hotfix/critical-bug-fix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复问题</span></span><br><span class="line"><span class="comment"># ... 修改相关服务 ...</span></span><br><span class="line">git add backend/src/main/java/com/project/service/DataService.java</span><br><span class="line">git commit -m <span class="string">"fix(service): handle large dataset processing"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并到main和develop</span></span><br><span class="line">git switch main</span><br><span class="line">git merge --no-ff hotfix/critical-bug-fix</span><br><span class="line">git tag -a v1.0.1 -m <span class="string">"Hotfix for critical bug"</span></span><br><span class="line">git push origin main --tags</span><br><span class="line"></span><br><span class="line">git switch develop</span><br><span class="line">git merge hotfix/critical-bug-fix</span><br><span class="line">git push origin develop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除热修复分支</span></span><br><span class="line">git branch -d hotfix/critical-bug-fix</span><br></pre></td></tr></tbody></table></figure>

<h2 id="checkout-和-switch-的区别"><a href="#checkout-和-switch-的区别" class="headerlink" title="checkout 和 switch 的区别"></a>checkout 和 switch 的区别</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分支切换</span></span><br><span class="line">git checkout existing-branch</span><br><span class="line">git switch existing-branch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建并切换分支</span></span><br><span class="line">git checkout -b feature/new-feature</span><br><span class="line">git switch -c feature/new-feature</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件恢复</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">核心场景：你还没提交，但把某个文件改坏了，想撤销所有未暂存的本地修改，让它立刻回到上一次提交时的样子（误删也用这个）</span></span><br><span class="line">git checkout -- src/components/Component.vue</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果已暂存，先用`git reset HEAD &lt;file&gt;`取消暂存，再用checkout</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看历史提交（只读模式）</span></span><br><span class="line">git checkout HEAD~3</span><br><span class="line">git switch --detach HEAD~3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安全机制</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当有未提交更改时尝试切换分支，switch会报错，而checkout会尝试自动合并，可能会导致数据丢失</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="pull-fetch-的区别"><a href="#pull-fetch-的区别" class="headerlink" title="pull &amp; fetch 的区别"></a>pull &amp; fetch 的区别</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pull = fetch + merge</span></span><br><span class="line">git pull origin develop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分步操作更安全</span></span><br><span class="line">git fetch origin           # 获取远程更新但不合并</span><br><span class="line">git log origin/develop..HEAD  # 查看差异</span><br><span class="line">git merge origin/develop    # 手动合并</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rebase方式拉取（保持线性历史）</span></span><br><span class="line">git pull --rebase origin develop</span><br></pre></td></tr></tbody></table></figure>

<h2 id="rebase-merge-的区别"><a href="#rebase-merge-的区别" class="headerlink" title="rebase &amp; merge 的区别"></a>rebase &amp; merge 的区别</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">merge方式：保留分支历史</span></span><br><span class="line">git switch main</span><br><span class="line">git merge feature/login     # 创建合并提交</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rebase方式：线性历史更整洁</span></span><br><span class="line">git switch feature/login</span><br><span class="line">git rebase main            # 重新应用提交</span><br><span class="line">git switch main</span><br><span class="line">git merge feature/login    # 快进合并</span><br></pre></td></tr></tbody></table></figure>

<h2 id="常用命令速查"><a href="#常用命令速查" class="headerlink" title="常用命令速查"></a>常用命令速查</h2><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>查看分支</td>
<td><code>git branch -a</code></td>
<td>显示所有分支</td>
</tr>
<tr>
<td>切换分支</td>
<td><code>git switch branch-name</code></td>
<td>推荐用法</td>
</tr>
<tr>
<td>创建切换</td>
<td><code>git switch -c new-branch</code></td>
<td>创建并切换到新分支</td>
</tr>
<tr>
<td>删除分支</td>
<td><code>git branch -d branch-name</code></td>
<td>删除已合并分支</td>
</tr>
<tr>
<td>强制删除</td>
<td><code>git branch -D branch-name</code></td>
<td>强制删除分支</td>
</tr>
</tbody></table>
<h3 id="同步操作"><a href="#同步操作" class="headerlink" title="同步操作"></a>同步操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>拉取更新</td>
<td><code>git pull origin main</code></td>
<td>拉取并合并</td>
</tr>
<tr>
<td>获取更新</td>
<td><code>git fetch origin</code></td>
<td>只获取不合并</td>
</tr>
<tr>
<td>推送分支</td>
<td><code>git push -u origin HEAD</code></td>
<td>推送当前分支</td>
</tr>
<tr>
<td>强制推送</td>
<td><code>git push --force-with-lease</code></td>
<td>安全强推</td>
</tr>
</tbody></table>
<h3 id="提交管理"><a href="#提交管理" class="headerlink" title="提交管理"></a>提交管理</h3><table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>查看状态</td>
<td><code>git status</code></td>
<td>检查工作区状态</td>
</tr>
<tr>
<td>暂存文件</td>
<td><code>git add .</code></td>
<td>暂存所有变更</td>
</tr>
<tr>
<td>提交变更</td>
<td><code>git commit -m "message"</code></td>
<td>提交暂存区</td>
</tr>
<tr>
<td>修改提交</td>
<td><code>git commit --amend</code></td>
<td>修改最后一次提交</td>
</tr>
<tr>
<td>撤销提交</td>
<td><code>git reset --soft HEAD~1</code></td>
<td>撤销但保留更改</td>
</tr>
</tbody></table>
<h3 id="历史查看"><a href="#历史查看" class="headerlink" title="历史查看"></a>历史查看</h3><table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>查看历史</td>
<td><code>git log --oneline</code></td>
<td>简洁历史</td>
</tr>
<tr>
<td>图形化历史</td>
<td><code>git log --graph --all</code></td>
<td>分支图</td>
</tr>
<tr>
<td>文件历史</td>
<td><code>git log -p filename</code></td>
<td>文件变更历史</td>
</tr>
<tr>
<td>查看差异</td>
<td><code>git diff HEAD~1</code></td>
<td>与上次提交比较</td>
</tr>
</tbody></table>
<h2 id="关键-git-命令速查表"><a href="#关键-git-命令速查表" class="headerlink" title="关键 git 命令速查表"></a>关键 git 命令速查表</h2><table>
<thead>
<tr>
<th align="center">场景</th>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开始新功能</td>
<td align="center"> git switch develop &amp;&amp; git pull &amp;&amp; git switch -c feature/[name]</td>
<td align="center"> 从 develop 创建新功能分支</td>
</tr>
<tr>
<td align="center">每日同步</td>
<td align="center"> git fetch origin &amp;&amp; git rebase origin/develop</td>
<td align="center"> 保持与 develop 同步</td>
</tr>
<tr>
<td align="center">提交变更</td>
<td align="center"> git add . &amp;&amp; git commit -m “…” &amp;&amp; git push -u origin HEAD</td>
<td align="center"> 推送当前分支</td>
</tr>
<tr>
<td align="center">解决冲突</td>
<td align="center"> git rebase –continue 或 git rebase –abort</td>
<td align="center"> 变基操作控制</td>
</tr>
<tr>
<td align="center">撤销错误提交</td>
<td align="center"> git reset –soft HEAD~1</td>
<td align="center"> 撤销最后一次提交</td>
</tr>
<tr>
<td align="center">查看分支关系</td>
<td align="center"> git log –all –graph –oneline</td>
<td align="center"> 可视化分支历史</td>
</tr>
</tbody></table>
<h2 id="git-提交规范"><a href="#git-提交规范" class="headerlink" title="git 提交规范"></a>git 提交规范</h2><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">feat: 添加新功能</span><br><span class="line">fix: 修复 bug</span><br><span class="line">docs: 文档变更</span><br><span class="line">style: 代码格式/样式调整</span><br><span class="line">refactor: 代码重构</span><br><span class="line">test: 添加或修改测试</span><br><span class="line">chore: 构建过程或辅助工具变更</span><br></pre></td></tr></tbody></table></figure>

<h2 id="常用场景补充"><a href="#常用场景补充" class="headerlink" title="常用场景补充"></a>常用场景补充</h2><h3 id="储藏工作进度"><a href="#储藏工作进度" class="headerlink" title="储藏工作进度"></a>储藏工作进度</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时保存当前工作</span></span><br><span class="line">git stash push -m "work in progress"</span><br><span class="line">git stash list               # 查看储藏列表</span><br><span class="line">git stash pop               # 恢复最新储藏</span><br><span class="line">git stash apply stash@{1}   # 恢复指定储藏</span><br></pre></td></tr></tbody></table></figure>

<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">撤销已暂存的文件</span></span><br><span class="line">git reset HEAD filename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">撤销本地修改</span></span><br><span class="line">git checkout -- filename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件修改者</span></span><br><span class="line">git blame filename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复已删除的文件</span></span><br><span class="line">git checkout HEAD~1 -- deleted-file.js</span><br></pre></td></tr></tbody></table></figure>

<h3 id="历史查看-1"><a href="#历史查看-1" class="headerlink" title="历史查看"></a>历史查看</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看简洁历史</span></span><br><span class="line">git log --oneline</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看分支图</span></span><br><span class="line">git log --all --graph --oneline</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件变更历史</span></span><br><span class="line">git log -p -- filename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索提交信息</span></span><br><span class="line">git log --grep="fix"</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
        <tag>命令笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP 字符串匹配算法</title>
    <url>/2024/06/11/Kmp%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="字符串匹配问题"><a href="#字符串匹配问题" class="headerlink" title="字符串匹配问题"></a>字符串匹配问题</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>首先字符串匹配问题是什么很容易知道，如下图<br><img src="https://telegraph-image-eja.pages.dev/file/f6379e3c35441555f747d.png" alt="image"><br>这在搜索引擎，文本编辑器等都有其身影。</p>
<blockquote>
<p>字符串匹配问题可以正式地表述如下：</p>
</blockquote>
<p>给定文本是一个长度为 &nbsp;𝑛&nbsp; 的数组 &nbsp;𝑇[1 : 𝑛]&nbsp;，模式 (串) 是一个长度为 &nbsp;𝑚(𝑚≤𝑛) 的数组 &nbsp;𝑃[1 : 𝑚]，𝑃&nbsp; 和 &nbsp;𝑇&nbsp; 中的所有元素都是来自一个有限字母集 $\Sigma$ 的字符。例如，$\Sigma$ 可以是 ${0, 1}$，也可以是 ${a, b, … , z}$。字符数组 &nbsp;𝑃&nbsp; 和 &nbsp;𝑇&nbsp; 通常称为字符串。如上图所示，模式 P 伴随着 T 中的偏移量 s 出现 (或者，等价地，模式 P 从文本 T 中的 s + 1 位置开始)。<br>若 $0\le 𝑠\le 𝑛−𝑚$ 且 $𝑇[𝑠+1:𝑠+𝑚]=𝑃[1:𝑚]$，即 $𝑇[𝑠+𝑗]=𝑃[𝑗]$，其中 $1≤𝑗≤𝑚$，那么模式 &nbsp;𝑃&nbsp; 在文本 &nbsp;𝑇&nbsp; 偏移 &nbsp;𝑠&nbsp; 后出现，称 &nbsp;𝑠&nbsp; 是有效偏移，否则 𝑠&nbsp; 就是无效偏移，而字符串匹配问题就是要找出模式 &nbsp;𝑃&nbsp; 出现在给定的文本 &nbsp;𝑇&nbsp; 中所有的有效偏移的问题。<br>为了方便，我们将 $𝑃[1:𝑚]$ 的前 &nbsp;𝑘&nbsp; 个字符组成的前缀 $𝑃[1:𝑘]$ 记作 $𝑃[:𝑘]$，与 python 类似。特别地，有 $𝑃[:0]=𝜀$ 和 $𝑃[:𝑚]=𝑃=𝑃[1:𝑚]$。于是，字符串匹配问题可以表述为找出所有偏移 $0≤𝑠≤𝑛−𝑚$，使得 $𝑃⊐𝑇[:𝑠+𝑚]$。</p>
<h3 id="术语与符号"><a href="#术语与符号" class="headerlink" title="术语与符号"></a>术语与符号</h3><p>在进入正式介绍前，需要引入一些术语和符号，以便形式化表示。</p>
<ul>
<li>$\Sigma ^*$：所有使用 $\Sigma$ 中的字符所构成的有限长度的字符串的集合。</li>
<li>$\varepsilon$：长度为零的字符串，$\varepsilon \in \Sigma ^*$。</li>
<li>|x|：字符串 x 的长度。</li>
<li>xy：字符串 x 和字符串 y 的连结 (concatenation)，反正就是把 y 填补到 x 的后面形成新的字符串。</li>
<li>$w⊏x$：w 是 x 的前缀，对于某个字符串 $𝑦\in \Sigma ^*$，&nbsp; 有 $𝑥=𝑤𝑦$，显然 $|𝑤|\le|𝑥|$，若 $|𝑤|&lt;|𝑥|$，则称 w 是真前缀。</li>
<li>$𝑤⊐𝑥$：w 是 x 的后缀，对于某个字符串 $𝑦\in \Sigma ^*$，&nbsp; 有 $𝑥=yw$，显然 $|𝑤|\le|𝑥|$，若 $|𝑤|&lt;|𝑥|$，则称 w 是真后缀，把 ⊐ 当做&gt; 箭头就行，箭头朝前就是前缀，朝后就是后缀。<br>注：</li>
<li>$\varepsilon$ 是所有字符串的前缀和后缀。</li>
<li>对于任意字符串 &nbsp;𝑥，𝑦&nbsp;，任意字符 &nbsp;𝑎&nbsp;，$𝑥⊐𝑦$ 当且仅当 $𝑥𝑎⊐𝑦𝑎$。</li>
<li>$⊏和⊐$ 关系具有传递性。</li>
</ul>
<h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>Overlapping-suffix lemma<br>假设 &nbsp;𝑥，𝑦&nbsp;，𝑧&nbsp; 是字符串，且满足 $𝑥⊐𝑧和𝑦⊐𝑧$。若 $|𝑥|≤|𝑦|$，则 $𝑥⊐𝑦$。若 $|𝑥|≥|𝑦|$，则 $𝑦⊐𝑥$。若 $|𝑥|=|𝑦|$，则 $𝑥=𝑦$，这在直觉上也很正确，下图示例：<br><img src="https://telegraph-image-eja.pages.dev/file/f583587ea80b1db76708c.png" alt="image"><br>当然也有 Overlapping-prefix lemma 与之对应，不再赘述。</p>
<h2 id="朴素字符串匹配算法-The-naive-string-matching-algorithm"><a href="#朴素字符串匹配算法-The-naive-string-matching-algorithm" class="headerlink" title="朴素字符串匹配算法(The naive string-matching algorithm)"></a>朴素字符串匹配算法 (The naive string-matching algorithm)</h2><p>字符串匹配问题容易想到的就是暴力解法了，如下图：<br><img src="https://telegraph-image-eja.pages.dev/file/473bf783a0d0eaa638e9b.png" alt="image"><br>伪代码如下：<br><img src="https://telegraph-image-eja.pages.dev/file/2f7b3445f88cd844aedba.png" alt="image"><br>cpp 代码示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Naive_String_Matcher</span><span class="params">(string T, string P, <span class="type">int</span> n, <span class="type">int</span> m)</span> </span>{</span><br><span class="line">&nbsp; &nbsp; <span class="type">bool</span> found;</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt; n - m; s++) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="literal">true</span>;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">if</span>(T[s + i] != P[i]) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="literal">false</span>;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">break</span>;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">if</span>(found) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>容易得到时间复杂度为 $\Theta ((n - m + 1) m)$，当然这也远远不是解决这个问题的最优方法，因为它没有利用前面比较过的有用的信息。</p>
<h2 id="Rabin-Karp-算法"><a href="#Rabin-Karp-算法" class="headerlink" title="Rabin-Karp 算法"></a>Rabin-Karp 算法</h2><p>在介绍著名的 kmp 算法前，我们先来了解一下 Rabin-Karp 算法。<br>Rabin 和 Karp 提出了一种字符串匹配算法，它在实践中表现良好，也可以推广到其他相关问题的算法，如二维模式匹配。Rabin-Karp 算法使用 $\Theta (m)$ 预处理时间，其最坏情况下的运行时间为 $\Theta ((n - m + 1) m)$，没错，和朴素算法一样，然而，基于某些假设，它的平均情况运行时间更好。</p>
<p>在一般情况下，我们可以假设每个字符都是一个以基数 d 表示的数字，因此它有 d 个数值在范围为 0 到 d - 1，，其中 $d=|\Sigma|$，然后，我们可以用长度为 &nbsp;𝑘&nbsp; 的 &nbsp;𝑑&nbsp; 进制数来表示由 &nbsp;𝑘&nbsp; 个连续的字符组成的字符串。为了简单说明，让我们假设 $\Sigma={0,1,2,…,9}$，例如，由 5 个连续的字符组成的字符串 31415，可以用长度为 5 的十进制数 31,415 来表示 (为了区分字符串和数字，在这里数字采用逗号作为千位分隔符)。因为我们将输入字符同时解释为图形符号和数字，所以在本节中可以方便地将它们表示为数字。</p>
<p>给定模式 $𝑃[1:𝑚]$，设其对应的十进制数为 &nbsp;𝑝&nbsp;。给定文本 $𝑇[1:𝑛]$，设其子字符串 $𝑇[𝑠+1:𝑠+𝑚]$ 对应的十进制数为 $𝑡_𝑠(s = 0,1,…,n-m)$。当且仅当 $𝑇[𝑠+1:𝑠+𝑚]=𝑃[1:𝑚]$ 时，有 $t_s=p$，此时的 s 为一个有效偏移。</p>
<p>那么 p 怎么求呢？可以先从我们熟知的二进制数入手，就是 $\Sigma={0,1}$ 的情况，那么字符串 100101 对应的二进制数即为 37，相信怎么计算已然熟悉，但我们要设计尽可能快的算法来计算，这里使用霍纳规则 (Horner’s rule)：</p>
<p>$$<br>𝑝=𝑃[𝑚]+𝑑(𝑃[𝑚−1]+𝑑(𝑃[𝑚−2]+⋯+𝑑(𝑃[2]+𝑑𝑃[1])⋯))<br>$$</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">hornerRule</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; coefficients, <span class="type">double</span> x)</span> </span>{</span><br><span class="line">&nbsp; &nbsp; <span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coefficients.<span class="built_in">size</span>(); ++i) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; result = result * x + coefficients[i];</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样就可以在 $\Theta (m)$ 内求出 p，求 $t_0$ 同理，但后面的 $t_s$ 就不再用这种求法了，还是有点慢，因此我们可以找出 $t_{s+1} 和 t_s$ 之间的关系：<br>$t_s=T[𝑚+s]+𝑑(T[𝑚+s−1]+𝑑(T[𝑚+s−2]+⋯+𝑑(T[s+2]+𝑑T[s+1])⋯))$<br>$t_{s+1}=T[𝑚+s+1]+𝑑(T[𝑚+s]+𝑑(T[𝑚+s−1]+⋯+𝑑(T[s+3]+𝑑T[s+2])⋯))$<br>观察相同的式子并进行进一步配凑：<br>$dt_s=d(T[𝑚+s]+𝑑(T[𝑚+s−1]+𝑑(T[𝑚+s−2]+⋯+𝑑(T[s+2]+𝑑T[s+1])⋯))$<br>$dt_s-d^mT[s+1]=d(T[𝑚+s]+𝑑(T[𝑚+s−1]+𝑑(T[𝑚+s−2]+⋯+𝑑(T[s+2])⋯))$<br>因此有：<br>$t_{s+1}=T[m+s+1]+d(t_s-d^{m-1}T[s+1])$</p>
<p>容易得到 $d^{m-1}$ 是一个常数，因此我们可以预先计算它，如果用简单循环的话时间为 $O (m)$，而用<a href="https://oi-wiki.org/math/binary-exponentiation/">快速幂算法</a>的时间是 $O (logm)$。这样一来，执行一次 $t_{s+1} 和 t_s$ 的等式只需要 $\Theta (1)$ 时间。因此，我们可以在求出 $t_0$ 后在 $\Theta (n-m)$ 时间内依次求出 $t_1,…,t_{n-m}$。所以，我们可以在 $\Theta (m)$ 的预处理时间和 $\Theta (n-m+1)$ 的匹配时间内找出模式 $𝑃[1:𝑚]$ 在文本 $𝑇[1:𝑛]$ 中的所有出现的位置。</p>
<p>当 &nbsp;𝑃&nbsp; 足够短且 $\Sigma$ 足够小时，对 p 和 $t_s$ 的算术运算只需要常数时间，这个方案效果很好。但如果 &nbsp;𝑃&nbsp; 很长，或者 $\Sigma$ 很大导致转化为数字的基数 d 很大，那么就无法在常数时间内计算出 &nbsp;𝑝&nbsp; 或 $𝑡_𝑠$。幸运的是，这个问题可以解决。<br><img src="https://telegraph-image-eja.pages.dev/file/aa3fb3c206ce349a6dfb2.png" alt="image"><br>如图，可以通过选取合适的模 q 来解决，使得 &nbsp;𝑑𝑞&nbsp; 在一个计算字长内，满足进行单精度计算的条件。通常，我们会选择一个形式简单的素数，比如形如 $2^k−1$(费马素数) 或者 $2^k +1$(梅森素数) 的数，因为这样的数在二进制计算机中可以通过位移操作和加法快速进行模运算。</p>
<p>所以等式相应地变为：<br>$t_{s+1}=(T [m+s+1]+d (t_s-T [s+1] h))$ mod q，其中 $h=d^{m-1}$ mod q<br>为了好看 c 图，改一下位置：<br>$t_{s+1}=((t_s-T[s+1]h)d+T[m+s+1])$ mod q</p>
<p>但是模 &nbsp;𝑞&nbsp; 后的结果并不完美，因为 $𝑡_𝑠=𝑝$ (mod 𝑞) 并不意味着 $𝑡_𝑠=𝑝$，它只是必要条件，因此，若 $𝑡_𝑠≠𝑝$ (mod 𝑞)，则 $𝑡_𝑠≠𝑝$ 肯定成立。因此可以把测试 $𝑡_𝑠=𝑝$ (mod 𝑞) 是否成立作为一种快速的方法来排除无效偏移 &nbsp;𝑠&nbsp;。当 $𝑡_𝑠=𝑝$ (mod 𝑞) 成立时，称为一个命中 (hit)，然后我们还需要进一步测试此时 $𝑡_𝑠=𝑝$ 是否成立，即检查 $𝑃[1:𝑚]=𝑇[𝑠+1:𝑠+𝑚]$ 是否成立。若 $𝑡_𝑠=𝑝$，则 &nbsp;𝑠&nbsp; 是一个有效偏移，若 $𝑡_𝑠≠𝑝$，则是一个假命中 (spurious hit)。若 &nbsp;𝑞&nbsp; 足够大，则出现假命中的期望次数会更少，从而降低额外检查的代价。</p>
<p>下面给出伪代码：<br><img src="https://telegraph-image-eja.pages.dev/file/00850934615eb00424f2a.png" alt="image"><br>t 的下标仅仅是为了逻辑清晰，去掉下标也能正确运行。<br>最坏情况下的匹配时间是 $\Theta ((n-m+1) m)$，因为如果 $P=a^m,T=a^n$，这样每个偏移都是有效的，就都得检查一遍。<br>所以为什么说该算法在实践中表现良好呢？<br>在许多应用中，我们希望少一些有效偏移，比如只有常数 &nbsp;𝑐&nbsp; 个。在这样的应用中，加上处理假命中所需时间，该算法的期望匹配时间为 $𝑂((𝑛−𝑚+1)+𝑐𝑚)=𝑂(𝑛+𝑚)$，又因为 $m\le n$，则期望匹配时间为 $O (n)$。</p>
<h2 id="用有限自动机进行字符串匹配-String-matching-with-finite-automata"><a href="#用有限自动机进行字符串匹配-String-matching-with-finite-automata" class="headerlink" title="用有限自动机进行字符串匹配(String matching with finite automata)"></a>用有限自动机进行字符串匹配 (String matching with finite automata)</h2><h3 id="有限自动机-Finite-automata"><a href="#有限自动机-Finite-automata" class="headerlink" title="有限自动机(Finite automata)"></a>有限自动机 (Finite automata)</h3><p>一个有限自动机 &nbsp;𝑀&nbsp; 是一个 5 元组 $(𝑄,𝑞_0,𝐴,\Sigma,\delta)$：</p>
<ul>
<li>Q 是一个有限状态集。</li>
<li>$𝑞_0\in 𝑄$ 是起始状态。</li>
<li>$𝐴⊆𝑄$ 是一个接受状态集。</li>
<li>$\Sigma$ 是一个有限输入字母表。</li>
<li>$\delta$ 是一个从 $𝑄\times \Sigma$ 到 &nbsp;𝑄&nbsp; 的函数，称为 &nbsp;𝑀&nbsp; 的转移函数。<br><img src="https://telegraph-image-eja.pages.dev/file/a6d4558c65809f64f66c7.png" alt="image"><br>说实话我第一眼看到这图就想到了数字逻辑电路里面的状态转化表和状态转化图</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
        <tag>模式匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimum Spanning Trees</title>
    <url>/2024/04/25/Minimum%20Spanning%20Trees/</url>
    <content><![CDATA[<h1 id="Minimum-Spanning-Trees"><a href="#Minimum-Spanning-Trees" class="headerlink" title="Minimum Spanning Trees"></a>Minimum Spanning Trees</h1><p>对于无向图 $𝐺=(𝑉,𝐸)$，存在一个能够连接所有顶点的无环子集 $𝑇⊆𝐸$，由于 &nbsp;𝑇&nbsp; 无环且连接所有顶点，因此 &nbsp;𝑇&nbsp; 一定为一棵树 (树是特殊的图，为无环连通图)，被称为生成树 (spanning tree)。无向图 $𝐺=(𝑉,𝐸)$ 的所有生成树都恰有 $|𝑉|−1$ 条边。</p>
<p>设边 $(𝑢,𝑣)∈𝐸$ 的权重为 $𝑤(𝑢,𝑣)$，生成树权重为 $𝑤(𝑇) = \sum_{(𝑢,𝑣)∈𝑇} 𝑤(𝑢,𝑣)$，所有生成树中权重最小的生成树被称为最小权重生成树 (minimum-weight spanning tree)，简称最小生成树 (minimum spanning tree)。</p>
<h2 id="Growing-a-minimum-spanning-tree"><a href="#Growing-a-minimum-spanning-tree" class="headerlink" title="Growing a minimum spanning tree"></a>Growing a minimum spanning tree</h2><p>最小生成树问题的输入为一个无向连通图 &nbsp;$𝐺=(𝑉,𝐸)$, 伪代码如下：</p>
<blockquote>
<p>$GENERIC-MST(G, w)$<br>1 $A = \not 0$<br>2 while A does not form a spanning tree<br>3 find an edge (u, v) that is safe for A<br>4 $A = A \cup {(u, v)}$<br>5 return A</p>
</blockquote>
<p>能够被加入 &nbsp;𝐴&nbsp; 的边 &nbsp;(𝑢,𝑣)&nbsp; 被称为 &nbsp;𝐴&nbsp; 的安全边 (safe edge)。通过 &nbsp;𝐴&nbsp; 维持了循环不变量可证明过程 &nbsp;GENERIC-MST&nbsp; 的正确性。在讨论如何识别安全边之前，我们需要了解一些定义。<br><img src="https://telegraph-image-eja.pages.dev/file/d85f5a52655f0d41a977d.png" alt="image"></p>
<ul>
<li>$cut$：无向图 $𝐺=(𝑉,𝐸)$ 的一个切割 (cut)&nbsp;$(𝑆,𝑉−𝑆)$ 是对顶点 𝑉 的一个划分，分成两个区域</li>
<li> $cross$：若边 $(𝑢,𝑣)∈𝐸$ 的一个端点属于 &nbsp;𝑆&nbsp;，另一个端点属于 𝑉−𝑆&nbsp;，则称边 (𝑢,𝑣)&nbsp; 横跨 (cross) cut (𝑆,𝑉−𝑆)，看图的话就是跟红色分割线相交的边都是 cross 的边</li>
<li> $respect$：若集合 &nbsp;𝐴&nbsp; 中不存在横跨切割 &nbsp;(𝑆,𝑉−𝑆)&nbsp; 的边，则称该切割不影响 (respect)&nbsp;𝐴</li>
<li>$light\ edge$：权重最小的 cross 边即是轻量边 (light edge)<br>原文如下：<br><img src="https://telegraph-image-eja.pages.dev/file/1833dbc2edcac6e9a8fb9.png" alt="image"><br>当然最好还得知道树的性质：添加一条边就会构成环，删除一条边就会分裂成两棵树。</li>
</ul>
<h3 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h3><blockquote>
<p>设 &nbsp;𝐺=(𝑉, 𝐸)&nbsp; 为一个无向连通图，其权重函数为 &nbsp;𝑤: $𝐸\to𝑅$&nbsp;，设 &nbsp;𝐴⊆𝐸&nbsp;，且 &nbsp;𝐴&nbsp; 包含于 &nbsp;𝐺&nbsp; 的一棵最小生成树中。设 &nbsp;(𝑆, 𝑉−𝑆)&nbsp; 为 &nbsp;𝐺&nbsp; 中不影响 &nbsp;𝐴&nbsp; 的任意一个切割，若 &nbsp;(𝑢, 𝑣)&nbsp; 为横跨 &nbsp;(𝑆, 𝑉−𝑆)&nbsp; 的一条轻量边，则对于 &nbsp;𝐴&nbsp;，(𝑢, 𝑣)&nbsp; 是安全的。</p>
</blockquote>
<p><img src="https://telegraph-image-eja.pages.dev/file/bd123ede0b571e7df22aa.png" alt="image"></p>
<p>// 图中橙色顶点属于 S，其它顶点属于 V-S，蓝色边就是 A 中的边</p>
<p>证明如下：</p>
<ul>
<li>首先假设 T 是包含 A 的最小生成树，并假设 T 不包含轻量边 (u, v)，因为如果包含了，我们就不用证了。接着我们可以通过构造另一棵最小生成树 T’，其中 $A \cup {(u, v)} ⊆ T’$, 从而表明，边 &nbsp;(𝑢, 𝑣)&nbsp; 对于 &nbsp;𝐴&nbsp; 是安全的。</li>
<li>由图可知边 (u, v) 与 $u \to v$ 的简单路径构成环路。因为 u, v 在 cut (𝑆, 𝑉−𝑆) 下分属两边，因此 &nbsp;𝑇&nbsp; 中至少有一条边属于简单路径 &nbsp;𝑝&nbsp; 并且横跨该切割，设 &nbsp;(𝑥, 𝑦)&nbsp; 为这样一条边。因为切割 &nbsp;(𝑆, 𝑉−𝑆)&nbsp; 不影响 𝐴&nbsp;，所以 &nbsp;(𝑥, 𝑦) ∉ 𝐴。又因为边 &nbsp;(𝑥, 𝑦)&nbsp; 位于 &nbsp;𝑇&nbsp; 中从 &nbsp;𝑢&nbsp; 到 &nbsp;𝑣&nbsp; 的唯一的简单路径上，所以移除 &nbsp;(𝑥, 𝑦)&nbsp; 会导致 &nbsp;𝑇&nbsp; 分裂成两部分。此时添加 &nbsp;(𝑢, 𝑣)&nbsp; 将这两部分重新连接成一棵新的生成树 ：𝑇′=(𝑇−{(𝑥,𝑦)})∪{(𝑢,𝑣)}&nbsp;。</li>
<li>我们接下来要证明 T’是最小生成树。由于 &nbsp;(𝑢, 𝑣)&nbsp; 为横跨 &nbsp;(𝑆, 𝑉−𝑆)&nbsp; 的一条轻量边且 &nbsp;(𝑥, 𝑦)&nbsp; 为横跨 &nbsp;(𝑆, 𝑉−𝑆)&nbsp; 的一条边，即 &nbsp;𝑤(𝑢, 𝑣)≤𝑤(𝑥, 𝑦)&nbsp;，因此：<br>$w(T’) = w(T) - w(x, y) + w(u, v)$<br>$\leq w(T)$<br>但是 &nbsp;𝑇&nbsp; 为一棵最小生成树，有 &nbsp;𝑤(𝑇)≤𝑤(𝑇′)&nbsp;。因此，有 &nbsp;𝑤(𝑇) = 𝑤(𝑇′)&nbsp;，所以 &nbsp;𝑇′&nbsp; 也是一棵最小生成树。</li>
<li>最后，我们还需要说明边 &nbsp;(𝑢, 𝑣)&nbsp; 对于 &nbsp;𝐴&nbsp; 是安全的。因为 &nbsp;𝐴⊆𝑇&nbsp; 且 &nbsp;(𝑥, 𝑦)∉𝐴&nbsp;，所以 &nbsp;𝐴⊆𝑇′&nbsp;，所以 &nbsp;(𝐴∪{(𝑢,𝑣)})⊆𝑇′&nbsp;。由于 &nbsp;𝑇′&nbsp; 是一棵最小生成树，因此对于 &nbsp;𝐴&nbsp;，(𝑢, 𝑣)&nbsp; 是安全的。</li>
</ul>
<p>感觉有点难咀嚼的话可以看看下面的另一种证明 (算法 4)：<br><img src="https://telegraph-image-eja.pages.dev/file/ef60c9e50f8c87db41f0d.png" alt="image"></p>
<blockquote>
<p>在算法执行的任何时候，图 $G_A = (V, A)$ 是一个森林，$G_A$ 中每一个连通分量都是一棵树 (一些树可能只包含一个顶点，例如在算法开始时，A 是空的，因为还没开始加入安全边，并且此时森林包含了 | V | 棵树，每棵树都只有一个顶点)。此外，因为 $A \cup {(u, v)}$ 必须是无环的，因此每一条安全边 (u, v) 都连接着 $G_A$ 中的不同分量。</p>
</blockquote>
<h3 id="Corollary"><a href="#Corollary" class="headerlink" title="Corollary"></a>Corollary</h3><p>设 &nbsp;𝐺=(𝑉, 𝐸)&nbsp; 为一个无向连通图，其权重函数为 $𝑤:𝐸\to𝑅$，设 &nbsp;𝐴⊆𝐸&nbsp;，且 &nbsp;𝐴&nbsp; 包含于 &nbsp;𝐺&nbsp; 的一棵最小生成树中。设 $𝐶=(𝑉_𝐶, 𝐸_𝐶)$ 为森林 $𝐺_𝐴=(𝑉,𝐴)$ 中的一个连通分量（一棵树）。若 &nbsp;(𝑢,𝑣)&nbsp; 是连接 &nbsp;𝐶&nbsp; 和 $𝐺_𝐴$ 中某一个其它的连通分量的一条轻量边，则对于 &nbsp;𝐴&nbsp;，(𝑢, 𝑣)&nbsp; 是安全边。</p>
<blockquote>
<p>Proof：<br>切割 $(V_C,V-V_C)$ 不影响 A，又因为 (u, v) 是该切割的轻量边，因此，对于 A，(u, v) 是安全的。</p>
</blockquote>
<h2 id="The-algorithms-of-Kruskal-and-Prim"><a href="#The-algorithms-of-Kruskal-and-Prim" class="headerlink" title="The algorithms of Kruskal and Prim"></a>The algorithms of Kruskal and Prim</h2><p>这里描述的两种最小生成树算法详细介绍了上面的通用方法。它们各自使用一个特殊的规则来确定 $GENERIC-MST (G, w)$ 的第 3 行中的 find an edge (u, v) that is safe for A。在 Kruskal 算法中，集合 A 是一个森林，其顶点都是给定图的顶点。添加到 A 中的安全边总是图中连接两个不同分量的最低权重边。在 Prim 算法中，集合 A 形成了一棵树，算法执行过程中始终为一棵树。添加到 A 中的安全边始终是连接树和树中以外的顶点的最低权重边。下面的介绍中，两种算法都假设输入图是连通的，并由邻接列表表示。</p>
<h3 id="Kruskal’s-algorithm"><a href="#Kruskal’s-algorithm" class="headerlink" title="Kruskal’s algorithm"></a>Kruskal’s algorithm</h3><p><img src="https://telegraph-image-eja.pages.dev/file/a9d9c05f942462df59992.png" alt="image"><br><img src="https://telegraph-image-eja.pages.dev/file/f2dcf3043bd0577717a43.png" alt="image"></p>
<blockquote>
<p>大家可以先通过上图感受一下该算法，蓝色边属于森林 A，透过上图我们还可以观察到被添加到 A 中的安全边的权重是从小到大的，所以容易发现 Kruskal 算法是贪心算法，每次都加入权重最小的安全边，以此来保证总权重最小。该算法以按权重排序的顺序来考虑每条边，因此正在考虑的那条边已经是当前未加入生成树的边中的轻量边，只需再判断是否产生环而决定是否将它加入 A，红色的箭头则指向在算法的每一步中所考虑的边。如果边 (u, v) 连接森林中两棵不同的树 (注意单一的顶点也是树），则将其添加到森林中，从而合并两棵树。</p>
</blockquote>
<ul>
<li>设 $C_1$ 和 $C_2$ 表示由 (u, v) 连接的两棵树。因为 (u, v) 必须是连接 $C_1$ 和其他树的轻量边，根据推论 (Corollary)，&nbsp;(𝑢, 𝑣)&nbsp; 是 $𝐶_1$ 的一条安全边。<br>伪代码如下：<blockquote>
<p>// 时间复杂度：𝑂(𝐸 lg⁡ 𝑉)<br>$MST-KRUSKAL(G, w)$<br>1 A = $\not 0$ // 初始化空集合<br>2 for each vertex $v \in G.V$<br>3 MAKE-SET (v) // 使用并查集 (disjoint-set) 的数据结构来维护几个不相交的元素集， 每个集合都包含当前林的一棵树中的顶点，初始化即一个顶点一棵树<br>4 create a single list of the edges in G.E<br>5 sort the list of edges into monotonically increasing order by weight w<br>6 for each edge (u, v) taken from the sorted list in order<br>7 if FIND-SET (u) $\not =$ FIND-SET (v) // 确定两个顶点是否属于同一棵树，同一棵树就会 成环<br>8 $A = A \cup {(u, v)}$ // 把边 (u, v) 加入到 A<br>9 UNION (u, v) // 合并树<br>10 return A</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>上面说到了并查集数据结构，下面简要说一下，已掌握可跳过。</p>
</blockquote>
<h4 id="Disjoint-set"><a href="#Disjoint-set" class="headerlink" title="Disjoint-set"></a>Disjoint-set</h4><p>首先并查集用数组来实现，数组的值代表其父节点的位置，在上面代码中的初始化中，一个顶点就是一棵树，因此没有父节点，可以把所有顶点的数组值标为 - 1。<br>并查集支持两个操作：</p>
<ul>
<li>查找 (Find)：确定某个元素属于哪个子集，它可以用来确定两个元素是否属于同一个子集。</li>
<li>合并 (Union)：将两个子集合并成一个集合<br>上面代码中的 FIND-SET 即是查找操作，对某个顶点 i 查找，即循环查找当前位置 i 的父节点，直到 arr [i] = -1 为止，返回 i，如果两个顶点的 FIND-SET 返回结果一样，即两个顶点属于同一棵树。<br>合并操作即是先分别找到 u，v 的根节点，然后将其中一个根节点的父节点设为另一个顶点。这是最基础的并查集实现，要提高效率的话就要进行路径压缩和按秩合并。</li>
<li>路径压缩：在 Find 过程中在返回之前，路径中的顶点的父节点直接设为根节点，毕竟 Find 返回的就是根节点，这有利于下一次查询的效率。</li>
<li>按秩合并：上面所说的合并操作是将其中一个根节点的父节点设为另一个顶点，这未免有点随便。比如现在有一棵简单的树，一棵复杂的树，那么是将简单的往复杂的合并好还是复杂的往简单的合并好？答案是前者，如果把复杂的往简单的合并，那么原来在复杂树中的每个元素到根节点的距离都变长了，影响后面 Find 的效率；而如果把简单的往复杂的合并，到根节点距离变长的节点个数比较少。所以就引入秩，初始时每个顶点的秩设为 1，那么什么时候秩会增加呢？这发生在合并时，如果两棵树深度相同，则新的根节点的秩 + 1。秩越高，树 (或子树) 就越复杂。</li>
</ul>
<h3 id="Prim’s-algorithm"><a href="#Prim’s-algorithm" class="headerlink" title="Prim’s algorithm"></a>Prim’s algorithm</h3><p>跟上面一样，我们可以先通过过程图感受一下：<br><img src="https://telegraph-image-eja.pages.dev/file/0149f1a64ebab26f61bdd.png" alt="image"><br>// 从上图可以明显感受到与 Kruskal 算法不一样的是，蓝色边之间都是连通的，这里就揭露了 Prim 算法具有的一个性质是 &nbsp;𝐴&nbsp; 中的边总是构成一棵树，我们还可以发现添加边的权重是没有像 Kruskal 算法一样按权重排序的。</p>
<p>如图所示，这棵树以任意一个顶点 &nbsp;𝑟&nbsp; 为根节点，不断生长直到包含 &nbsp;𝑉&nbsp; 中所有顶点。每次加入到 &nbsp;𝐴&nbsp; 中的安全边永远是 (𝐴, 𝑉−𝐴) 切割的轻量边。根据 Corollary，每次加入 &nbsp;𝐴&nbsp; 的边一定是安全边。该算法也满足贪心性质，因为在每一步它向树添加的一条边，都为树的权重贡献可能的最小量。</p>
<p>伪代码如下：</p>
<blockquote>
<p>$MST-PRIM(G, w, r)$<br>1 for each vertex $u \in G.V$<br>2 $u.key = \infty$ //&nbsp;u.𝑘𝑒𝑦 保存连接 u 和树中任一其它节点的所有边中最小的边的权 重，若不存在这样的边，即设为 $\infty$，初始化时都设为 $\infty$。<br>3 $u.\pi = NIL$ //u.𝜋&nbsp; 保存 u 在树中的父节点<br>4 $r.key = 0$ // 把根节点 r 的 key 设为 0，方便第 9 行第一个处理 r<br>5 $Q = \not 0$ // 创建基于 &nbsp;𝑘𝑒𝑦&nbsp; 属性的优先队列<br>6 for each vertex $u \in G.V$<br>7 INSERT (Q, u)<br>8 while $Q \not = \not 0$ // 只要队列非空<br>9 u = EXTRACT-MIN (Q) // 把 u 加到树 (A) 中<br>10 for each vertex v in $G.Adj [u]$ // 更新 u 的非树邻居的 key<br>11 if $v \in Q$ and w(u, v) &lt; v.key<br>12 $v.\pi = u$<br>13 v.key = w(u, v)<br>14 DECREASE-KEY (Q, v, w (u, v)) // 调整 Q 中 v 的 key 值</p>
</blockquote>
<p>该算法保持以下三个循环不变量：</p>
<ul>
<li>$𝐴={(𝑣, 𝑣.𝜋): 𝑣∈𝑉−{𝑟}−𝑄}$，(算法终止时，&nbsp;𝑄=∅，因此 G 的最小生成树 $𝐴={(𝑣, 𝑣.𝜋): 𝑣∈𝑉−{𝑟}}$。)</li>
<li> 已经放在最小生成树中的顶点都是 V - Q 中的顶点。</li>
<li>对于图中所有的顶点 v∈Q，如果 $v.\pi$ 不等于 NIL，那么 v.key 小于正无穷大，v.key 是连接 v 到已经放置在最小生成树中的某个顶点的轻量边 $(v,v.\pi)$ 的权重。</li>
</ul>
<p>Prim 算法的运行时间取决于最小优先级队列 Q 的实现：</p>
<ul>
<li>二叉堆：时间复杂度：$𝑂(𝐸lg⁡𝑉)$</li>
<li> 斐波那契堆：时间复杂度：$O (E+V lg V)$</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>算法</tag>
        <tag>最小生成树</tag>
        <tag>Kruskal</tag>
        <tag>Prim</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 入坑篇</title>
    <url>/2024/09/25/Rust%20%E5%85%A5%E5%9D%91%E7%AF%87/</url>
    <content><![CDATA[<h1 id="Rust-入坑篇"><a href="#Rust-入坑篇" class="headerlink" title="Rust 入坑篇"></a>Rust 入坑篇</h1><p>本文直接参考该博客文章:<a href="https://blog.jetbrains.com/rust/2024/09/20/how-to-learn-rust/">how-to-learn-rust</a></p>
<h2 id="Understanding-Rust’s-core-concepts"><a href="#Understanding-Rust’s-core-concepts" class="headerlink" title="Understanding Rust’s core concepts"></a>Understanding Rust’s core concepts</h2><p>初步印象：既不是面向对象语言也不是函数式编程语言，没有类。</p>
<h3 id="Memory-management"><a href="#Memory-management" class="headerlink" title="Memory management"></a>Memory management</h3><p>原则：<strong>Rust 编译器必须知道代码中内存分配的准确位置、访问内存的位置和方式以及不再需要内存的位置</strong><br>因此相较于自动回收垃圾的编程语言来说，Rust 节省了在运行时执行相应回收算法的时间，也因此一举两得，内存安全和性能兼得。</p>
<h4 id="Some-limits-or-strict-rules"><a href="#Some-limits-or-strict-rules" class="headerlink" title="Some limits or strict rules"></a>Some limits or strict rules</h4><ul>
<li>每个内存片段必须由单个变量拥有 ——Rust 的<strong>所有权模型 (ownership model)</strong> 基于此。</li>
<li>改变内存片段需要独占访问（而不是仅仅读取内存）。</li>
<li>Rust 允许创建对内存片段的可变和不可变引用（借用它们），但使用借用检查器来强制正确性（例如，禁止多个可变引用）。</li>
<li>Rust 编译器会计算并检查程序中每个变量的生命周期，从变量创建的地方到变量被删除的地方（变量不再可访问的地方）。</li>
</ul>
<p>这里提到了一个所有权模型，感觉可以初步了解下：</p>
<h5 id="所有权模型的三个核心规则"><a href="#所有权模型的三个核心规则" class="headerlink" title="所有权模型的三个核心规则"></a>所有权模型的三个核心规则</h5><p>Rust 的所有权系统主要围绕以下三个规则：</p>
<ol>
<li><strong>每个值都有一个所有者（Owner）</strong><br>每个变量或数据都有一个所有者，数据的所有权只能归属于一个变量。</li>
<li><strong>每个值同时只能有一个所有者</strong><br>在任意时刻，某个值最多只能有一个所有者。当所有者离开作用域时，该值会被自动释放。</li>
<li><strong>当所有者超出作用域，值会被自动释放</strong><br>当所有者变量离开它所在的作用域时，Rust 会自动调用 <code>drop</code> 函数释放该变量所占用的内存。这种机制确保了内存安全，同时避免了内存泄漏。</li>
</ol>
<h5 id="所有权转移（Move）"><a href="#所有权转移（Move）" class="headerlink" title="所有权转移（Move）"></a>所有权转移（Move）</h5><p>在 Rust 中，当我们将一个变量赋值给另一个变量时，所有权会发生转移。这个过程称为 <strong>Move</strong>。被转移的变量在转移之后将不再有效，例子如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">let s1 = String::from("hello");</span><br><span class="line">let s2 = s1;  // 所有权转移，s1 不再有效</span><br><span class="line">// println!("{}", s1); // 编译错误，因为s1已经被转移</span><br></pre></td></tr></tbody></table></figure>

<p>好奇心驱使下，搜了下相关语法：</p>
<ul>
<li><code>&amp;str</code>（字符串切片），通常是静态的不可变引用。</li>
<li><code>String</code>，是动态分配的可变字符串。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);  <span class="comment">// 使用 String::from</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">"hello"</span>.<span class="title function_ invoke__">to_string</span>();    <span class="comment">// 另一种创建 String 的方式</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后 <code>!</code> 表示宏调用，这里涉及有点多不展开。</p>
<h5 id="借用（Borrowing）与引用（Reference）"><a href="#借用（Borrowing）与引用（Reference）" class="headerlink" title="借用（Borrowing）与引用（Reference）"></a>借用（Borrowing）与引用（Reference）</h5><p>为了在不转移所有权的情况下访问数据，Rust 引入了 <strong>借用</strong>（通过引用）。借用分为两种类型：<strong>不可变引用</strong> 和 <strong>可变引用</strong>。</p>
<h6 id="不可变引用（-）"><a href="#不可变引用（-）" class="headerlink" title="不可变引用（&amp;）"></a>不可变引用（&amp;）</h6><p>多个不可变引用可以同时存在，但不能与可变引用共存。</p>
<figure class="highlight rust"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s;  <span class="comment">// 不可变引用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s;  <span class="comment">// 允许多个不可变引用</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{} and {}"</span>, r1, r2);  <span class="comment">// 正常工作</span></span><br></pre></td></tr></tbody></table></figure>

<h6 id="可变引用（-mut）"><a href="#可变引用（-mut）" class="headerlink" title="可变引用（&amp;mut）"></a>可变引用（&amp;mut）</h6><p>在某一时刻，只能有一个可变引用，并且不可与不可变引用同时存在。这是为了避免数据竞争。</p>
<figure class="highlight rust"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;  <span class="comment">// 可变引用</span></span><br><span class="line"><span class="comment">// let r2 = &amp;s;  // 编译错误：不可变引用与可变引用不能共存</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="悬挂引用（Dangling-References）与借用检查"><a href="#悬挂引用（Dangling-References）与借用检查" class="headerlink" title="悬挂引用（Dangling References）与借用检查"></a>悬挂引用（Dangling References）与借用检查</h5><p>Rust 编译器通过借用检查（Borrow Checker）来确保引用的生命周期不会超出它们所借用的数据的作用域。Rust 会在编译时防止悬挂引用，即避免在数据被释放后，仍然有对它的引用。</p>
<h5 id="生命周期（Lifetimes）"><a href="#生命周期（Lifetimes）" class="headerlink" title="生命周期（Lifetimes）"></a>生命周期（Lifetimes）</h5><p>Rust 通过 <strong>生命周期</strong> 机制来跟踪引用的有效性。生命周期标注是编译器用于确保所有引用在有效的范围内使用的辅助工具。虽然很多情况下 Rust 可以自动推断生命周期，但在某些复杂情况下需要手动标注。</p>
<figure class="highlight rust"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="type">str</span>, y: &amp;<span class="symbol">'a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">'a</span> <span class="type">str</span> {</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() {</span><br><span class="line">        x <span class="comment">// Rust 使用表达式式编程，也就是说，函数的最后一个表达式的结果会自动作为返回值，如果这个表达式没有被分号结尾。</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        y</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>-&gt; &amp;'a str</code> 表示返回类型，<code>'a</code> 是一个占位符，为生命周期参数，表示输入参数和返回值的生命周期，表明以下的引用都至少活得跟<code>'a</code> 一样久。（a 可以替换成任意自定义名称，单引号则必须有）</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Rust 的所有权模型提供了一种安全的内存管理方式，避免了内存泄漏和数据竞争等问题。所有权、借用和生命周期相结合，使得程序在编译时能够保证内存安全，并且无需运行时的垃圾回收机制。这也是 Rust 被认为是 “零成本抽象” 的原因之一。</p>
<p>这是博客里的示例代码：</p>
<figure class="highlight rust"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Here we take a vector by reference (&amp;).</span></span><br><span class="line"><span class="comment">// We are not allowed to mutate elements.</span></span><br><span class="line"><span class="comment">// We don't take ownership; we just borrow.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_vec</span>(numbers: &amp;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) {</span><br><span class="line">   <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> numbers {</span><br><span class="line">       <span class="built_in">print!</span>(<span class="string">"{} "</span>, number);</span><br><span class="line">   }</span><br><span class="line">   <span class="built_in">println!</span>()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here we take a vector by mutable reference (&amp;mut).</span></span><br><span class="line"><span class="comment">// We are now allowed to mutate elements and the vector itself.</span></span><br><span class="line"><span class="comment">// We still don't take ownership; we just borrow.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>(numbers: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) {</span><br><span class="line">   numbers.<span class="title function_ invoke__">push</span>(<span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">   <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">   <span class="comment">// We pass a reference</span></span><br><span class="line">   <span class="title function_ invoke__">print_vec</span>(&amp;numbers);</span><br><span class="line">   <span class="comment">// We pass a mutable reference</span></span><br><span class="line">   <span class="title function_ invoke__">add_one</span>(&amp;<span class="keyword">mut</span> numbers);</span><br><span class="line">   <span class="comment">// We pass a reference again</span></span><br><span class="line">   <span class="title function_ invoke__">print_vec</span>(&amp;numbers);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意 <code>We don't take ownership; we just borrow.</code> 这句话上面出现了两次</p>
<figure class="highlight rust"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one_incorrect</span>(<span class="keyword">mut</span> numbers: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) {</span><br><span class="line">	numbers.<span class="title function_ invoke__">push</span>(<span class="number">1</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个例子就是 <code>take ownership</code> 的了。</p>
<p>当你将 <code>main</code> 函数中的 <code>numbers</code> 传递给 <code>add_one_incorrect</code> 时，<code>numbers</code> 的<strong>所有权</strong>会从 <code>main</code> 转移到 <code>add_one_incorrect</code> 的参数 <code>numbers</code> 上。函数中的 <code>numbers</code> 和 <code>main</code> 中的 <code>numbers</code> 只是同名变量，但它们是不同的实例。函数内部的 <code>mut</code> 使得你可以修改 <code>add_one_incorrect</code> 内部的 <code>numbers</code>，但这并不会影响 <code>main</code> 中的 <code>numbers</code>，因为 <code>main</code> 的 <code>numbers</code> 已经失去了所有权。函数结束后，<code>add_one_incorrect</code> 内的 <code>numbers</code> 会被释放，且 <code>main</code> 中的 <code>numbers</code> 已经不再有效，不能再使用，会出现 <code>borrow of moved value</code> 之类的报错信息。</p>
<h3 id="并发（Concurrency）"><a href="#并发（Concurrency）" class="headerlink" title="并发（Concurrency）"></a>并发（Concurrency）</h3><p>Rustaceans 经常将 Rust 的并发性描述为无所畏惧。有几个因素促成了这种看法：</p>
<ul>
<li>所有权模型增加了对并发线程之间共享数据的更多控制。</li>
<li>采用不可变的数据结构（具有天然的线程安全性，不会出现数据竞争），简化了并发算法的实现并有助于线程安全。</li>
<li>Rust 采用通过通道传递消息（通道是一种避免共享状态的方式，通过在不同线程之间传递消息来代替共享数据），因此大大降低了共享状态并发的复杂性。</li>
<li>Rust 的生命周期和内存管理方法通常使使用并发原语（例如锁、信号量或障碍 &nbsp;-&gt; locks, semaphores, or barriers）的代码更加优雅和安全。</li>
<li>在很多情况下，Rust 的异步编程方法可以避免使用复杂的并发模式，并使您能够编写简洁清晰的代码。(<strong>异步编程</strong>是一种编程范式，它允许程序在执行耗时任务（如 I/O 操作、网络请求、文件读取等）时不阻塞整个程序的运行。简单来说，异步编程使程序可以在等待某些任务完成的同时，继续处理其他任务，从而提高效率和响应性。)<br>以上是原文直译与补充，仅作对并发的粗略了解。</li>
</ul>
<h2 id="How-to-install"><a href="#How-to-install" class="headerlink" title="How to install"></a>How to install</h2><p><a href="https://course.rs/first-try/installation.html">install rust</a><br><a href="https://code.visualstudio.com/docs/languages/rust">rust in vscode</a></p>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p>我感觉原文给的资源都挺好的，就不贴出来了，读者可自行查看。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>Rust</tag>
        <tag>编程语言</tag>
        <tag>所有权</tag>
      </tags>
  </entry>
  <entry>
    <title>fusc 函数与尾递归优化</title>
    <url>/2024/07/07/fusc-%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="codewars-fusc-函数"><a href="#codewars-fusc-函数" class="headerlink" title="codewars-fusc 函数"></a>codewars-fusc 函数</h1><p><a href="https://www.codewars.com/kata/the-fusc-function-part-2">codewars 传送门</a></p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># fusc函数定义如下：</span><br><span class="line">fusc(0) = 0</span><br><span class="line">fusc(1) = 1</span><br><span class="line">fusc(2n) = fusc(n)</span><br><span class="line">fusc(2n + 1) = fusc(n) + fusc(n + 1)</span><br></pre></td></tr></tbody></table></figure>

<p>在这里你需要考虑栈溢出和超时问题，因为测试集是大数。<br>在题目描述中，给出了 fib 函数的优化方法以供参考：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># Fibonacci数定义如下：</span><br><span class="line">fib(0) = 1</span><br><span class="line">fib(1) = 1</span><br><span class="line">fib(n) = fib(n - 1) + fib(n - 2), if n &gt; 1       (1)</span><br></pre></td></tr></tbody></table></figure>

<p>第一步就是先尝试并找到一个尾递归定义，我们可以对等式 (1) 做处理，使得等式 (1) 两边具有相同形式，现在，等式右边有两项，而左边只有一项，所以容易想到的尝试是把左边也变成两项：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">fib(n) + fib(n - 1) = 2 * fib(n - 1) + fib(n - 2)      (2)</span><br></pre></td></tr></tbody></table></figure>

<p>等式 (2) 看起来是那么一回事了，但我们要做的是抽象出尾递归定义，等式中系数都为常数，因此我们可以从 (1) 式开始就将系数变量化：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">a * fib(n) = a * fib(n - 1) + a * fib(n - 2)</span><br><span class="line"># 接着两边加上b * fib(n - 1)</span><br><span class="line">a * fib(n) + b * fib(n - 1) = (a + b) * fib(n - 1) + a * fib(n - 2)   (3)</span><br></pre></td></tr></tbody></table></figure>

<p>现在等式 (3) 两边已有相同的形式，我们可以定义<br><code>F(a, b, n) = a * fib(n) + b * fib(n - 1)</code><br>那么等式 (3) 就可转换如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">F(a, b, n) = F(a + b, a, n - 1)</span><br></pre></td></tr></tbody></table></figure>

<p>那么这个定义运行到什么时候结束呢？因为前面 fib 公式定义在 <code>n &gt; 1</code> ，所以在 <code>n == 1</code> 时停止运行，那时有</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">F(a, b, 1) = a * fib(1) + b * fib(0) = a + b          末</span><br></pre></td></tr></tbody></table></figure>

<p>同时根据 F 的定义我们可以得到 fib (n) 在 F 上的定义</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">fib(n) = F(1, 0, n)                                   初</span><br></pre></td></tr></tbody></table></figure>

<p>综上所述，转换成代码即是：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">a, b, n</span>):</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">0</span>: <span class="keyword">return</span> a + b</span><br><span class="line">        <span class="keyword">return</span> F(a + b, a, n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> F(<span class="number">1</span>, <span class="number">0</span>, n)</span><br></pre></td></tr></tbody></table></figure>

<p>对于某些支持尾递归优化的语言来说，做到这里就结束了<br>Python 语言本身并不支持尾递归优化，因此需要转换成迭代形式</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        a, b, n = a + b, a, n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></tbody></table></figure>

<p>到这里的代码是没问题的，但是感觉总是有点不太对，所以建议还是看 codewar 里面的 description 吧，它是 <code>fib(n + 2) = fib(n) + fib(n + 1), if n + 2 &gt; 1</code> 定义的，这里的 <code>n &gt;= 0</code> 更直观。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>有了上面的 fib 例子，我们也可以按照同样的步骤设计 fusc 函数的尾递归优化</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">fusc(0) = 0</span><br><span class="line">fusc(1) = 1</span><br><span class="line">fusc(2n) = fusc(n)</span><br><span class="line">fusc(2n + 1) = fusc(n) + fusc(n + 1)</span><br></pre></td></tr></tbody></table></figure>

<p>从上面式子可以观察到是分奇偶的，所以在推导优化式子时也要分奇偶。</p>
<ul>
<li>偶数<br>为了统一一下，在系数方面我选择 a 在前面，b 在后面<br>按照上面例子，第一步是系数抽象：</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">b * fusc(2n + 1) = b * fusc(n) + b * fusc(n + 1)</span><br></pre></td></tr></tbody></table></figure>

<p>第二步是格式统一：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">a * fusc(2n) + b * fusc(2n + 1) = b * fusc(n) + b * fusc(n + 1) + a * fusc(2n)</span><br><span class="line"># 因为 fusc(2n) = fusc(n)，所以上式等于：</span><br><span class="line">a * fusc(2n) + b * fusc(2n + 1) = (a + b) * fusc(n) + b * fusc(n + 1)       (1)</span><br></pre></td></tr></tbody></table></figure>

<p>第三步是定义抽象函数 F：<br><code>F(a, b, n) = a * fib(n) + b * fib(n + 1)</code><br>第四步是回代 (1) 式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">F(a, b, 2n) = F(a + b, b, n)</span><br><span class="line"># 所以当n是偶数时，有：</span><br><span class="line">F(a, b, n) = F(a + b, b, n // 2)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>奇数<br>在看之前可以先自己推一下奇数的，再看我的想法。<br>同样的，这里就简写了：</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1    a * fusc(2n + 1) = a * fusc(n) + a * fusc(n + 1)</span><br><span class="line"></span><br><span class="line">2    a * fusc(2n + 1) + b * fusc(2n + 2) = a * fusc(n) + (a + b) * fusc(n + 1)</span><br><span class="line">     # 2式运用了 fusc(2n + 2) = fusc(n + 1)</span><br><span class="line"></span><br><span class="line">3    F(a, b, n) = a * fusc(n) + b * fusc(n + 1)</span><br><span class="line">     # 这里还是一样的定义，这就是前面为什么我要说(在系数方面我选择a在前面，b在后面)的原因了</span><br><span class="line"></span><br><span class="line">4    F(a, b, 2n + 1) = F(a, a + b, n)</span><br><span class="line">     # 所以当n是奇数时，有：</span><br><span class="line">     F(a, b, n) = F(a, a + b, (n - 1) // 2)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>定初末状态<br><code>fusc(n) = F(1, 0, n)</code> 初状态跟上面例子一样<br>综上，转换成代码为：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">a, b, n</span>):</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">0</span>: <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">		    <span class="keyword">return</span> F(a + b, b, n // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">	        <span class="keyword">return</span> F(a, a + b, (n - <span class="number">1</span>) // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> F(<span class="number">1</span>, <span class="number">0</span>, n)</span><br></pre></td></tr></tbody></table></figure>

<p>再转换成迭代形式：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fusc</span>(<span class="params">n</span>):</span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            a, b, n = a + b, b, n // <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a, b, n = a, a + b, (n - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> a + b <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">else</span> b</span><br></pre></td></tr></tbody></table></figure>

<p>但这段代码在 commit 时还是出现超时情况，所以还得再优化，比如位运算</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fusc</span>(<span class="params">n</span>):</span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">            a, b, n = a, a + b, (n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a, b, n = a + b, b, n &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a + b <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">else</span> b</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码就没有超时了，提交后可以查看别人代码。<br>在这里贴一个只有一行的答案，采用 lambda<br><img src="https://telegraph-image-eja.pages.dev/file/966c1d42f69a041bcbcfb.png" alt="solution"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">fusc=<span class="keyword">lambda</span> n,a=<span class="number">1</span>,b=<span class="number">0</span>:[i==<span class="string">'1'</span><span class="keyword">and</span>(b:=b+a)<span class="keyword">or</span>(a:=a+b) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">bin</span>(n)[<span class="number">2</span>:]] <span class="keyword">and</span> b</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>codewars</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>尾递归</tag>
        <tag>刷题</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title>Missing Semester Lecture 2 - Shell 工具与脚本</title>
    <url>/2023/12/18/Missing-Semester-lecture-2/</url>
    <content><![CDATA[<p><a href="https://missing.csail.mit.edu/2020/shell-tools/">missing semester lecture 2</a></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">a=hello</span><br><span class="line">echo "$a" #prints hello</span><br><span class="line">echo '$a' #prints $a</span><br></pre></td></tr></tbody></table></figure>

<p>Strings delimited with&nbsp;<code>'</code>&nbsp;are literal strings and will not substitute variable values whereas&nbsp;<code>"</code> delimited strings will.<br>notice: <code>a=hello</code>don’t allow to delimit with space, such as <code>a =hello</code>.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mcd () {</span><br><span class="line">    mkdir -p "$1"</span><br><span class="line">    cd "$1"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here is an example of a function that creates a directory and&nbsp;<code>cd</code>s into it when you type <code>mcd arg</code>.<br>You can also use <code>vim</code> to create a function.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim mcd.sh</span><br></pre></td></tr></tbody></table></figure>

<p>And then you come to a command pattern, you can type <code>i</code> to input mcd function. After you complete, you can press <code>Esc</code> to return the command pattern, you can type <code>:wq</code> to save it and quit vim. But now you can not use the mcd function.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">source mcd.sh</span><br></pre></td></tr></tbody></table></figure>

<p>Now you can call the mcd function. (If you want to know more about <code>vim</code>, just search it online.)</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mcd arg</span><br></pre></td></tr></tbody></table></figure>

<p>Bash uses a variety of special variables to refer to arguments:</p>
<ul>
<li><code>$0</code>&nbsp;- Name of the script</li>
<li><code>$1</code>&nbsp;to&nbsp;<code>$9</code>&nbsp;- Arguments to the script.&nbsp;<code>$1</code>&nbsp;is the first argument and so on.</li>
<li><code>$@</code>&nbsp;- All the arguments</li>
<li><code>$#</code>&nbsp;- Number of arguments</li>
<li><code>$?</code>&nbsp;- Return code of the previous command</li>
<li><code>$$</code>&nbsp;- Process identification number (PID) for the current script</li>
<li><code>!!</code>&nbsp;- Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing&nbsp;<code>sudo !!</code></li>
<li><code>$_</code>&nbsp;- Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing&nbsp;<code>Esc</code>&nbsp;followed by&nbsp;<code>.</code>&nbsp;or&nbsp;<code>Alt+.</code></li>
</ul>
<p>A value of 0 usually means everything went OK; anything different from 0 means an error occurred.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">false || echo "Oops, fail"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Oops, fail</span></span><br><span class="line"></span><br><span class="line">true || echo "Will not be printed"</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">true &amp;&amp; echo "Things went well"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Things went well</span></span><br><span class="line"></span><br><span class="line">false &amp;&amp; echo "Will not be printed"</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">true ; echo "This will always run"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This will always run</span></span><br><span class="line"></span><br><span class="line">false ; echo "This will always run"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This will always run</span></span><br></pre></td></tr></tbody></table></figure>

<p>Another common pattern is wanting to get the output of a command as a variable.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">foo=$(pwd)</span><br><span class="line">echo "$foo"</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat &lt;(ls) &lt;(ls ..)</span><br></pre></td></tr></tbody></table></figure>

<p><code>&lt;( CMD )</code>&nbsp;will execute&nbsp;<code>CMD</code>&nbsp;and place the output in a temporary file and substitute the&nbsp;<code>&lt;()</code>&nbsp;with that file’s name. This is useful when commands expect values to be passed by file instead of by STDIN.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo "Starting program at $(date)" # Date will be substituted</span><br><span class="line"></span><br><span class="line">echo "Running program $0 with $# arguments with pid $$"</span><br><span class="line"></span><br><span class="line">for file in "$@"; do</span><br><span class="line">    grep foobar "$file" &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">    # When pattern is not found, grep has exit status 1</span><br><span class="line">    # We redirect STDOUT and STDERR to a null register since we do not care about them</span><br><span class="line">    if [[ $? -ne 0 ]]; then</span><br><span class="line">        echo "File $file does not have any foobar, adding one"</span><br><span class="line">        echo "# foobar" &gt;&gt; "$file"</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>

<p>You can also edit it by vim like mcd function.&nbsp;This example will iterate through the arguments we provide,&nbsp;<code>grep</code>&nbsp;for the string&nbsp;<code>foobar</code>, and append it to the file as a comment if it’s not found.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">./example arg1 arg2 ...</span><br></pre></td></tr></tbody></table></figure>

<p>Shell globbing<br>you can use&nbsp;<code>?</code>&nbsp;and&nbsp;<code>*</code>&nbsp;to match one or any amount of characters respectively. For instance, given files&nbsp;<code>foo</code>,&nbsp;<code>foo1</code>,&nbsp;<code>foo2</code>,&nbsp;<code>foo10</code>&nbsp;and&nbsp;<code>bar</code>, the command&nbsp;<code>rm foo?</code>&nbsp;will delete&nbsp;<code>foo1</code>&nbsp;and&nbsp;<code>foo2</code>&nbsp;whereas&nbsp;<code>rm foo*</code>&nbsp;will delete all but&nbsp;<code>bar</code>.(<code>?</code> can just replace one.)<br>Other powerful usage:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">convert image.{png,jpg}</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Will <span class="built_in">expand</span> to</span></span><br><span class="line">convert image.png image.jpg</span><br><span class="line"></span><br><span class="line">cp /path/to/project/{foo,bar,baz}.sh /newpath</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Will <span class="built_in">expand</span> to</span></span><br><span class="line">cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Globbing techniques can also be combined</span></span><br><span class="line">mv *{.py,.sh} folder</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Will move all *.py and *.sh files</span></span><br><span class="line"></span><br><span class="line">mkdir foo bar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This creates files foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h</span></span><br><span class="line">touch {foo,bar}/{a..h}</span><br><span class="line">touch foo/x bar/y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Show differences between files <span class="keyword">in</span> foo and bar</span></span><br><span class="line">diff &lt;(ls foo) &lt;(ls bar)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Outputs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt; x</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">---</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt; y</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>vim script.py</code>:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/local/bin/python3</span></span><br><span class="line">import sys</span><br><span class="line">for arg in reversed(sys.argv[1:]):</span><br><span class="line">    print(arg)</span><br></pre></td></tr></tbody></table></figure>

<p>You can call it by <code>python3 script.py arg1 arg2 arg3</code>. But if we call it by <code>./script.py arg1 arg2 arg3</code>, it doesn’t work. So it is good practice to write shebang lines using the&nbsp;<code>env</code> that will resolve to wherever the command lives in the system, increasing the portability of your scripts. (<code>#!/usr/bin/env python3</code>)<br>Writing&nbsp;<code>bash</code>&nbsp;scripts can be tricky and unintuitive. There are tools like&nbsp;<a href="https://github.com/koalaman/shellcheck">shellcheck</a>&nbsp;that will help you find errors in your sh/bash scripts. You can also use sudo to install it.(When you call shellcheck, the terminal will give you some tips about how to use <code>sudo</code> to install it.)</p>
<p>Finding files:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all directories named src</span></span><br><span class="line">find . -name src -type d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all python files that have a folder named <span class="built_in">test</span> <span class="keyword">in</span> their path</span></span><br><span class="line">find . -path '*/test/*.py' -type f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all files modified <span class="keyword">in</span> the last day</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all zip files with size <span class="keyword">in</span> range 500k to 10M</span></span><br><span class="line">find . -size +500k -size -10M -name '*.tar.gz'</span><br></pre></td></tr></tbody></table></figure>

<p>Other command(should be installed) to find:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">fd ".*py"</span><br><span class="line">locate tmp #`locate`&nbsp;uses a database that is updated using&nbsp;`updatedb`.</span><br></pre></td></tr></tbody></table></figure>

<p>Beyond listing files, find can also perform actions over files that match your query.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Delete all files with .tmp extension</span></span><br><span class="line">find . -name '*.tmp' -exec rm {} \;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all PNG files and convert them to JPG</span></span><br><span class="line">find . -name '*.png' -exec convert {} {}.jpg \;</span><br></pre></td></tr></tbody></table></figure>

<p>Finding code:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">grep -R foobar</span><br></pre></td></tr></tbody></table></figure>

<p>Many&nbsp;<code>grep</code>&nbsp;alternatives have been developed, including&nbsp;<code>ack</code>,&nbsp;<code>ag</code>and&nbsp;<code>rg</code>.&nbsp;<br>Finding shell commands:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">history</span><br><span class="line">history | grep find</span><br></pre></td></tr></tbody></table></figure>

<p><code>fzf</code>&nbsp;is a general-purpose fuzzy finder that can be used with many commands. Here it is used to fuzzily match through your history and present results in a convenient and visually pleasing manner.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">history | fzf</span><br></pre></td></tr></tbody></table></figure>

<p>Directory Navigation:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">tree</span><br><span class="line">nnn # press `q` to quit.</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Missing Semester</category>
      </categories>
      <tags>
        <tag>命令笔记</tag>
        <tag>Shell</tag>
        <tag>Linux</tag>
        <tag>工具</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Missing Semester Lecture 1 - Shell 基础</title>
    <url>/2023/12/17/Missing-Semester-lecture-1/</url>
    <content><![CDATA[<p><a href="https://missing.csail.mit.edu/2020/course-shell/">missing semester lecture 1</a><br>In my first jump in missing semester – lecture 1, I learned something new(like a new language for me) about shell and had a try on ubuntu terminal. If there are any errors or missing things, please forgive me, as I haven’t really stepped into the Linux operating system yet.</p>
<p>During my study, there are something what I have learned as follow.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></tbody></table></figure>

<p>It can display current date and time.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo</span><br></pre></td></tr></tbody></table></figure>

<p>It can print out something you want.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">which</span><br></pre></td></tr></tbody></table></figure>

<p>It can find the system command position and return it. For example, the result of <code>which echo</code> is <code>/bin/echo</code> or <code>/usr/bin/echo</code>.So, using <code>echo</code> or using <code>/bin/echo</code> have the same effect(the next is an example).</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">/bin/echo $PATH</span><br><span class="line">/usr/bin/echo $PATH</span><br></pre></td></tr></tbody></table></figure>

<p><code>$PATH</code>&nbsp;lists which directories the shell should search for programs when it is given a command. The result of the three line above is the same.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mkdir</span><br><span class="line">touch</span><br></pre></td></tr></tbody></table></figure>

<p>The first can make a new directory in current directory.<br>The second can make a new file in current directory.(They’re not the same.<code>touch</code>can not make a new directory.)</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rm [file_name]</span><br><span class="line">rm -f</span><br><span class="line">rm -i</span><br><span class="line">rm -r(or R)</span><br><span class="line">rm -v</span><br></pre></td></tr></tbody></table></figure>

<p>Using <code>rm --help</code> can find the function of <code>-f</code> and etc.<br>Notice: <code>rm</code> will prompt you that the file is not exist while <code>rm -f</code> ignores whether the file is exist or not.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rm -r [directory_name]</span><br><span class="line">rm -rf []</span><br></pre></td></tr></tbody></table></figure>

<p><code>rm [directory_name]</code> can not succeed to remove directory. The two above can both remove directory.(But the second is dangerous in some case.)</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rmdir</span><br></pre></td></tr></tbody></table></figure>

<p>It can just remove blank directory.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></tbody></table></figure>

<p>It can display current directory.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd</span><br><span class="line">cd ~</span><br></pre></td></tr></tbody></table></figure>

<p>They can return to current user’s home directory like <code>/home/user_name</code> .</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd -</span><br></pre></td></tr></tbody></table></figure>

<p>It will return to the last directory that you have been accessed.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd .</span><br><span class="line">cd ..</span><br><span class="line">cd ../../</span><br></pre></td></tr></tbody></table></figure>

<p>In a path,&nbsp;<code>.</code>&nbsp;refers to the current directory, and&nbsp;<code>..</code>&nbsp;to its parent directory. And the <code>..</code> can be used for several times. (Hint: you can examine with <code>pwd</code> every time you use the <code>cd</code> .)<br>Notice: <code>cd ../../</code> must be the complete path. But when you are in a subdirectory, you don’t need to type complete path if you want to back to the parent directory or the parent directory of the parent directory and etc.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ls</span><br><span class="line">ls -l</span><br><span class="line">ls /[directory_name]</span><br><span class="line">ls -l /[directory_name]</span><br></pre></td></tr></tbody></table></figure>

<p>The first will print the contents of the current directory to see what lives in a given directory.<br>The second will print the contents of the current directory by using a long listing format, which means more detailed. The third and the fourth can print the contents of directory that you point so that you don’t need to switch your current directory.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">man</span><br></pre></td></tr></tbody></table></figure>

<p>For example, <code>man ls</code> will let you read the manual page about <code>ls</code> . That is its function.<br>And it is the last line in manual page: Manual page man(1) line 1 (press h for help or q to quit).</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat</span><br></pre></td></tr></tbody></table></figure>

<p><code>cat</code> stands for concatenate. You can also type <code>cat --help</code> to find some functions of options. For example, <code>-n</code> can number all output lines.<br><code>cat [file_name]</code> can print the whole text file.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat &gt; file_name</span><br></pre></td></tr></tbody></table></figure>

<p>It is better than <code>touch</code> for which it can make a new file and add content to it. What’s more, you can use <code>Ctrl + d</code> to save it.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat file_A &gt; file_B</span><br><span class="line">cat file_A file_C &gt;file_B</span><br><span class="line">cat &lt; file_A &gt; file_B</span><br></pre></td></tr></tbody></table></figure>

<p>It will delete the file_B’s data, and copy the file_A’s content to file_B. Copy several files is ok as well.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat file_A &gt;&gt; file_B</span><br></pre></td></tr></tbody></table></figure>

<p>When you don’t want to delete file_b’s content, you can use <code>&gt;&gt;</code> instead of <code>&gt;</code> .</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat file_name | grep -v '^$'</span><br><span class="line">cat file_name1 | grep -v '^$' &gt; file_name2</span><br></pre></td></tr></tbody></table></figure>

<p>They can delete blank line in the file. The first will print the changed content. The second will not output anything. And the file_name1’s content keep the same as before. The changed content is saved in file_name2.</p>
<p>When it comes to pipe <code>|</code> , let me introduce detailed usage about it.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">command1 | command2</span><br></pre></td></tr></tbody></table></figure>

<p>The output of command1 will become the input of command2.<br>For example:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ls | sort</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Missing Semester</category>
      </categories>
      <tags>
        <tag>命令笔记</tag>
        <tag>Shell</tag>
        <tag>Linux</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>单源最短路径 (Single-Source Shortest Paths)</title>
    <url>/2024/05/12/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="单源最短路径-SSSP"><a href="#单源最短路径-SSSP" class="headerlink" title="单源最短路径(SSSP)"></a>单源最短路径 (SSSP)</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h3 id="图的输入"><a href="#图的输入" class="headerlink" title="图的输入"></a>图的输入</h3><ul>
<li>无权图: bfs 可以求解其最短路径，无权图可以视为每条边的权重都是单位权重的图。前面已分享过，这里就不再赘述，传送门 <a href="https://ius7.qzz.io/2024/04/21/Elementary-Graph-Algorithms/">here</a></li>
<li> 有向带权图：从 u 到 v 的最短路径为任意一条满足 $w (p)=δ(u, v)$ 的路径。给定图 $G=(V, E)$，找出从源点 $s\in V$ 到每一个顶点 $v\in V$ 的一条最短路径。</li>
</ul>
<h3 id="松弛-Relaxation"><a href="#松弛-Relaxation" class="headerlink" title="松弛(Relaxation)"></a>松弛 (Relaxation)</h3><p>对于每个顶点 v，需要维护一个顶点属性 v.d 记录从 s 到 v 的最短路径的权重的上界。v.d 被称为从 s 到 v 的最短路径估计 (shortest-path estimate)。初始化如下:<br><img src="https://telegraph-image-eja.pages.dev/file/b63a6ef4467d480d1b43f.png" alt="image"><br>松弛操作如下:<br><img src="https://telegraph-image-eja.pages.dev/file/e75f4fa06dd16a04b677d.png" alt="image"></p>
<blockquote>
<p>其实就是在维护 v.d 这个属性，测试是否可以利用 u 对从 s 到 v 的最短路径估计进行改善 。</p>
</blockquote>
<h3 id="无路径性质"><a href="#无路径性质" class="headerlink" title="无路径性质"></a>无路径性质</h3><blockquote>
<p>若从 &nbsp;𝑠&nbsp; 到 &nbsp;𝑣&nbsp; 不存在路径，则 $𝑣.𝑑=𝛿(𝑠,𝑣)=∞$。</p>
</blockquote>
<h3 id="上界性质"><a href="#上界性质" class="headerlink" title="上界性质"></a>上界性质</h3><blockquote>
<p>对于所有顶点 $𝑣∈𝑉$，有 $𝑣.𝑑≥𝛿(𝑠,𝑣)$，并且该不变式在对 𝐺 的边进行任意顺序的松弛过程中保持成立。而且，一旦 𝑣.𝑑 达到其下界 $𝛿(𝑠,𝑣)$，𝑣.𝑑 不再改变。</p>
</blockquote>
<p><strong>Proof</strong></p>
<ul>
<li>base case：初始化后，对于所有 $𝑣∈𝑉−{𝑠}$，有 $𝑣.𝑑=∞$，则 $𝑣.𝑑≥𝛿(𝑠,𝑣)$ 显然成立，而对于 𝑠，有 $𝑠.𝑑=0≥𝛿(𝑠,𝑠)$。</li>
<li>inductive hypothesis：在算法的每次迭代之前，对于所有顶点 $x\in V$, 有 $x.d \geq \delta (s, x)$。</li>
<li>inductive step：考虑边 (u, v) 的松弛操作，唯一能改变的只有 𝑣.𝑑，若它发生改变，有<br>$v.d = u.d + w(u, v)$<br>$\geq \delta(s, u) + w(u, v)$<br>$\ge \delta(s, v)$<br>因为 $𝑣.𝑑≥𝛿(𝑠,𝑣)$ 且松弛操作不会增大 𝑣.𝑑，所以一旦 𝑣.𝑑 达到其下界 $𝛿(𝑠,𝑣)$，𝑣.𝑑 不再改变。</li>
</ul>
<h3 id="收敛性质"><a href="#收敛性质" class="headerlink" title="收敛性质"></a>收敛性质</h3><blockquote>
<p>若对于某些顶点 $𝑢,𝑣∈𝑉$，$𝑠⇝𝑢→𝑣$ 为 𝐺 中的一条最短路径，在对 (𝑢, 𝑣) 进行松弛之前的任意时间有 $𝑢.𝑑=𝛿(𝑠,𝑢)$，则在对 (𝑢, 𝑣) 进行松弛之后的时间有 $𝑣.𝑑=𝛿(𝑠,𝑣)$。</p>
</blockquote>
<p>根据上界性质，若松弛边 (𝑢, 𝑣) 前的某个时刻已经有 $𝑢.𝑑=𝛿(𝑠,𝑢)$，则此后该等式保持成立。当边 (𝑢, 𝑣) 被松弛后，有<br>$v.d \leq u.d + w(u, v)$<br>$= \delta(s, u) + w(u, v)$<br>$= \delta(s, v)$<br>又根据上界性质，有 $𝑣.𝑑≥𝛿(𝑠,𝑣)$，此后 $𝑣.𝑑=𝛿(𝑠,𝑣)$ 保持不变</p>
<h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>你可以把 Dijkstra 算法看作是将广度优先搜索推广到加权图。波从源点发出，当波第一次到达某个顶点时，记录从源点到该顶点的最短路径长度，新的波从该顶点发出，直到记录完从源点到所有顶点的最短路径长度。</p>
<blockquote>
<p>$DIJKSTRA(G, w, s)$<br>1 $INITIALIZE-SINGLE-SOURCE (G, s)$ // 初始化<br>2 $S = \not 0$ // 初始化顶点集合 S，表示从 &nbsp;𝑠&nbsp; 可达的最终最短距离已经确定的顶点的集合。<br>3 $Q = \not 0$ // 初始化以 v.d 为 key 的最小优先队列<br>4 for each vertex $u \in G.V$<br>5 $INSERT (Q, u)$ // 将所有顶点入队<br>6 while $Q \not = \not 0$ // 只要队列非空继续执行，易知一共执行 V 次，过程中 $Q = V - S$ 不变<br>7 $u = EXTRACT-MIN (Q)$ // 从 Q 中选择具有最小路径估计的顶点 𝑢<br>8 $S = S \cup {u}$ // 将 u 加入到 S<br>9 for each vertex $v \in G.Adj[u]$<br>10 RELAX (u, v, w) // 松弛所有从 𝑢 发出的边<br>11 if the call of RELAX decreased v.d<br>12 $DECREASED-KEY (Q, v, v.d)$ // 更新 Q 中顶点最短路径估计</p>
</blockquote>
<p>下面给出过程示例图：<br><img src="https://telegraph-image-eja.pages.dev/file/69fa37e8cf4862d7e25ba.png" alt="image"></p>
<h3 id="Theorem-Correctness-of-Dijkstra’s-algorithm"><a href="#Theorem-Correctness-of-Dijkstra’s-algorithm" class="headerlink" title="Theorem(Correctness of Dijkstra’s algorithm)"></a>Theorem(Correctness of Dijkstra’s algorithm)</h3><p>下面采用归纳法证明算法的正确性，我们将要证明在 6-12 行的每一次迭代开始时，对于所有顶点 $𝑣\in𝑆$，有 $𝑣.𝑑=\delta (𝑠,𝑣)$。算法终止时，由于 𝑆 = 𝑉，因此对于所有顶点 $𝑣\in 𝑉$，有 $𝑣.𝑑=\delta (𝑠,𝑣)$。<br><strong>Proof</strong></p>
<ul>
<li>base cases<ul>
<li> 当 $|𝑆|=0$ 时，有 $𝑆 = ∅$，断言为真。</li>
<li>当 $|𝑆|=1$ 时，有 $𝑆={𝑠}$ 且 $𝑠.𝑑=𝛿(𝑠,𝑠)=0$。</li>
</ul>
</li>
<li>inductive hypothesis：对于所有顶点 $𝑣\in 𝑉$，有 $𝑣.𝑑=𝛿(𝑠,𝑣)$。<br><img src="https://telegraph-image-eja.pages.dev/file/c7f1800d8c978418f3bde.png" alt="image"></li>
<li>算法每次迭代添加一个顶点 𝑢 到 𝑆 中，我们需要证明操作结束后有 $𝑢.𝑑=𝛿(𝑠,𝑢)$。 - 若从 𝑠 到 𝑢 不存在路径，则根据无路径性质，证明完毕。 - 若从 𝑠 到 𝑢 存在路径，如图所示，设 𝑦 为从 𝑠 到 𝑢 的路径上的第一个不在 𝑆 中的顶点，令 $𝑥∈𝑆$ 为 𝑦 在该路径上的前驱，当然可以存在 $𝑦=𝑢$ 或者 $𝑥=𝑠$ 的情况，由于在该路径上 𝑦 不会晚于 𝑢 出现且所有边的权重非负，有 $𝛿(𝑠,𝑦)≤𝛿(𝑠,𝑢)$，又由于 EXTRACT-MIN 返回了 𝑉−𝑆 中 𝑑 值最小的顶点，有 $𝑢.𝑑≤𝑦.𝑑$，根据上界性质，有 $𝛿(𝑠,𝑢)≤𝑢.𝑑$。 - 对于 $𝑥∈𝑆$，根据归纳假设有 $𝑥.𝑑=𝛿(𝑠,𝑥)$。在 while 循环的某一次迭代中，𝑥 被加入 𝑆，边 (𝑥, 𝑦) 被松弛，根据收敛性质，𝑦.𝑑 此时得到最小值 $𝛿(𝑠,𝑦)$，有 $𝛿(𝑠,𝑦)≤𝛿(𝑠,𝑢)≤𝑢.𝑑≤𝑦.𝑑$ 且 $𝑦.𝑑=𝛿(𝑠,𝑦)$，即 $𝛿(𝑠,𝑦)=𝛿(𝑠,𝑢)=𝑢.𝑑=𝑦.𝑑$。因此 $𝑢.𝑑=𝛿(𝑠,𝑢)$，根据上界性质，𝑢.𝑑 不再改变，得证。<blockquote>
<p>也可以从循环不变量角度理解，在每一次迭代中，以下条件保持不变：</p>
</blockquote>
</li>
<li>对于所有已确定的顶点 v，即加入到 S 中的顶点 v，它们的 v.d 是正确的，即从源点到这些顶点的最短路径长度已经被找到。</li>
<li>对于所有未确定的顶点，存在一个 “松弛” 操作，该操作可以减少某个顶点的距离值，同时保持其他顶点的距离值不变或减少。<br><strong>Proof</strong></li>
<li> 初始化：在算法开始时，只有源点的距离值被设置为 0，其他所有顶点的距离值被设置为无穷大。这满足了循环不变量的条件，因为源点到自己的最短路径长度是 0，而其他顶点的最短路径长度尚未确定。</li>
<li>保持：在算法的每次迭代中，我们选择一个未确定的最短距离顶点 (即队列中的第一个顶点)，并将其标记为已确定 (即将其加入到 S)。然后，我们更新这个顶点的所有邻接顶点的距离值。这个过程中，已确定顶点的距离值不会改变 (因为它们已经出队)，而未确定顶点的距离值只会在找到更短的路径时减少。因此，循环不变量在每个迭代中都被保持。</li>
<li>终止：当算法终止时，所有顶点的最短路径长度都已经被确定。这是因为算法在每次迭代中都选择了一个未确定的最短距离顶点，并将其标记为已确定，直到没有未确定的顶点为止。根据循环不变量，所有已确定的顶点的距离值是正确的，因此算法找到了从源点到所有其他顶点的最短路径。<blockquote>
<p>Dijkstra 的局限性在于它要求所有边的权重都得 ≥0，因为如果存在负边，原本已经被加入到 S 的顶点还有可能通过有负边的路径而减小 d 值，这违反了循环不变量。</p>
</blockquote>
</li>
</ul>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><blockquote>
<p>$DIJKSTRA(G, w, s)$<br>1 $INITIALIZE-SINGLE-SOURCE(G, s)$ //O(V)<br>2 $S = \not 0$ //O(1)<br>3 $Q = \not 0$ //O(1)<br>4 for each vertex $u \in G.V$ //O(V)<br>5 $INSERT(Q, u)$ //O(1)<br>6 while $Q \not = \not 0$ //O(V)<br>7 $u = EXTRACT-MIN(Q)$ //O(V) or $𝑂(lg⁡𝑉)$<br>8 $S = S \cup {u}$ //O(1)<br>9 for each vertex $v \in G.Adj [u]$ //O (E)(因为每条边都会被松弛一次)<br>10 RELAX(u, v, w) //O(1)<br>11 if the call of RELAX decreased v.d //O(1)<br>12 $DECREASED-KEY(Q, v, v.d)$ //O(1) or $𝑂(lg⁡𝑉)$</p>
</blockquote>
<p>Dijkstra 算法的运行时间取决于最小优先队列的具体实现，一个简单的实现方式就是将顶点从 1 到 𝑉 编号，构造一个数组 &nbsp;𝐴[1 : 𝑉]&nbsp;，编号 𝑖 的顶点 𝑣 的 𝑣.𝑑 存储在数组的第 𝑖 项中，每次调用 INSERT 和 DECREASED-KEY 的运行时间为 𝑂(1)，每次调用 EXTRACT_MIN 的运行时间为 𝑂(𝑉)&nbsp;(由于需要遍历整个数组找到最小值)，总的运行时间为 $𝑂(𝑉^2+𝐸)=𝑂(𝑉^2)$。</p>
<p>如果图足够稀疏，特别的，如果 $𝐸=𝑜(𝑉^2/lg⁡𝑉)$，那么我们可以使用最小二叉堆实现最小优先队列，其中包含将顶点映射到对应的堆中元素的函数，每次调用 EXTRACT_MIN 的运行时间为 $𝑂(lg⁡𝑉)$，构建最小二叉堆的运行时间为 𝑂(𝑉)，总的运行时间为 $𝑂((𝑉+𝐸) lg⁡𝑉)$，若 $E=\Omega (V)$，则总的运行时间为 $𝑂(𝐸lg⁡𝑉)$。若 $𝐸=𝑜(𝑉^2/lg⁡𝑉)$，则总的运行时间相比 $𝑂(𝑉^2)$ 有所改善。</p>
<h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><blockquote>
<p>$DIJKSTRA(G, w, s)$<br>1 $INITIALIZE-SINGLE-SOURCE(G, s)$ //O(V)<br>2 $S = \not 0$ //O(V)<br>3 $Q = \not 0$ //O(V)<br>4 for each vertex $u \in G.V$<br>5 $INSERT(Q, u)$ //O(1)<br>6 while $Q \not = \not 0$<br>7 $u = EXTRACT-MIN(Q)$ //O(1)<br>8 $S = S \cup {u}$ //O(1)<br>9 for each vertex $v \in G.Adj[u]$<br>10 RELAX(u, v, w)<br>11 if the call of RELAX decreased v.d<br>12 $DECREASED-KEY(Q, v, v.d)$ //O(1)</p>
</blockquote>
<p>所以总空间复杂度为 $O (V)$</p>
<h3 id="cpp-算法实现"><a href="#cpp-算法实现" class="headerlink" title="cpp 算法实现"></a>cpp 算法实现</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 顶点结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> {</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> index; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="comment">// 顶点索引</span></span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> distance; &nbsp; &nbsp; &nbsp; <span class="comment">// 到源顶点的距离</span></span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> parent; &nbsp; &nbsp; &nbsp; &nbsp; <span class="comment">// 前驱节点索引</span></span><br><span class="line">&nbsp; &nbsp; <span class="built_in">Vertex</span>(<span class="type">int</span> i, <span class="type">int</span> d, <span class="type">int</span> p) : <span class="built_in">index</span>(i), <span class="built_in">distance</span>(d), <span class="built_in">parent</span>(p) {}</span><br><span class="line">&nbsp; &nbsp; <span class="comment">// 自定义比较函数，用于优先队列</span></span><br><span class="line">&nbsp; &nbsp; <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Vertex&amp; other) <span class="type">const</span> {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">return</span> distance &gt; other.distance;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 边结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> {</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> from; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="comment">// 起始顶点索引</span></span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> to; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="comment">// 终止顶点索引</span></span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> weight; &nbsp; &nbsp; &nbsp; &nbsp; <span class="comment">// 边的权重</span></span><br><span class="line">&nbsp; &nbsp; <span class="built_in">Edge</span>(<span class="type">int</span> f, <span class="type">int</span> t, <span class="type">int</span> w) : <span class="built_in">from</span>(f), <span class="built_in">to</span>(t), <span class="built_in">weight</span>(w) {}</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 图类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> V; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="comment">// 顶点数量</span></span><br><span class="line">&nbsp; &nbsp; vector&lt;vector&lt;Edge&gt;&gt; adj; &nbsp; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="built_in">Graph</span>(<span class="type">int</span> vertices) : <span class="built_in">V</span>(vertices) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; adj.<span class="built_in">resize</span>(V);</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> weight)</span> </span>{</span><br><span class="line">&nbsp;   &nbsp; &nbsp; adj[from].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, to, weight));</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">getAdj</span>() {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">return</span> adj;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">int</span> <span class="title">getV</span><span class="params">()</span> </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">return</span> V;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">};</span><br><span class="line"><span class="comment">// Dijkstra 算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dijkstra</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">initializeSingleSource</span><span class="params">(Graph&amp; G, <span class="type">int</span> s, vector&lt;Vertex&gt;&amp; vertices)</span> </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="type">int</span> V = G.<span class="built_in">getV</span>();</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; vertices.<span class="built_in">clear</span>();</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; vertices.<span class="built_in">reserve</span>(V);</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; ++i) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(i, numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>(), <span class="number">-1</span>));</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; vertices[s].distance = <span class="number">0</span>;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">relax</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> weight, vector&lt;Vertex&gt;&amp; vertices, priority_queue&lt;Vertex, vector&lt;Vertex&gt;, greater&lt;Vertex&gt;&gt;&amp; Q)</span> </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">if</span> (vertices[v].distance &gt; vertices[u].distance + weight) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vertices[v].distance = vertices[u].distance + weight;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vertices[v].parent = u;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="comment">// 重新构建优先队列</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priority_queue&lt;Vertex, vector&lt;Vertex&gt;, greater&lt;Vertex&gt;&gt; updatedQ;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updatedQ.<span class="built_in">push</span>(Q.<span class="built_in">top</span>());</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Q.<span class="built_in">pop</span>();</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">swap</span>(Q, updatedQ);</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">dijkstra</span><span class="params">(Graph&amp; G, <span class="type">int</span> s)</span> </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="type">int</span> V = G.<span class="built_in">getV</span>();</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; vector&lt;Vertex&gt; vertices;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; priority_queue&lt;Vertex, vector&lt;Vertex&gt;, greater&lt;Vertex&gt;&gt; Q;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">initializeSingleSource</span>(G, s, vertices);</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">for</span> (Vertex v : vertices) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Q.<span class="built_in">push</span>(v);</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vertex uVertex = Q.<span class="built_in">top</span>();</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Q.<span class="built_in">pop</span>();</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="type">int</span> u = uVertex.index;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;Edge&gt; neighbors = G.<span class="built_in">getAdj</span>()[u];</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">for</span> (Edge edge : neighbors) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="type">int</span> v = edge.to;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="type">int</span> weight = edge.weight;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">relax</span>(u, v, weight, vertices, Q);</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">printShortestPaths</span>(s, vertices);</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printShortestPaths</span><span class="params">(<span class="type">int</span> source, <span class="type">const</span> vector&lt;Vertex&gt;&amp; vertices)</span> </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; <span class="string">"Shortest Paths from source vertex "</span> &lt;&lt; source &lt;&lt; <span class="string">":"</span> &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">for</span> (<span class="type">const</span> Vertex&amp; v : vertices) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; <span class="string">"Vertex "</span> &lt;&lt; v.index &lt;&lt; <span class="string">": Distance = "</span> &lt;&lt; v.distance &lt;&lt; <span class="string">", Parent = "</span> &lt;&lt; v.parent &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">&nbsp; &nbsp; <span class="comment">// 构建图</span></span><br><span class="line">&nbsp; &nbsp; <span class="function">Graph <span class="title">G</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> source = <span class="number">0</span>;</span><br><span class="line">&nbsp; &nbsp; Dijkstra::<span class="built_in">dijkstra</span>(G, source);</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><p>Bellman-Ford 算法解决的是一般情况下单源最短路径问题，边的权重可以为负值。Bellman-Ford 算法返回一个布尔值，该布尔值表明是否存在一个从源点可达的负权重的环路。若存在这样一个环路，则算法提示不存在解决方案。若不存在这样一个环路，则算法给出最短路径和它们的权重。<br>注意：负权重环路是总权重为负的环路，而非只要有负权重的边所形成的环路就是负权重环路。<br>伪代码如下：</p>
<blockquote>
<p>$BELLMAN-FORD(G, w, s)$<br>1 $INITIALIZE-SINGLE-SOURCE(G, s)$<br>2 for $i = 1$ to $|G.V| - 1$<br>3 for each edge $(u, v) \in G.E$<br>4 RELAX(u, v, w)<br>5 for each edge $(u, v) \in G.E$<br>6 if $v.d &gt; u.d + w(u, v)$<br>7 return FALSE<br>8 return TRUE</p>
</blockquote>
<p>示例图：<br><img src="https://telegraph-image-eja.pages.dev/file/4af76847af45d3632f2c2.png" alt="image"><br>// 从上图我们可以发现在每一次迭代中都有一个节点的 d 值被确定，不再改变。依次被确定的节点是：$&lt;s,y,x,t,z&gt;$，因为这例子比较特殊，每次迭代都只确定一个节点，但在实际情况中，通常少于 $V-1$ 次迭代就可以确定完，因此正确的表述是每次迭代都至少有一个节点的 d 值被确定。</p>
<h4 id="时间复杂度分析-邻接表"><a href="#时间复杂度分析-邻接表" class="headerlink" title="时间复杂度分析(邻接表)"></a>时间复杂度分析 (邻接表)</h4><blockquote>
<p>$BELLMAN-FORD(G, w, s)$<br>1 $INITIALIZE-SINGLE-SOURCE(G, s)$ //$\Theta(V)$<br>2 for $i = 1$ to $|V| - 1$<br>3 for each vertex $u\in V$<br>4 for each vertex $v \in G.Adj[u]$<br>5 RELAX (u, v, w) //2-5: $\Theta (V + E)$ 循环 $V-1$ 次<br>6 for each vertex $u\in V$<br>7 for each vertex $v\in G.Adj[u]$<br>8 if $v.d &gt; u.d + w(u, v)$<br>9 return FALSE //6-9: O(V + E)<br>10 return TRUE</p>
</blockquote>
<p>因此总的时间复杂度为 $O (V^2 + VE)$，若 $E=\Omega (V)$，则时间复杂度可以表示为 $O (VE)$。</p>
<h4 id="空间复杂度分析-1"><a href="#空间复杂度分析-1" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><blockquote>
<p>$BELLMAN-FORD(G, w, s)$<br>1 $INITIALIZE-SINGLE-SOURCE(G, s)$ //O(V)<br>2 for $i = 1$ to $|V| - 1$<br>3 for each vertex $u\in V$<br>4 for each vertex $v \in G.Adj[u]$<br>5 RELAX(u, v, w)<br>6 for each vertex $u\in V$<br>7 for each vertex $v\in G.Adj[u]$<br>8 if $v.d &gt; u.d + w(u, v)$<br>9 return FALSE<br>10 return TRUE</p>
</blockquote>
<p>因此总的空间复杂度为 O (V)</p>
<h4 id="Theorem-Correctness-of-the-Bellman-Ford-algorithm"><a href="#Theorem-Correctness-of-the-Bellman-Ford-algorithm" class="headerlink" title="Theorem(Correctness of the Bellman-Ford algorithm)"></a>Theorem(Correctness of the Bellman-Ford algorithm)</h4><p>假设 𝐺 中不存在从源点 𝑠 可达的负权重的环路，在算法运行结束时，对于任意一条边 $(𝑢,𝑣)∈𝐸$，有<br>$v.d=\delta(s, v)$<br>$\le \delta(s, u) + w(u, v)$<br>$= u.d + w(u, v)$<br>此时算法一定返回 TRUE</p>
<p>假设 G 中存在从源点 s 可达的负权重环路，设该环路为 $c=&lt;v_0,v_1,…,v_k&gt;$，其中 $v_0=v_k$，有</p>
<p>$$<br>\sum_{i=1}^{k}w(v_{i-1},v_{i})&lt;0<br>$$</p>
<p>接下来用反证法，假设算法返回 TRUE，则对于 $i=1,2,…,k$，有 $v_i.d \le v_{i-1}.d+w (v_{i-1},v_i)$</p>
<p>$$<br>\sum_{i=1}^k v_i.d \leq\sum_{i=1}^k (v_{i-1}.d + w(v_{i-1}, v_i))<br>$$</p>
<p>$$<br>=\sum_{i=1}^k v_{i-1}.d +\sum_{i=1}^k w(v_{i-1}, v_i)<br>$$</p>
<p>由于 $v_0=v_k$，那么</p>
<p>$$<br>\sum_{i=1}^k v_i.d =\sum_{i=1}^k v_{i-1}.d<br>$$</p>
<p>解得</p>
<p>$$<br>0\leq\sum_{i=1}^k w(v_{i-1}, v_i)<br>$$</p>
<p>与上面的不等式矛盾，因此算法返回的是 FALSE，所以 bellman-ford 算法能检查负权重环路，因此能处理负边。</p>
<h4 id="cpp-算法实现-1"><a href="#cpp-算法实现-1" class="headerlink" title="cpp 算法实现"></a>cpp 算法实现</h4><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 边结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> {</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> to; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="comment">// 终止顶点索引</span></span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> weight; &nbsp; &nbsp; &nbsp; &nbsp; <span class="comment">// 边的权重</span></span><br><span class="line">&nbsp; &nbsp; <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w) : <span class="built_in">to</span>(t), <span class="built_in">weight</span>(w) {}</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 图类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> V; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="comment">// 顶点数量</span></span><br><span class="line">&nbsp; &nbsp; vector&lt;vector&lt;Edge&gt;&gt; adj; &nbsp; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="built_in">Graph</span>(<span class="type">int</span> vertices) : <span class="built_in">V</span>(vertices) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; adj.<span class="built_in">resize</span>(V);</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> weight)</span> </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; adj[from].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, weight));</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; vector&lt;vector&lt;Edge&gt;&gt;&amp; <span class="built_in">getAdj</span>() {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">return</span> adj;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">int</span> <span class="title">getV</span><span class="params">()</span> </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">return</span> V;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 初始化单源最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initializeSingleSource</span><span class="params">(Graph&amp; G, <span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; distance, vector&lt;<span class="type">int</span>&gt;&amp; predecessor)</span> </span>{</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> V = G.<span class="built_in">getV</span>();</span><br><span class="line">&nbsp; &nbsp; distance.<span class="built_in">clear</span>();</span><br><span class="line">&nbsp; &nbsp; distance.<span class="built_in">resize</span>(V, numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">&nbsp; &nbsp; predecessor.<span class="built_in">clear</span>();</span><br><span class="line">&nbsp; &nbsp; predecessor.<span class="built_in">resize</span>(V, <span class="number">-1</span>);</span><br><span class="line">&nbsp; &nbsp; distance[s] = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 松弛操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">relax</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> weight, vector&lt;<span class="type">int</span>&gt;&amp; distance, vector&lt;<span class="type">int</span>&gt;&amp; predecessor)</span> </span>{</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">if</span> (distance[v] &gt; distance[u] + weight) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; distance[v] = distance[u] + weight;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; predecessor[v] = u;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Bellman-Ford 算法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bellmanFord</span><span class="params">(Graph&amp; G, <span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; distance, vector&lt;<span class="type">int</span>&gt;&amp; predecessor)</span> </span>{</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> V = G.<span class="built_in">getV</span>();</span><br><span class="line">&nbsp; &nbsp; <span class="built_in">initializeSingleSource</span>(G, s, distance, predecessor);</span><br><span class="line">&nbsp; &nbsp; <span class="comment">// 重复 |V| - 1 次松弛操作</span></span><br><span class="line">&nbsp; &nbsp; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= V - <span class="number">1</span>; ++i) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; ++u) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">for</span> (Edge edge : G.<span class="built_in">getAdj</span>()[u]) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="type">int</span> v = edge.to;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="type">int</span> weight = edge.weight;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">relax</span>(u, v, weight, distance, predecessor);</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="comment">// 检查是否存在负权回路</span></span><br><span class="line">&nbsp; &nbsp; <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; ++u) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">for</span> (Edge edge : G.<span class="built_in">getAdj</span>()[u]) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="type">int</span> v = edge.to;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="type">int</span> weight = edge.weight;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">if</span> (distance[v] &gt; distance[u] + weight) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 存在负权回路</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 不存在负权回路</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 输出最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printShortestPath</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> v, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; predecessor)</span> </span>{</span><br><span class="line">&nbsp; &nbsp; stack&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> current = v;</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">while</span> (current != s) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; path.<span class="built_in">push</span>(current);</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; current = predecessor[current];</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; path.<span class="built_in">push</span>(s);</span><br><span class="line">&nbsp; &nbsp; cout &lt;&lt; <span class="string">"Shortest path from "</span> &lt;&lt; s &lt;&lt; <span class="string">" to "</span> &lt;&lt; v &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">while</span> (!path.<span class="built_in">empty</span>()) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; path.<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; path.<span class="built_in">pop</span>();</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">&nbsp; &nbsp; <span class="comment">// 构建图</span></span><br><span class="line">&nbsp; &nbsp; <span class="function">Graph <span class="title">G</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">7</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">-4</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">-3</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&nbsp; &nbsp; G.<span class="built_in">addEdge</span>(<span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> source = <span class="number">0</span>;</span><br><span class="line">&nbsp; &nbsp; vector&lt;<span class="type">int</span>&gt; distance;</span><br><span class="line">&nbsp; &nbsp; vector&lt;<span class="type">int</span>&gt; predecessor;</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">if</span> (<span class="built_in">bellmanFord</span>(G, source, distance, predecessor)) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; <span class="string">"No negative weight cycle detected."</span> &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.<span class="built_in">getV</span>(); ++v) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">if</span> (v != source) {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">printShortestPath</span>(source, v, predecessor);</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; } <span class="keyword">else</span> {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; <span class="string">"Negative weight cycle detected."</span> &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line"> &nbsp; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路径</tag>
        <tag>Dijkstra</tag>
        <tag>Bellman-Ford</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划 (Dynamic Programming)</title>
    <url>/2024/03/31/dynamic%20programming/</url>
    <content><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><blockquote>
<p>[!question]<br>经典爬楼梯问题<br>给定一个共有 &nbsp;n 阶的楼梯，你每步可以上 &nbsp;1&nbsp; 阶或者 &nbsp;2&nbsp; 阶，请问有多少种方案可以爬到楼顶？</p>
</blockquote>
<h3 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;choices, <span class="type">int</span> state, <span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt; &amp;res)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (state == n)</span><br><span class="line">        res[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;choice : choices) {</span><br><span class="line">        <span class="keyword">if</span> (state + choice &gt; n)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(choices, state + choice, n, res);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbingStairsBacktrack</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; choices = {<span class="number">1</span>, <span class="number">2</span>};</span><br><span class="line">    <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = {<span class="number">0</span>};</span><br><span class="line">    <span class="built_in">backtrack</span>(choices, state, n, res);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="方法二：暴搜"><a href="#方法二：暴搜" class="headerlink" title="方法二：暴搜"></a>方法二：暴搜</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">dfs</span>(i - <span class="number">1</span>) + <span class="built_in">dfs</span>(i - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbingStairsDFS</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(n);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="方法三：记忆化搜索"><a href="#方法三：记忆化搜索" class="headerlink" title="方法三：记忆化搜索"></a>方法三：记忆化搜索</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt; &amp;mem)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">if</span> (mem[i] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> mem[i];</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">dfs</span>(i - <span class="number">1</span>, mem) + <span class="built_in">dfs</span>(i - <span class="number">2</span>, mem);</span><br><span class="line">    mem[i] = count;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbingStairsDFSMem</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mem</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(n, mem);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="方法四：动态规划"><a href="#方法四：动态规划" class="headerlink" title="方法四：动态规划"></a>方法四：动态规划</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbingStairsDP</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbingStairsDPComp</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="type">int</span> tmp = b;</span><br><span class="line">        b = a + b;</span><br><span class="line">        a = tmp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="DP-问题特性"><a href="#DP-问题特性" class="headerlink" title="DP 问题特性"></a>DP 问题特性</h2><h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><blockquote>
<p>[!question]<br>给定一个楼梯，你每步可以上 &nbsp;1&nbsp; 阶或者 &nbsp;2&nbsp; 阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。给定一个非负整数数组 &nbsp;cost&nbsp;，其中 &nbsp;cost [i]&nbsp; 表示在第 &nbsp;i&nbsp; 个台阶需要付出的代价，cost [0]&nbsp; 为地面（起始点）。请计算最少需要付出多少代价才能到达顶部？</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairsDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cost)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = cost.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> cost[n];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>] = cost[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairsDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cost)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = cost.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> cost[n];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> prev1 = cost[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> prev2 = cost[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="type">int</span> current = <span class="built_in">min</span>(prev1, prev2) + cost[i];</span><br><span class="line">        prev1 = prev2;</span><br><span class="line">        prev2 = current;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(prev1, prev2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h3><blockquote>
<p><strong>给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关</strong>。</p>
</blockquote>
<blockquote>
<p>[!question]<br>给定一个共有 &nbsp;n 阶的楼梯，你每步可以上 &nbsp;1&nbsp; 阶或者 &nbsp;2&nbsp; 阶，<strong>但不能连续两轮跳 &nbsp;1&nbsp; 阶</strong>，请问有多少种方案可以爬到楼顶？</p>
</blockquote>
<blockquote>
<p>扩展状态定义，使得问题重新满足无后效性。</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbingStairsConstraintDP</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[i][<span class="number">2</span>] = dp[i - <span class="number">2</span>][<span class="number">1</span>] + dp[i - <span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">1</span>] + dp[n][<span class="number">2</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="动态规划解题步骤"><a href="#动态规划解题步骤" class="headerlink" title="动态规划解题步骤"></a>动态规划解题步骤</h2><blockquote>
<p>[!example]<br>给定一个 &nbsp;n × n 的二维网格 &nbsp;<code>grid</code>&nbsp;，网格中的每个单元格包含一个非负整数，表示该单元格的代价。机器人以左上角单元格为起始点，每次只能向下或者向右移动一步，直至到达右下角单元格。请返回从左上角到右下角的最小路径和。</p>
</blockquote>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><blockquote>
<p>描述决策：只能向下、右走，定义状态：行列索引 [i, j]，建立 &nbsp;dp 表：矩阵</p>
</blockquote>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><blockquote>
<p>找出最优子结构，进而推导出状态转移方程</p>
</blockquote>
<p>$dp[i, j] = min(dp[i - 1, j], dp[i, j - 1]) + grid[i, j]$</p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><blockquote>
<p>确定边界条件：初始化首行首列， 状态转移顺序：正序遍历矩阵</p>
</blockquote>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><h4 id="方法一：暴搜"><a href="#方法一：暴搜" class="headerlink" title="方法一：暴搜"></a>方法一：暴搜</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSumDFS</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> up = <span class="built_in">minPathSumDFS</span>(grid, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">minPathSumDFS</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(left, up) != INT_MAX ? std::<span class="built_in">min</span>(left, up) + grid[i][j] : INT_MAX;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="方法二：记搜"><a href="#方法二：记搜" class="headerlink" title="方法二：记搜"></a>方法二：记搜</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSumDFSMem</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mem, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (mem[i][j] != <span class="number">-1</span>) {</span><br><span class="line">        <span class="keyword">return</span> mem[i][j];</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> up = <span class="built_in">minPathSumDFSMem</span>(grid, mem, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">minPathSumDFSMem</span>(grid, mem, i, j - <span class="number">1</span>);</span><br><span class="line">    mem[i][j] = std::<span class="built_in">min</span>(left, up) != INT_MAX ? std::<span class="built_in">min</span>(left, up) + grid[i][j] : INT_MAX;</span><br><span class="line">    <span class="keyword">return</span> mem[i][j];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="方法三：动规"><a href="#方法三：动规" class="headerlink" title="方法三：动规"></a>方法三：动规</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSumDP</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) {</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) {</span><br><span class="line">            dp[i][j] = std::<span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSumDPComp</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) {</span><br><span class="line">        dp[j] = dp[j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) {</span><br><span class="line">            dp[j] = std::<span class="built_in">min</span>(dp[j - <span class="number">1</span>], dp[j]) + grid[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><blockquote>
<p>[!question]<br>给定 &nbsp;n&nbsp; 个物品，第 &nbsp;i&nbsp; 个物品的重量为 &nbsp;wgt [i − 1]、价值为 &nbsp;val [i − 1]&nbsp;，和一个容量为 &nbsp;cap&nbsp; 的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值。</p>
</blockquote>
<blockquote>
<p>关键：状态 &nbsp;[i , c]&nbsp; 对应的子问题为：<strong>前 &nbsp;i&nbsp; 个物品在剩余容量为 &nbsp;c&nbsp; 的背包中的最大价值</strong>，记为 &nbsp;dp [i , c]&nbsp;。</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴搜</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDFS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> i, <span class="type">int</span> c)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">knapsackDFS</span>(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> no = <span class="built_in">knapsackDFS</span>(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> yes = <span class="built_in">knapsackDFS</span>(wgt, val, i - <span class="number">1</span>, c - wgt[i - <span class="number">1</span>]) + val[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(no, yes);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//记搜</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDFSMem</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mem, <span class="type">int</span> i, <span class="type">int</span> c)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (mem[i][c] != <span class="number">-1</span>) {</span><br><span class="line">        <span class="keyword">return</span> mem[i][c];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> no = <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> yes = <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c - wgt[i - <span class="number">1</span>]) + val[i - <span class="number">1</span>];</span><br><span class="line">    mem[i][c] = <span class="built_in">max</span>(no, yes);</span><br><span class="line">    <span class="keyword">return</span> mem[i][c];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//动规</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cap + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= cap; c++) {</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) {</span><br><span class="line">                dp[i][c] = dp[i - <span class="number">1</span>][c];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                dp[i][c] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][c], dp[i - <span class="number">1</span>][c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDPComp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cap + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> c = cap; c &gt;= <span class="number">1</span>; c--) {    <span class="comment">//倒序遍历</span></span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &lt;= c) {</span><br><span class="line">                dp[c] = <span class="built_in">max</span>(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[cap];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><blockquote>
<p>[!question]<br>给定 &nbsp;n&nbsp; 个物品，第 &nbsp;i&nbsp; 个物品的重量为 &nbsp;wgt [i − 1]、价值为 &nbsp;val [i − 1]&nbsp;，和一个容量为 &nbsp;cap&nbsp; 的背包。<strong>每个物品可以重复选取</strong>，问在限定背包容量下能放入物品的最大价值。</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//动规</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unboundedKnapsackDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cap + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= cap; c++) {</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) {</span><br><span class="line">                dp[i][c] = dp[i - <span class="number">1</span>][c];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                dp[i][c] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][c], dp[i][c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unboundedKnapsackDPComp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cap + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= cap; c++) {    <span class="comment">//正序遍历</span></span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) {</span><br><span class="line">                dp[c] = dp[c];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                dp[c] = <span class="built_in">max</span>(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[cap];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="完全背包问题变种"><a href="#完全背包问题变种" class="headerlink" title="完全背包问题变种"></a>完全背包问题变种</h2><h3 id="零钱兑换问题-1"><a href="#零钱兑换问题-1" class="headerlink" title="零钱兑换问题 1"></a>零钱兑换问题 1</h3><blockquote>
<p>[!question]<br>给定 &nbsp;n&nbsp; 种硬币，第 &nbsp;i&nbsp; 种硬币的面值为 &nbsp;coins [i − 1]&nbsp;，目标金额为 &nbsp;amt&nbsp;，<strong>每种硬币可以重复选取</strong>，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回 &nbsp;−1&nbsp;。</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChangeDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amt)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> MAX = amt + <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amt + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) {</span><br><span class="line">        dp[<span class="number">0</span>][a] = MAX;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) {</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) {</span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                dp[i][a] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][a], dp[i][a - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n][amt] != MAX ? dp[n][amt] : <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChangeDPComp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amt)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> MAX = amt + <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amt + <span class="number">1</span>, MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) {</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) {</span><br><span class="line">                dp[a] = dp[a];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                dp[a] = <span class="built_in">min</span>(dp[a], dp[a - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[amt] != MAX ? dp[amt] : <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="零钱兑换问题-2"><a href="#零钱兑换问题-2" class="headerlink" title="零钱兑换问题 2"></a>零钱兑换问题 2</h3><blockquote>
<p>[!question]<br>给定 &nbsp;n&nbsp; 种硬币，第 &nbsp;i&nbsp; 种硬币的面值为 &nbsp;coins [i − 1]&nbsp;，目标金额为 &nbsp;amt&nbsp;，每种硬币可以重复选取，问凑出目标金额的硬币组合数量。</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChangeIIDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amt)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amt + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) {</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) {</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) {</span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a] + dp[i][a - coins[i - <span class="number">1</span>]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n][amt];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChangeIIDPComp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amt)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amt + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) {</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) {</span><br><span class="line">                dp[a] = dp[a];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                dp[a] = dp[a] + dp[a - coins[i - <span class="number">1</span>]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[amt];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h2><blockquote>
<p>[!question]<br>输入两个字符串 &nbsp;s&nbsp; 和 &nbsp;t&nbsp;，返回将 &nbsp;s&nbsp; 转换为 &nbsp;t&nbsp; 所需的最少编辑步数。<br>你可以在一个字符串中进行三种编辑操作：插入一个字符、删除一个字符、将字符替换为任意一个字符。</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">editDistanceDP</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>(), m = t.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) {</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">editDistanceDPComp</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>(), m = t.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">        dp[j] = j;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="type">int</span> leftup = dp[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">            <span class="type">int</span> temp = dp[j];</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) {</span><br><span class="line">                dp[j] = leftup;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[j - <span class="number">1</span>], dp[j]), leftup) + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            leftup = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>DP</tag>
        <tag>背包问题</tag>
        <tag>编辑距离</tag>
      </tags>
  </entry>
  <entry>
    <title>最大流 (Maximum Flow)</title>
    <url>/2024/05/30/%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
    <content><![CDATA[<h1 id="最大流-Maximum-Flow"><a href="#最大流-Maximum-Flow" class="headerlink" title="最大流(Maximum Flow)"></a>最大流 (Maximum Flow)</h1><h2 id="流网络-Flow-networks"><a href="#流网络-Flow-networks" class="headerlink" title="流网络(Flow networks)"></a>流网络 (Flow networks)</h2><h3 id="流网络和流"><a href="#流网络和流" class="headerlink" title="流网络和流"></a>流网络和流</h3><p>流网络 $G = (V, E)$ 是一个有向带权图，权重非负，在这里称其为容量 $c (u, v) \ge 0$。我们进一步要求如果 E 包含边 (u, v), 那么 E 就不包含反向边 (v, u)。若 $(u, v)\not \in E$, 方便起见，我们定义 c (u, v) = 0, 同时不允许自环。每一个流网络包含两个特殊顶点：源点 s 和汇点 t, 这个汇点在基本图论中的习题中已接触过，当时是求一个图是否有全局汇点，这里的汇点意思没变，还是出度为 0。为了方便，我们假设每一个顶点都位于从 s 到 t 的某条路径上。因为除了 s 外的顶点都至少有一条入边，因此有 $|E| \ge |V| - 1$。<br>接着对流进行正式的定义：<br>已知流网络 $G=(V,E)$，c 是容量函数，s 是源点，t 是汇点，那么在 G 中的一个流是一个实值函数 $f:V \times V \to R$，其满足下面两条性质：</p>
<ul>
<li><strong>容量限制</strong>：$0 \le f(u, v) \le c(u, v)$</li>
<li><strong> 流量守恒</strong>：对于所有的顶点 $u \in V - {s, t}$，我们要求<br>$$<br>\sum_{v \in V}f(v,u) = \sum_{v \in V}f(u, v)<br>$$<br>即除了源点和汇点，流入一个顶点的总流量等于流出该顶点的总流量，就是流入等于流出。这跟基尔霍夫电流定律特性一样。<br>我们称非负数值 f (u, v) 为从顶点 u 到 v 的流，一个流 f 的值 | f | 定义如下：<br>$$<br>|f|=\sum_{v \in V}f(s, v)-\sum_{v \in V}f(v,s)<br>$$<br>即从源点流出的总流量减去流入源点的总能量。通常，一个流网络的源点是没有入边的，因此 $\sum_{v\in V} f (v, s)$ 为 0，那么存在即合理，这里定义包含它是因为后面讲到残差网络 or 剩余网络 or 其它翻译 (residual networks)，那时 $\sum_{v\in V} f (v, s)&gt;0$ 是可以的。<br>最大流问题就是求 $|f|$ 的最大值。<br>下面是流网络的一个例子：<br><img src="https://telegraph-image-eja.pages.dev/file/0ea4104cb216c143ad4c8.png" alt="image"><br>(b) 中的边都有两个数值，左边的数值代表流量，右边的数值代表容量，以顶点 $v_3$ 为例，流入 $v_3$ 的总流量为 $12+7=19$，流出 $v_3$ 的总流量为 $15+4=19$，可见流入等于流出。</li>
</ul>
<h3 id="反向平行边"><a href="#反向平行边" class="headerlink" title="反向平行边"></a>反向平行边</h3><p>假设在上面图的基础上加多一条边，如图，该网络产生了一个问题，它违反了最上面的要求：如果 E 包含边 (u, v)，那么 E 就不包含反向边 (v, u)，我们称边 $(v_1,v_2)$ 和边 $(v_2,v_1)$ 互为反平行。<br><img src="https://telegraph-image-eja.pages.dev/file/06cc45f7a370a6c63456c.png" alt="image"><br>因此，我们需要将有问题的网络等价转换为不包含反向平行边的网络，正如图 (b) 所示，我们可以从两条反向平行边任选其一，然后通过添加一个新顶点 $v’$ 把原来的边 $(v_1,v_2)$ 分解成两条边，并且新的两条边的容量都设为原来边 $(v_1,v_2)$ 的容量。</p>
<h3 id="多源点多汇点网络"><a href="#多源点多汇点网络" class="headerlink" title="多源点多汇点网络"></a>多源点多汇点网络</h3><p><img src="https://telegraph-image-eja.pages.dev/file/d8a054ff24bd0feaff874.png" alt="image"><br>该图告诉我们如何将一个多源点多汇点网络转换成一个普通网络，s 为超级源点，t 为超级汇点。</p>
<h2 id="Ford-Fulkerson-方法"><a href="#Ford-Fulkerson-方法" class="headerlink" title="Ford-Fulkerson 方法"></a>Ford-Fulkerson 方法</h2><p>这里称作方法而不是算法是因为它包含几种运行时间不同的算法实现，以下简称 FF 方法。<br>FF 方法迭代增加流的值，一开始，对于所有的顶点对 u, v 都有 f (u, v) = 0，因此初始流值为 0。在每一次迭代中，通过在关联的残差网络 $G_f$ 中找一条增广路径 (augmenting path)，找出其在 G 中对应的边，接着更新这些边的流量，从而增加流的值。<br>尽管每一次迭代都增加了流的值，但对于 G 中的某条特定的边，其流量可能增加也可能减少。减少这个情况看上去有点违反直觉，但是实际情况却是会让其它边上的流量增加，使得从 s 到 t 的流最大化。伪代码如下：<br><img src="https://telegraph-image-eja.pages.dev/file/ded556038695346235b68.png" alt="image"></p>
<h3 id="残差网络-Residual-networks"><a href="#残差网络-Residual-networks" class="headerlink" title="残差网络(Residual networks)"></a>残差网络 (Residual networks)</h3><p>前面已两次提到残差网络，现在正式介绍。<br>字面来看，残差或者剩余就是剩下的意思，那么流网络中有啥是剩下的呢，那就是容量了，前面规定流量要小于或等于容量，小于的时候不就有剩下的容量吗，而等于的时候就没有剩下的了，因此 G 中流量等于容量的边不属于 $G_f$。残差网络也有容量，就称为残差容量，公式为 $c_f (u,v) = c (u,v) - f (u,v)$。<br>你可能会感到惊讶，残差网络 $G_f$ 还可能包含 G 中没有的边。前面提到算法可能会减少某条特定的边的流量，那么为了表示 G 中一条边 (u, v) 上的正流量可能的减少，我们在 $G_f$ 中添加一条边 (v, u)，并且 $c_f (v,u)=f (u,v)$，</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>汉明数 (Hamming Numbers)</title>
    <url>/2024/05/27/hamming-numbers-%E6%B1%89%E6%98%8E%E6%95%B0/</url>
    <content><![CDATA[<h1 id="codewars-汉明数"><a href="#codewars-汉明数" class="headerlink" title="codewars-汉明数"></a>codewars - 汉明数</h1><p><a href="https://www.codewars.com/kata/526d84b98f428f14a60008da/">codewars 传送门</a></p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>汉明数是形如 $2^i3^j5^k$ 的正整数，<code>i, j, k</code> 是非负整数，题目要求写一个函数计算出第 n 个最小汉明数<br>特别地：</p>
<ul>
<li>第一个最小汉明数是 $1 = 2^03^05^0$</li>
<li> 第二个最小汉明数是 $2 = 2^13^05^0$</li>
<li> 第三个最小汉明数是 $3 = 2^03^15^0$</li>
<li> 第四个最小汉明数是 $4 = 2^23^05^0$</li>
<li> 第五个最小汉明数是 $5 = 2^03^05^1$</li>
<li> 第六个最小汉明数是 $6 = 2^13^15^0$<br>首先容易想到的就是暴力解法咯，套三层循环，同时也容易想到必定超时，因此需要设计。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>第一个问题我觉得就是要考虑汉明数是用数组存着每一个最小汉明数，还是用一个变量存着然后一直更新变量的值。通过观察发现每一个最小汉明数都是由前面的某一个最小汉明数进行乘 2 或乘 3 或乘 5 得到的，因而可以知道的是每一个最小汉明数都得存起来，排除了只用一个变量存储的可能。</p>
<p>现在就得想如何知道进行什么操作才能做到每一次都是最小的。首先，我们先假设现在前面已经有若干个最小汉明数存着了，现在要求第 n 个，这第 n 个最小汉明数是由 2 或 3 或 5 乘以前面某一个最小汉明数得到，这里有两个未知的量，因此我们先假设某个量是定的，比如假设要进行的是乘 2 操作，接下来就要从前面的最小汉明数中找一个与之相乘，使其乘积最小，那么很显然，我们要找的那个最小汉明数肯定是越前越好，所以就引出关键问题了，我们得知道前面的最小汉明数有没有被用过，或者说有没有被乘 2 这个操作用过，被用过的话就代表着在第 n 个前面肯定是有一个最小汉明数是对其进行乘 2 操作得到的，因此第 n 个就得在后面找第一个没有被用过的，因此我们需要东西去记录用过的汉明数，不难发现只用一个标记就够了，通过右移来更新标记，在标记前面的最小汉明数都是被用过的。因为前面假设的是乘 2 操作，那么乘 3 或乘 5 是同样的情况，所以需要三个标记去记录，这里把标记记为 <code>i, j, k</code> 分别代表着 2，3，5 ，这里的标记其实就是最小汉明数数组的索引，注意此 <code>ijk</code> 跟题目定义的 <code>ijk</code> 不是一个东西，切勿混淆。</p>
<p>下一步就得考虑一下初始状态了，存储最小汉明数的数组初始化首先得搞个数字存进去吧，那么是存 0 好呢还是把第一个最小汉明数丢进去呢。假设先存个 0，那么 <code>i, j, k</code> 初始化都得是 0，毕竟数组里暂时只有 0 这个索引有数字，那么第一个最小汉明数按上面的操作的话就求不出来了，因为 0 乘任何数都是 0。假设先存个 1，然后从第二个最小汉明数开始按照上面分析的操作进行，2,3,5 分别乘 1，得出 2 最小，接着把 2 加在最小汉明数数组中，然后还得更新 2 所对应的 i 标记右移一个单位，这时 <code>i == 1</code>，此时 i 指向的是数组中索引为 1 的数，即 2，其它两个标记还是 0，为了验证并理解，再举两个例子推演。下面到第三个最小汉明数，为了方便叙述，我把数组实际化为 nums，那么第三个最小汉明数就要在 $nums [i] * 2=4$ ，$nums [j]*3=3$，$nums [k]*5=5$ 中的最小值取得，即是中间的 3，把它加入到 nums 中，并把 j 右移一位，现在 i 和 j 都是 1，k 是 0,。接着第四个最小汉明数就要从 $nums [i] * 2=4$ ，$nums [j]*3=6$，$nums [k]*5=5$ 中取得，即是 4，把 4 加入到 nums，i 再次右移一位，后面的同理。</p>
<p>可能说的还是有点模糊，下面用一张图来进行具象化：<br><img src="https://telegraph-image-eja.pages.dev/file/12bb4c8ae58643b244279.jpg" alt="image"><br>那就直接上代码</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hamming</span>(<span class="params">n</span>):</span><br><span class="line">    i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    nums = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(nums) &lt; n:</span><br><span class="line">        nums.append(<span class="built_in">min</span>(nums[i]*<span class="number">2</span>, nums[j]*<span class="number">3</span>, nums[k]*<span class="number">5</span>))</span><br><span class="line">        <span class="keyword">if</span> nums[-<span class="number">1</span>] == nums[i]*<span class="number">2</span>: i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[-<span class="number">1</span>] == nums[j]*<span class="number">3</span>: j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[-<span class="number">1</span>] == nums[k]*<span class="number">5</span>: k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums[-<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>没想到做完两题就直接从 8kyu 到 6kyu 了</p>
]]></content>
      <categories>
        <category>codewars</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
</search>
