<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cpp 智能指针与 lambda 表达式</title>
    <url>/2024/09/28/Cpp-Smart-Pointer/</url>
    <content><![CDATA[<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">[OuterVar](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> {</span><br><span class="line">	<span class="keyword">return</span> OuterVar + x + y;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> {</span><br><span class="line">	<span class="keyword">return</span>  + B;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//返回类型 -&gt; int 可以省略，编译器会自行推断其类型</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="变量捕获-Capture-clause"><a href="#变量捕获-Capture-clause" class="headerlink" title="变量捕获(Capture clause)"></a>变量捕获 (Capture clause)</h3><p>特殊：<code>[&amp;] [=] [&amp;, =N]</code><br>可以在捕获语句中定义新的变量并初始化：<code>[n, &amp;m, k = 4]</code><br>还支持 <code>[](auto a, auto b) { return a + b }</code></p>
<h2 id="共享指针-shared-ptr"><a href="#共享指针-shared-ptr" class="headerlink" title="共享指针(shared_ptr)"></a>共享指针 (shared_ptr)</h2><p>首先 <code>include &lt;memory&gt;</code></p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; p {new int(100)};</span><br><span class="line">shared_ptr&lt;int&gt; p {make_shared&lt;int&gt;(100)};//效率更高更安全</span><br></pre></td></tr></tbody></table></figure>

<h3 id="自动管理内存"><a href="#自动管理内存" class="headerlink" title="自动管理内存"></a>自动管理内存</h3><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>指向某个 item 的共享指针个数，当这个 item 的引用计数为 0 时，程序就会自动释放这个 item。<br>考虑一下这种情况：当你函数参数必须要传一个裸指针时，你使用 <code>T* rp = p.get()</code> 来获取，其中 p 是共享指针。<br>如果有一块资源，同时有裸指针和共享指针指向它，当所有共享指针被摧毁，但是裸指针仍然存在时，这块资源仍然会被释放，这个时候再用裸指针去访问那块资源就会发生未定义行为，因此，用共享指针的时候最好避免跟裸指针混用。</p>
<h4 id="杂识"><a href="#杂识" class="headerlink" title="杂识"></a>杂识</h4><ul>
<li>我们常见的 <code>p.reset()</code> 是无参时释放，<code>reset</code> 其实还可以接受参数 <code>eg:p.reset(new T)</code>，那么旧的 item T 的引用计数减 1，p 则指向新的 T。</li>
<li>默认情况下共享指针使用 <code>delete</code> 释放资源，但是你也可以自定义删除函数，例如：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_file</span><span class="params">(FILE* fp)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">	cout &lt;&lt; <span class="string">"File closed."</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mian</span><span class="params">()</span> </span>{</span><br><span class="line">	FILE* fp = <span class="built_in">fopen</span>(<span class="string">"data.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">	shared_ptr&lt;FILE&gt; sfp {fp, close_file};</span><br><span class="line">	<span class="keyword">if</span> (sfp == <span class="literal">nullptr</span>)</span><br><span class="line">		cerr &lt;&lt; <span class="string">"Error opening file."</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">"File opened."</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>别名 (Aliasing)：<br>下面代码 <code>b</code> 的命名就是别名，注意到 <code>f</code> 指向的 item 的引用计数加了 1，那么意味着只要 <code>b</code> 还在，<code>f</code> 指向的资源就不会被删除。但是这里 <code>b</code> 的数据指针指向的是 <code>bar</code>(代码最后一行也能看出)，仅是 <code>f</code> 的一个成员，通常这个技巧用于访问类的成员变量，我们希望在访问实例的成员时，不希望实例本身被删除。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span> { <span class="type">int</span> i = <span class="number">123</span>; };</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> { Bar bar; };</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	shared_ptr&lt;Foo&gt; f = <span class="built_in">make_shared</span>&lt;Foo&gt;();</span><br><span class="line">	cout &lt;&lt; f.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// prints 1</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Bar&gt; <span class="title">b</span><span class="params">(f, &amp;(f-&gt;bar))</span></span>;</span><br><span class="line">	cout &lt;&lt; f.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// prints 2</span></span><br><span class="line">	cout &lt;&lt; b-&gt;i &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>Undefined Behavior<ul>
<li> 手动 delete</li>
</ul>
</li>
<li> 额外性能开销</li>
</ul>
<h2 id="独享指针-unique-ptr"><a href="#独享指针-unique-ptr" class="headerlink" title="独享指针(unique_ptr)"></a>独享指针 (unique_ptr)</h2><blockquote>
<p>零开销，不能有两个独享指针同时指向同一块资源，当独享指针被销毁，其绑定的资源就会自动释放。</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>{</span><br><span class="line">	Object* p = <span class="keyword">new</span> Object;</span><br><span class="line">	p-&gt;<span class="built_in">foo</span>();</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>{</span><br><span class="line">	unique_ptr&lt;Object&gt; up { <span class="built_in">make_unique</span>&lt;Object&gt;() };</span><br><span class="line">	up-&gt;<span class="built_in">foo</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>考虑 <code>func1</code>，可能会发生内存泄漏，比如如果 <code>p-&gt;foo()</code> 抛出异常，<code>delete p</code> 就不会被执行，从而造成内存泄漏。而 <code>func2</code> 就不用担心这个问题，即便抛出异常，资源最后也会释放。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">up.<span class="built_in">reset</span>(); <span class="comment">//释放up下的资源，把up设置为nullptr</span></span><br><span class="line">up.<span class="built_in">reset</span>(<span class="keyword">new</span> Object{}); <span class="comment">//释放的同时指向另外一份资源</span></span><br><span class="line"></span><br><span class="line">Object* object = up.<span class="built_in">release</span>(); <span class="comment">//把up和资源解绑，返回资源的裸指针，同时把up设置为nullptr</span></span><br><span class="line">up = <span class="literal">nullptr</span>; <span class="comment">//也会释放up下的资源</span></span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up2</span><span class="params">(up1)</span></span>; <span class="comment">//error</span></span><br><span class="line">up2 = up1; <span class="comment">//error</span></span><br><span class="line"><span class="comment">//这两行会报错是因为unique_ptr独占一段内存的控制权</span></span><br><span class="line"><span class="comment">//我们不能复制控制权，但是可以转移控制权，如下：</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; up1 = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up2</span><span class="params">(up1.release())</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; up2 = <span class="built_in">move</span>(up1); <span class="comment">//与上句相同的转移效果</span></span><br></pre></td></tr></tbody></table></figure>

<p>独享指针也可以自定义删除函数，但是比共享指针复杂：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">my_alloc</span><span class="params">(<span class="type">int</span> v)</span> </span>{}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_dealloc</span><span class="params">(<span class="type">int</span> *p)</span> </span>{}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	unique_ptr&lt;<span class="type">int</span>, <span class="keyword">decltype</span>(&amp;my_dealloc)&gt; cup {<span class="built_in">my_alloc</span>(<span class="number">100</span>), my_dealloc};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>复杂性是由于独享指针绑定释放函数在编译期，避免了运行时绑定的时间损耗，这与其零开销特性有关；而共享指针在运行时绑定，由于共享指针在引用计数上的性能开销，那么再增加一点也就无所谓了。</p>
<p>由于 <code>unique_ptr</code> 禁止复制操作，因此在函数间传递的时候需要注意方法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_up</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; up)</span> </span>{}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_up1</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>{}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_up2</span><span class="params">(<span class="type">int</span>* p)</span> </span>{}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_up3</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt;&amp; up)</span> </span>{}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_up4</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; up)</span> </span>{}</span><br><span class="line"><span class="comment">//返回up</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">return_uptr</span><span class="params">(<span class="type">int</span> value)</span> </span>{</span><br><span class="line">	unique_ptr&lt;<span class="type">int</span>&gt; up = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(value);</span><br><span class="line">	<span class="keyword">return</span> up;</span><br><span class="line">	<span class="comment">//return move(up);</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mian</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">auto</span> up = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">123</span>);</span><br><span class="line">	<span class="built_in">pass_up</span>(up); <span class="comment">//编译错误</span></span><br><span class="line">	<span class="built_in">pass_up1</span>(*up);</span><br><span class="line">	<span class="built_in">pass_up2</span>(up.<span class="built_in">get</span>());</span><br><span class="line">	<span class="comment">//改变up本身</span></span><br><span class="line">	<span class="built_in">pass_up3</span>(up);</span><br><span class="line">	<span class="built_in">pass_up4</span>(<span class="built_in">move</span>(up));</span><br><span class="line">	unique_ptr&lt;<span class="type">int</span>&gt; up = <span class="built_in">return_uptr</span>(<span class="number">321</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="弱指针-weak-ptr"><a href="#弱指针-weak-ptr" class="headerlink" title="弱指针(weak_ptr)"></a>弱指针 (weak_ptr)</h2><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>weak_ptr 是一种伴随着 shared_ptr 而生的智能指针，它可以建模对象的临时管理权，可以用来解决环形依赖的问题。<br>在不想额外控制资源，但又想检查资源是否存在的时候，可以用弱指针。</p>
<ul>
<li><code>std::weak_ptr</code> 不增加引用计数，不会参与对象生命周期的管理。</li>
<li>它只是一种弱引用，不影响 <code>shared_ptr</code> 的引用计数。</li>
<li>只有当我们需要访问对象时，可以通过 <code>weak_ptr.lock()</code> 临时获取一个 <code>shared_ptr</code>，以确保对象没有被销毁。</li>
</ul>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><h4 id="环形依赖"><a href="#环形依赖" class="headerlink" title="环形依赖"></a>环形依赖</h4><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; bPtr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; aPtr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;bPtr = b;</span><br><span class="line">    b-&gt;aPtr = a;</span><br><span class="line">    <span class="comment">// 到此，a 和 b 都超出了作用域，但它们无法被释放，因为存在环形引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，两个对象间形成了一个<strong>循环引用</strong>：</p>
<ol>
<li><code>a</code> 持有 <code>b</code> 的 <code>shared_ptr</code>，<code>b</code> 的引用计数增加到 2。</li>
<li><code>b</code> 持有 <code>a</code> 的 <code>shared_ptr</code>，<code>a</code> 的引用计数也增加到 2。<br>当 <code>main</code> 函数结束时，<code>a</code> 和 <code>b</code> 超出了作用域，<code>shared_ptr</code> 应该开始析构。然而：</li>
</ol>
<ul>
<li>当 <code>a</code> 超出作用域时，<code>a</code> 的 <code>shared_ptr</code> 会被销毁，<code>a</code> 的引用计数减 1，变为 1（因为 <code>b</code> 还持有 <code>a</code> 的 <code>shared_ptr</code>）。</li>
<li>同样地，当 <code>b</code> 超出作用域时，<code>b</code> 的引用计数减 1，变为 1（因为 <code>a</code> 还持有 <code>b</code> 的 <code>shared_ptr</code>）。<br>结果是：</li>
<li><code>a</code> 和 <code>b</code> 都无法被销毁，因为它们的引用计数都不是 0。</li>
<li><strong>循环引用</strong>导致它们的引用计数永远不会归零，内存无法释放，形成了<strong>内存泄漏</strong>。</li>
</ul>
<h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::weak_ptr&lt;A&gt; aPtr; <span class="comment">// B 持有 A 的 weak_ptr</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>解决方案</strong>：通过使用 <code>std::weak_ptr</code> 打破其中一个引用链，不再增加引用计数，从而避免循环引用的发生，确保对象能够被正常释放。<br><strong>分析</strong>：</p>
<ol>
<li>**<code>a</code> 持有 <code>b</code> 的 <code>shared_ptr</code>**：当 <code>a</code> 对象持有 <code>b</code> 的 <code>shared_ptr</code> 时，<code>b</code> 的引用计数从 1 增加到 2，因为 <code>a-&gt;bPtr</code> 是一个 <code>shared_ptr</code>。</li>
<li><strong><code>b</code> 持有 <code>a</code> 的 <code>weak_ptr</code><strong>：<code>b</code> 持有的 <code>a-&gt;aPtr</code> 是一个 <code>weak_ptr</code>，</strong>不会增加 <code>a</code> 的引用计数</strong>，因此 <code>a</code> 的引用计数保持为 1。<br><strong>结束时的析构行为</strong>：</li>
</ol>
<ul>
<li><strong>当 <code>a</code> 超出作用域时</strong>：<ul>
<li><code>a</code> 的 <code>shared_ptr</code> 被销毁，<code>a</code> 的引用计数减少 1，变为 0，因为此时没有其他 <code>shared_ptr</code> 指向 <code>a</code>。</li>
<li>由于 <code>a</code> 的引用计数归零，<code>a</code> 对象被销毁，<code>a</code> 持有的 <code>bPtr</code> 也被销毁，<code>b</code> 的引用计数减 1，变为 1。</li>
</ul>
</li>
<li><strong>当 <code>b</code> 超出作用域时</strong>：<ul>
<li><code>b</code> 的 <code>shared_ptr</code> 被销毁，<code>b</code> 的引用计数减 1，变为 0，因为此时没有其他 <code>shared_ptr</code> 指向 <code>b</code>。</li>
<li>由于 <code>b</code> 的引用计数归零，<code>b</code> 对象也被销毁。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>智能指针</tag>
        <tag>lambda</tag>
        <tag>编程</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Elementary Graph Algorithms</title>
    <url>/2024/04/21/Elementary-Graph-Algorithms/</url>
    <content><![CDATA[<h1 id="Elementary-Graph-Algorithms"><a href="#Elementary-Graph-Algorithms" class="headerlink" title="Elementary Graph Algorithms"></a>Elementary Graph Algorithms</h1><h2 id="Representations-of-graphs"><a href="#Representations-of-graphs" class="headerlink" title="Representations of graphs"></a>Representations of graphs</h2><p>$$<br>G = (V, E)<br>$$</p>
<p>$G \to Graph, V \to Vertex, E \to Edge$, 式子说明图是由顶点和边这两个元素组成，那么只要把顶点和边表示出来，图就表示出来了。其中有两种方法，一种是邻接表表示，一种是用矩阵表示，根据不同的情景需要会选取不同的表示方法。</p>
<h3 id="adjacency-list"><a href="#adjacency-list" class="headerlink" title="adjacency-list"></a>adjacency-list</h3><p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_list.png" alt="list"><br>// 邻接表可用链表，也可用哈希表</p>
<blockquote>
<p>If $G$ is a directed graph, the sum of the lengths of all the adjacency lists is |E|.<br>If $G$ is an undirected graph, the sum of the lengths of all the adjacency lists is 2|E|.</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//下面是无向图的示例，有向图需要修改部分method代码</span></span><br><span class="line"><span class="comment">//为了方便添加与删除顶点，以及简化代码，这里使用列表（动态数组）来代替链表。</span></span><br><span class="line"><span class="comment">//使用哈希表来存储邻接表，key为顶点实例，value为该顶点的邻接顶点列表（链表）。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="type">int</span> value) : <span class="built_in">val</span>(value) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjList</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::unordered_map&lt;Vertex *, std::vector&lt;Vertex *&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(std::vector&lt;Vertex *&gt; &amp;vec, Vertex *vet)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (vec[i] == vet) {</span><br><span class="line">                vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GraphAdjList</span>(<span class="type">const</span> std::vector&lt;std::vector&lt;Vertex *&gt;&gt; &amp;edges) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> std::vector&lt;Vertex *&gt; &amp;edge : edges) {</span><br><span class="line">            <span class="built_in">addVertex</span>(edge[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">addVertex</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">addEdge</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> adjList.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(Vertex *vet1, Vertex *vet2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1 == vet2)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">"不存在顶点"</span>);</span><br><span class="line">        adjList[vet1].<span class="built_in">push_back</span>(vet2);</span><br><span class="line">        adjList[vet2].<span class="built_in">push_back</span>(vet1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(Vertex *vet1, Vertex *vet2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1 == vet2)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">"不存在顶点"</span>);</span><br><span class="line">        <span class="built_in">remove</span>(adjList[vet1], vet2);</span><br><span class="line">        <span class="built_in">remove</span>(adjList[vet2], vet1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(Vertex *vet)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        adjList[vet] = std::<span class="built_in">vector</span>&lt;Vertex *&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(Vertex *vet)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">"不存在顶点"</span>);</span><br><span class="line">        adjList.<span class="built_in">erase</span>(vet);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;adj : adjList) {</span><br><span class="line">            <span class="built_in">remove</span>(adj.second, vet);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"邻接表 ="</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;adj : adjList) {</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> &amp;key = adj.first;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> &amp;vec = adj.second;</span><br><span class="line">            std::cout &lt;&lt; key-&gt;val &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="built_in">printVector</span>(<span class="built_in">vetsToVals</span>(vec));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vetsToVals</span><span class="params">(<span class="type">const</span> std::vector&lt;Vertex *&gt; &amp;vec)</span> </span>{</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> Vertex *vet : vec) {</span><br><span class="line">            vals.<span class="built_in">push_back</span>(vet-&gt;val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vals;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vec) {</span><br><span class="line">            std::cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h4><blockquote>
<p>加权图即边是有权值的，可添加 Edge 类来实现</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Vertex *destination;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	<span class="built_in">Edge</span>(Vertex *dest, <span class="type">int</span> w) : <span class="built_in">destination</span>(dest), <span class="built_in">weight</span>(w) {}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> val; <span class="comment">// 顶点的值</span></span><br><span class="line">	std::vector&lt;Edge*&gt; adjList; <span class="comment">// 邻接列表</span></span><br><span class="line">	<span class="built_in">Vertex</span>(<span class="type">int</span> v) : <span class="built_in">val</span>(v) {}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>The adjacency-list representation is quite robust in that you can modify it to support many other graph variants.<br>// 上方的代码顶点都是唯一的实例，还可以往其添加属性，这就体现了邻接表的灵活性，加上它的动态性以及内存效率等的优势，共同构建了其健壮性，使其能够支持很多其它的图变体。</p>
</blockquote>
<blockquote>
<p>邻接表查询边的存在性较慢，邻接矩阵表示较快</p>
</blockquote>
<h3 id="adjacency-matrix"><a href="#adjacency-matrix" class="headerlink" title="adjacency-matrix"></a>adjacency-matrix</h3><p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_matrix.png" alt="matrix"></p>
<blockquote>
<p>in an undirected graph, the adjacency matrix A of an undirected graph is its own transpose: $A = A^T$<br>// 正是因为有这一性质，在一些应用中，只选择存储对角线以上的元素来提高内存效率。</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjMat</span> {</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vertices;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; adjMat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphAdjMat</span>(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vertices, <span class="type">const</span> std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vertices) {</span><br><span class="line">            <span class="built_in">addVertex</span>(val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;edge : edges) {</span><br><span class="line">            <span class="built_in">addEdge</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> vertices.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">size</span>();</span><br><span class="line">        vertices.<span class="built_in">push_back</span>(val);</span><br><span class="line">        adjMat.<span class="built_in">emplace_back</span>(std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt; &amp;row : adjMat) {</span><br><span class="line">            row.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"顶点不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">        vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + index);</span><br><span class="line">        adjMat.<span class="built_in">erase</span>(adjMat.<span class="built_in">begin</span>() + index);</span><br><span class="line">        <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt; &amp;row : adjMat) {</span><br><span class="line">            row.<span class="built_in">erase</span>(row.<span class="built_in">begin</span>() + index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= <span class="built_in">size</span>() || j &gt;= <span class="built_in">size</span>() || i == j) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"顶点不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">        adjMat[i][j] = <span class="number">1</span>;</span><br><span class="line">        adjMat[j][i] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= <span class="built_in">size</span>() || j &gt;= <span class="built_in">size</span>() || i == j) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"顶点不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">        adjMat[i][j] = <span class="number">0</span>;</span><br><span class="line">        adjMat[j][i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"顶点列表 = "</span>;</span><br><span class="line">        <span class="built_in">printVector</span>(vertices);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"邻接矩阵 ="</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">printVectorMatrix</span>(adjMat);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vec) {</span><br><span class="line">            std::cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVectorMatrix</span><span class="params">(<span class="type">const</span> std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;row : matrix) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> val : row) {</span><br><span class="line">                std::cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            }</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>邻接矩阵也可表示有权图，但空间浪费明显，无论稀疏还是密集：<br>在稀疏图中，尽管边的数量很少，但邻接矩阵仍然需要为每个可能的顶点对（即矩阵中的每个元素）分配空间。大多数这些顶点对之间实际上是没有边的，因此这些空间是浪费的。<br>在密集图中，虽然边的数量很多，但邻接矩阵仍然需要为每个顶点对分配空间，即使某些顶点对之间可能有多个边。例如，如果图中有两个顶点之间有 5 条边，邻接矩阵中的对应元素就需要存储这 5 条边的权重信息，而实际上只需要存储一个权重信息就足够了。</p>
</blockquote>
<blockquote>
<p>图规模较小时倾向于使用邻接矩阵</p>
</blockquote>
<h3 id="效率对比"><a href="#效率对比" class="headerlink" title="效率对比"></a>效率对比</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">adjacency-matrix</th>
<th align="center">adjacency-list(ll)</th>
<th align="center">adjacency-list(hash)</th>
</tr>
</thead>
<tbody><tr>
<td align="center"> 边的存在性</td>
<td align="center"> $O(1)$</td>
<td align="center">$O(E)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center"> 添加边</td>
<td align="center"> $O(1)$</td>
<td align="center">$O(1)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center"> 删除边</td>
<td align="center"> $O(1)$</td>
<td align="center">$O(E)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center"> 添加顶点</td>
<td align="center"> $O(V)$</td>
<td align="center">$O(1)$</td>
<td align="center">$O(1)$</td>
</tr>
<tr>
<td align="center"> 删除顶点</td>
<td align="center"> $O(V^2)$</td>
<td align="center">$O(V+E)$</td>
<td align="center">$O(V)$</td>
</tr>
<tr>
<td align="center"> 内存空间占用</td>
<td align="center"> $O(V^2)$</td>
<td align="center">$O(V+E)$</td>
<td align="center">$O(V+E)$</td>
</tr>
</tbody></table>
<h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><div class="callout question">
  Given an adjacency-list representation of a directed graph, how long does it take
  to compute the out-degree of every vertex? How long does it take to compute the
  in-degrees?
</div>
   
<blockquote>
<p>题目是求基于邻接表表示的有向图，计算每个顶点的出度，入度的时间复杂度分别是多少。<br>   顶点的出度很容易，每个顶点的邻接表存储的就是其指向的顶点，故直接计算每个顶点的邻接表<br>   长度即为其出度，可知要遍历整个图，因此时间复杂度为 O (V+E)。<br>顶点的入度的话，邻接表里存储的每个顶点都是被指向的顶点，也就是说在邻接表里的顶点每出现一次就表明其被指向一次，即入度 + 1，因此时间复杂度也为 O (V+E)。</p>
</blockquote>
<div class="callout question">
  The transpose of a directed graph $G = (V, E)$ is the graph $G^T = (V, E^T)$, where $E^T = \{(v, u) \in V \times V : (u, v) \in E\}$. That is, $G^T$ is $G$ with all its edges reversed.
   Describe efficient algorithms for computing $G^T$ from $G$, for both the adjacency-
   list and adjacency-matrix representations of $G$. Analyze the running times of your
   algorithms.
</div>

<blockquote>
<p>这题说的是有向图的转置，即把边的方向都反过来，描述计算 $G^T$ 的算法。<br>伪代码如下</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">transposeAdjList</span><span class="params">(G)</span>:  //时间复杂度：O(V+E)</span></span><br><span class="line"><span class="function">    GT =</span> empty adjacency list <span class="keyword">for</span> each vertex in G</span><br><span class="line">    <span class="keyword">for</span> each vertex u in G:</span><br><span class="line">        <span class="keyword">for</span> each vertex v in adjacency list of u:</span><br><span class="line">            <span class="function">add u to adjacency list of v in GT</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> GT</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">function <span class="title">transposeAdjMatrix</span><span class="params">(G)</span>:  //时间复杂度：O(V^<span class="number">2</span>)</span></span><br><span class="line"><span class="function">    GT =</span> empty matrix of same size as G</span><br><span class="line">    <span class="keyword">for</span> each vertex u in G:</span><br><span class="line">        <span class="keyword">for</span> each vertex v in G:</span><br><span class="line">            <span class="keyword">if</span> G[u][v] == <span class="number">1</span>:</span><br><span class="line">                GT[v][u] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> GT</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>equivalent undirected graph 等效无向图</p>
</blockquote>
<blockquote>
<p>大概就是保留原有向图所有顶点，边的方向被忽略，不包含任何自环</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">convertToUndirectedGraph</span><span class="params">(G)</span>:</span></span><br><span class="line"><span class="function">    G0 =</span> <span class="keyword">new</span> adjacency list <span class="keyword">for</span> each vertex in G</span><br><span class="line">    <span class="keyword">for</span> each vertex u in G:</span><br><span class="line">        <span class="keyword">for</span> each vertex v in adjacency list of u:</span><br><span class="line">            <span class="keyword">if</span> u ≠ v <span class="built_in">and</span> (u, v) <span class="keyword">not</span> in G0 <span class="built_in">and</span> (v, u) <span class="keyword">not</span> in G0:<span class="comment">//忽略方向</span></span><br><span class="line">                <span class="built_in">add</span> (u, v) to G0</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> u = v:<span class="comment">//排除自环</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> G0</span><br></pre></td></tr></tbody></table></figure>

<div class="callout question">
  The square of a directed graph $G = (V, E)$ is the graph $G^2 = (V, E)$ such that
   $(u, v) \in E^2$ if and only if $G$ contains a path with at most two edges between
   u and v. Describe efficient algorithms for computing $G^2$ from $G$ for both the
   adjacency-list and adjacency-matrix representations of $G$. Analyze the running
   times of your algorithms.
</div>

<p>// 这题提出了平方有向图的定义，就是边 (u, v) 在 $G^2$ 中当且仅当在 $G$ 中包含了 $u \to v$ 不超过两条边的路径，换句话说，$G^2$ 包含了 $G$ 中所有顶点对之间长度不超过 2 的路径，要求描述计算 $G^2$ 的算法。(原图中有自环的话平方图也会有，如果想排除自环就添加控制条件约束即可)</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度：O(|V|^2+|V|E).</span></span><br><span class="line"><span class="function">Algorithm <span class="title">computeSquareAdjList</span><span class="params">(G)</span>:</span></span><br><span class="line"><span class="function">    // Initialize the adjacency list for the square graph G^<span class="number">2</span></span></span><br><span class="line"><span class="function">    G2 =</span> empty adjacency list <span class="keyword">for</span> each node in V</span><br><span class="line">    <span class="comment">// Iterate over each node u in the graph</span></span><br><span class="line">    <span class="keyword">for</span> each u in V:</span><br><span class="line">        <span class="comment">// Set of nodes reachable from u within one step</span></span><br><span class="line">        direct_neighbors = <span class="built_in">set</span>(G[u])</span><br><span class="line">        <span class="comment">// Set of nodes reachable from u within two steps</span></span><br><span class="line">        two_step_neighbors = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment">// Iterate over each direct neighbor v of u</span></span><br><span class="line">        <span class="keyword">for</span> each v in direct_neighbors:</span><br><span class="line">            <span class="comment">// Add direct neighbors to G^2</span></span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> in G2[u]:</span><br><span class="line">                G2[u].<span class="built_in">append</span>(v)</span><br><span class="line">            <span class="comment">// Iterate over each neighbor w of v</span></span><br><span class="line">            <span class="keyword">for</span> each w in G[v]:</span><br><span class="line">                <span class="comment">// Add w as a two-step neighbor of u if not already added</span></span><br><span class="line">                <span class="keyword">if</span> w != u <span class="keyword">and</span> w <span class="keyword">not</span> in direct_neighbors <span class="keyword">and</span> w <span class="keyword">not</span> in two_step_neighbors:</span><br><span class="line">                    two_step_neighbors.<span class="built_in">add</span>(w)</span><br><span class="line">                    G2[u].<span class="built_in">append</span>(w)</span><br><span class="line">    <span class="keyword">return</span> G2</span><br><span class="line"><span class="comment">//时间复杂度：(|V|^3)</span></span><br><span class="line">Algorithm <span class="built_in">computeSquareAdjMatrix</span>(G):</span><br><span class="line">    <span class="comment">// Initialize the adjacency matrix for the square graph G^2</span></span><br><span class="line">    n = number of nodes in V</span><br><span class="line">    A2 = <span class="keyword">new</span> matrix of size n x n filled with <span class="number">0</span>s</span><br><span class="line">    <span class="comment">// Calculate the square of the adjacency matrix</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">0</span> to n - <span class="number">1</span>:</span><br><span class="line">            <span class="comment">// A2[i][j] is 1 if there is a path of length at most 2 from i to j</span></span><br><span class="line">            <span class="keyword">if</span> A[i][j] == <span class="number">1</span>:</span><br><span class="line">                A2[i][j] = <span class="number">1</span>  <span class="comment">// Direct edge (i, j)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> k = <span class="number">0</span> to n - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> A[i][k] == <span class="number">1</span> <span class="keyword">and</span> A[k][j] == <span class="number">1</span>:</span><br><span class="line">                        A2[i][j] = <span class="number">1</span>  <span class="comment">// Path of length 2 from i to j</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A2</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>此题拓展：$G^k$ 包含了 $G$ 中所有顶点对之间长度不超过 $k$ 的路径</p>
</blockquote>
<div class="callout question">
  Most graph algorithms that take an adjacency-matrix representation as input require $\Omega (V^2)$ time, but there are some exceptions. Show how to determine whether a directed graph $G$ contains a universal sink--a vertex with in-degree |V| - 1 and out-degree 0--in $O(V)$ time, given an adjacency matrix for $G$.
</div>

<p>// 这题说的是很多基于邻接矩阵的图算法都需要 $\Omega (V^2)$ 的时间复杂度，但也有一些例外，比如查看一个有向图是否含有全局汇点（入度为 | V| - 1，出度为 0）。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">findUniversalSink</span><span class="params">(G)</span>:</span></span><br><span class="line"><span class="function">    candidate =</span> <span class="number">1</span>  <span class="comment">//这里索引从1开始，candidate为候选全局汇点</span></span><br><span class="line">    <span class="keyword">for</span> v from <span class="number">2</span> to |V|:</span><br><span class="line">        <span class="keyword">if</span> G[candidate][v] == <span class="number">1</span>: <span class="comment">//找到第一个出度为0的点作为最终的候选点</span></span><br><span class="line">            candidate = v</span><br><span class="line"></span><br><span class="line">    inDegree = <span class="number">0</span></span><br><span class="line">    outDegree = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> u from <span class="number">1</span> to |V|:</span><br><span class="line">        inDegree += G[u][candidate]</span><br><span class="line">        outDegree += G[candidate][u]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> inDegree == |V| - <span class="number">1</span> <span class="keyword">and</span> outDegree == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> candidate</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"No universal sink found"</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>这里确定候选汇点的形式很讲究，首先主对角线上元素都为 0，因此无参考价值，故只在其上方查找。只要遇到一个 1，就换到下一行（即下一个顶点），因为全局汇点没有出边，只要是 0，就在该行一直往后验证。到这里可能就有疑问（其实就是我的疑问罢了）：假设候选汇点一直都是 1，那么就只检查了第一行，其它行都没检查呢，为啥只要这候选汇点不是真的全局汇点，整个图就没有全局汇点。其实每检查一条边就相当于检查了一个顶点，比如，如果 $G [1][2] == 0$ 的话，就说明第二个顶点没有接受第一个顶点的入边，这同样是不符合全局汇点定义的，因为全局汇点是除了它自身，其它顶点都会指向它，因此该次检查排除了第二个顶点。如果 $G [1][3]$ 也 == 0 的话，那就排除了第三个顶点，以此类推。所以无论 $G [candidate][v]$ 等于 0 还是 1，都是有价值的，这使得定位候选汇点是固定地检查 | V| - 1 遍即可。</p>
</blockquote>
<div class="callout question">
 The incidence matrix of a directed graph $G = (V, E)$ with no self-loops is a $|V| \times |E|$ matrix $B = (b_{ij})$ such that
 $$
 b_{ij} = 
 \begin{cases} 
 -1, &amp; \text{ if edge j leaves vertex i}  \\ 
 1, &amp; \text{ if edge j enters vertex i} \\
 0, &amp; \text{ otherwise}  
 \end{cases} 
 $$
   Describe what the entries of the matrix product $B B^T$ represent, where $B^T$ is the
   transpose of B.
</div>

<blockquote>
<p>这题说的是有向无环图的关联矩阵，直接建立顶点与每条边的对应关系，出边就是 - 1，入边就是 1，没有关系就是 0。题目要求描述 $B B^T$ 矩阵的元素都代表什么。</p>
</blockquote>
<ol>
<li>对角线元素 $c_{ii}$​ 表示顶点 i 的度数，即与该顶点相关联的边的数量，包括入度和出度的边。<blockquote>
<ol start="2">
<li>非对角线元素 $c_{ij}$​（其中 i≠j）表示顶点 i 和 j 之间共享的边的数量，经计算我们可以发现 $B B^T$ 矩阵的元素要么是 0，要么是负数，没有正数。所以如果 $c_{ij}​=0$，则表示顶点 i 和 j 之间没有共享的边，而非零值则表示它们之间存在共享的边，如果是有多重边 (multiple edges) 的话，这个非零值就不只是 - 1 了。这里没直接说多重图 (multigraphs)，是因为多重图是包括了自环和多重边的，但题目说的是有向无环图。</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="Breadth-first-search"><a href="#Breadth-first-search" class="headerlink" title="Breadth-first search"></a>Breadth-first search</h2><blockquote>
<p>// 时间复杂度：O (V + E)<br>$BFS(G, s)$</p>
</blockquote>
<pre><code>for each vertex u $\in G.V - \{s\}$      //初始化
    u.color = WHITE
    $u.d = \infty$                              //d是距离
    u.$\pi$ = NIL                            //$\pi$是前驱
s.color = $GRAY$
s.d = 0
s.$\pi$ = NIL
$Q = \not 0$                                        //初始化队列
ENQUEUE(Q, s)
while Q $\not = \not 0$
    u = DEQUEUE(Q)
    for each vertex v in $G$.Adj[u]
        if v.color = WHITE
            v.color = $GRAY$
            v.d = u.d + 1
            v.$\pi$ = u
            ENQUEUE(Q, v)      //可以发现队列里的顶点都是灰色的
    u.color = BLACK
</code></pre>
<p>// 图的广搜使用了颜色标记方法，白色表示顶点未被发现，灰色表示该顶点已被发现，但其邻接顶点可能还有未被发现的顶点，黑色则表示其邻接顶点全被发现。<br><img src="https://telegraph-image-eja.pages.dev/file/68170db1c351c1c1154fb.png" alt="bfs"><br>// 该图展示了广搜全过程，广搜的结果可能不一样，这取决于 for each vertex v in $G$.Adj [u] 的遍历顺序。</p>
<h3 id="Shortest-paths"><a href="#Shortest-paths" class="headerlink" title="Shortest paths"></a>Shortest paths</h3><blockquote>
<p>定义 $\delta (s, v)$ 为从 s 到 v 的所有路径中的最少的边数</p>
</blockquote>
<h4 id="Lemma"><a href="#Lemma" class="headerlink" title="Lemma"></a>Lemma</h4><ul>
<li><p>(1) Let $G = (V, E)$ be a directed or undirected graph, and let $s \in V$ be an arbitrary<br>vertex. Then, for any edge $(u, v) \in E$,</p>
<p>$$<br>\delta(s, v) \leq \delta(s, u) + 1<br>$$</p>
<p><img src="https://telegraph-image-eja.pages.dev/file/40f16ccf9c4b758354fd3.png" alt="image"></p>
<blockquote>
<p>对于该引理有个方便记忆的描述，即三角形两边之和大于第三边，见 A 图，公式中的 1 就是 (u, v) 这条确定的边。</p>
<p>我一开始的想法是，(u, v) 这条边有 A, B, C 三种情况 (不严谨)，A 表示顶点 u, v 是同级的，对应 $\delta (s, v) = \delta (s, u)$ 的情况；B 表示顶点 u 相对于 s 的位置来说在 v 前面，对应 $\delta (s, v) = \delta (s, u) + 1$ 的情况；C 表示顶点 v 相对于 s 的位置来说在 u 前面，对应 $\delta (s, v) &lt; \delta (s, u)$ 的情况，特别地，C 中的蓝色曲线代表了 s 到 u 的其他路径，所以说 A 是 C 的特殊情况，因此也可以分成两种情况，上面都是建立在 u 是从 s 可以到达的情况，不可以到达的情况参照下面的解释。<br>// 上面纯属主观想法描述，可能存在纰漏以及说法不严谨的地方。</p>
<p>CLRS 里面的解释：<br>① 如果 u 是从 s 可以到达的顶点，那么 v 也是可达的，这种情况下从 $s \to v$ 的最短路径不可能比从 $s \to u$ 的最短路径再加上边 (u, v) 更长，因此不等式成立。// 这是原话，看到这句我觉得我上面的想法貌似就是想表达这个意思。反正就是因为 $\delta (s, u)$ 本身就是最短的，然后与顶点 v 再连一条边的话，那么 $\delta (s, v)$ 的路径要么不经过 u，要么经过 u。不经过的话就必定有 $\delta (s, v) \leq \delta (s, u) + 1$，因为如果不等号为 &gt;，那么 $\delta (s, u) + 1$ 这条路径才应该是 $\delta (s, v)$ 真正的路径，因为它更短；经过 u 的话就说明 u 是 $\delta (s, v)$ 路径的一部分，此时在无向图中 $\delta (s, v)$ 不仅有上限 $\delta (s, u) + 1$，还有 $\delta (s, u) - 1$ 这个下限。<br>② 如果 u 是从 s 不可以到达的顶点，那么在上面伪代码算法中可知，$\delta (s, u) = \infty$，等式显然成立。</p>
</blockquote>
</li>
<li><p>(2) Let $G = (V, E)$ be a directed or undirected graph, and suppose that BFS is run<br>on $G$ from a given source vertex $s \in V$ . Then, for each vertex $v \in V$ , the value v.d<br>computed by BFS satisfies $v.d \geq \delta (s, v)$ at all times, including at termination.</p>
</li>
</ul>
<blockquote>
<p>这里是用归纳法进行证明：归纳假设即为 $v.d \geq \delta (s, v)$ 对于所有 $v \in V$ 都成立<br>① 基本情况：在把源点 s 入队后，$s.d = 0 = \delta (s, s)$ 并且对于所有除 s 外的顶点 v 都有 $v.d = \infty \geq \delta (s, v)$，因此等式成立。<br>② 归纳：考虑到一个白色顶点 v 是在对顶点 u 的邻接表搜索中被发现的，因此 $v.d = u.d + 1$（可见伪代码），基于归纳假设，有 $v.d \geq \delta (s, u) + 1$，由引理 (1) 可知 $\delta (s, u) + 1 \geq \delta (s,v)$，因此等式成立。</p>
</blockquote>
<ul>
<li>(3) Suppose that during the execution of BFS on a graph $G = (V, E)$, the queue Q<br>contains the vertices $&lt;v_1, v_2, . . . , v_r&gt;$, where $v_1$ is the head of Q and $v_r$ is the tail.<br>Then, $v_r.d \leq v_1.d + 1$ and $v_i.d \leq v_{i + 1}.d$ for i = 1, 2, . . . , r - 1.</li>
</ul>
<blockquote>
<p>这里也是用归纳法进行证明，但直接理解好像更容易。首先，假设队列里只能有不超过两种距离不同的顶点，如果是只有一种距离，假设为 d，那么队列里肯定都是上一次出队的那个顶点 (距离为 d - 1) 的邻接表 (假设为 u) 里的，假设还没遍历完，那就继续添加，此时队列里顶点距离都是 d。遍历完后就又要把当前队列第一个顶点出队，如果其邻接表为空，那就下一个继续出队操作，此时队列还是一种距离的情况，如果不为空，那就开始遍历其邻接表，只要是对邻接表 u 里面的元素执行出队，之后入队的顶点的距离都会是 d+1，在此过程中距离就有两种情况，这种情况持续到 u 的所有顶点都出队了，那么此时队列里就只有 d+1 的顶点了，就又变回一种距离的情况了，以此类推，因此队列里不可能有超过两种距离，且从过程可知，跨度不超过 1，因此 $v_r.d \leq v_1.d + 1$ 成立，又因为代码中 d 的计算只有加没有减，因此在后面入队的肯定 $\geq$ 在前面入队的，因此，$v_i.d \leq v_{i + 1}.d$ 也成立。</p>
</blockquote>
<h4 id="Corollary"><a href="#Corollary" class="headerlink" title="Corollary"></a>Corollary</h4><ul>
<li>Suppose that vertices $v_i$ and $v_j$ are enqueued during the execution of BFS, and that $v_i$ is enqueued before $v_j$. Then $v_i.d \leq v_j.d$ at the time that $v_j$ is enqueued.</li>
</ul>
<h4 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h4><ul>
<li>Let $G = (V, E)$ be a directed or undirected graph, and suppose that BFS is run<br>on $G$ from a given source vertex $s \in V$ . Then, during its execution, BFS discovers<br>every vertex $v \in V$ that is reachable from the source s, and upon termination,<br>$v.d = \delta (s, v)$ for all $v \in V$ . Moreover, for any vertex $v \not = s$ that is reachable from s, one of the shortest paths from s to v is a shortest path from s to $v.\pi$ followed by the edge $(v.\pi, v)$.</li>
</ul>
<blockquote>
<p>这里定理其实主要表达的就是 $v.d = \delta (s, v)$，这就使得广搜可以用来求最短路径问题。<br>这个定理的证明采用反证法：<br>假设存在顶点的 d 值不等于它最短路径的距离。对于所有的这种顶点，设顶点 v 的最短距离为 $\delta (s, v)$，通过引理 (2) 可知，$v.d \geq \delta (s, v)$，因此在这里的顶点 v 有 $v.d &gt; \delta (s, v)$①，当然不能有 $v \not = s$，因为 s.d = 0 并且 $\delta (s, s) = 0$。而且，顶点 v 必须是从 s 可达的，否则我们将有 $\delta (s, v) = \infty \geq v.d$。设 u 是从 s 到 v 的最短路径上紧邻 v 前面的顶点 (因为 $v \not = s$，所以顶点 u 必须存在)，这样就有 $\delta (s, v) = \delta (s, u) + 1$② 了。因此 $\delta (s, u) &lt; \delta (s, v)$，又因为我们设 u 的方式，所以有 $u.d = \delta (s, u)$③。<br>结合 ①②③，就有了下图的公式，然后对 v 的所有情况进行讨论，推出矛盾，证明 $v.d = \delta (s, v)$ 成立。具体看下图：</p>
</blockquote>
<p><img src="https://telegraph-image-eja.pages.dev/file/a9bfbbf9fc07d7969e851.png" alt="?"></p>
<h3 id="Breadth-first-trees"><a href="#Breadth-first-trees" class="headerlink" title="Breadth-first trees"></a>Breadth-first trees</h3><p>上面广搜全过程图片中的蓝色边正展示了广度优先树在 BFS 过程中被建立，这个树对应着 $\pi$ 属性。<br>形式化的定义即是：对于有源点 s 的图 $G = (V, E)$，定义 $G$ 的前驱子图 (predecessor subgraph) $G_\pi = (V_\pi, E_\pi)$，其中 $V_\pi = {v \in V: v.\pi \not = NIL} \cup {s}$，$E_\pi = {(v.\pi, v): v \in V_\pi - {s}}$。这样的 $G_\pi$ 就是广度优先树，$E_\pi$ 为树边。</p>
<h2 id="Depth-first-search"><a href="#Depth-first-search" class="headerlink" title="Depth-first search"></a>Depth-first search</h2><ul>
<li>与广搜不同，深搜的前驱子图可能包含多个树，因为深搜可能从多个源点进行。<br>它对 $G_\pi$ 的定义是：$G_\pi = (V, E_\pi)$，其中 $E_\pi = {(v.\pi, v): v \in V \wedge v.\pi \not = NIL}$。<br>深度优先搜索的前驱子图形成了包含多个深度优先树的深度优先森林。</li>
<li>深度优先搜索着色方法与广搜一样，该方法在这里保证了每个顶点只在一棵深度优先树中出现，因此这些树都是不相交的。</li>
<li>与广搜不一样的是，深搜过程还提供了时间戳，每个顶点有两个时间戳，第一个时间戳 v.d 记录了 v 什么时候第一次被发现，第二个时间戳 v.f 记录了什么时候完成了对 v 的邻接表的遍历。因为每个顶点都有两个时间戳，因此时间戳范围是 $1 \to 2|V|$ 的整数，并且 $v.d &lt; v.f$。v 在 v.d 之前为白色，在 v.d 到 v.f 之间为灰色，在 v.f 之后为黑色。下面是深搜伪代码：</li>
</ul>
<blockquote>
<p>// 时间复杂度：O (V + E)<br>$DFS(G)$</p>
</blockquote>
<pre><code>   for each vertex $u \in G.V$                  //初始化
       u.color = WHITE
       u.$\pi$ = NIL
   time  = 0
   for each vertex $u \in G.V$
       if u.color == WHITE
           DFS-VISIT $(G, u)$
</code></pre>
<blockquote>
<p>DFS-VISIT $(G, u)$</p>
</blockquote>
<pre><code>   time = time + 1
   u.d = time
   u.color =$GRAY$
   for each vertex v in $G.Adj[u]$
       if v.color == WHITE
           v.$\pi$ = u
           DFS-VISIT $(G, v)$               //体现了深度优先
   time = time + 1
   u.f = time
   u.color = BLACK
</code></pre>
<p><img src="https://telegraph-image-eja.pages.dev/file/275c9f0fa7b28c8b16770.png" alt="dfs"><br>// 这是深搜全过程图</p>
<h3 id="Properties-of-depth-first-search"><a href="#Properties-of-depth-first-search" class="headerlink" title="Properties of depth-first search"></a>Properties of depth-first search</h3><ul>
<li>(1) 深度优先搜索生成的前驱子图 $G_\pi$ 为一个有若干棵树的森林，因为深度优先树的结构与 &nbsp;DFS-VISIT&nbsp; 递归调用的结构完全对应，也就是说，$u = v.\pi$ 当且仅当 &nbsp;DFS-VISIT (G, v)&nbsp; 在搜索 &nbsp;u&nbsp; 的邻接表时被调用，此外，在深度优先森林中，顶点 v 是顶点 u 的后代当且仅当顶点 v 在顶点 u 为灰色的时间段里被发现。<br><img src="https://telegraph-image-eja.pages.dev/file/b2b7493044770da13ffa1.png" alt="image"></li>
<li>(2) 顶点的发现时间和完成的时间具有括号化结构，与此对应的是括号化定理。</li>
</ul>
<h3 id="Parenthesis-theorem"><a href="#Parenthesis-theorem" class="headerlink" title="Parenthesis theorem"></a>Parenthesis theorem</h3><p>在对有向图或无向图 &nbsp;$G=(V, E)$ 的深度优先搜索中，对于任意两个顶点 &nbsp;u&nbsp; 和 &nbsp;v&nbsp;，以下三种情况只有一种成立：</p>
<ul>
<li>若 &nbsp;$[u.d, u.f]∩[v.d, v.f] = ∅$&nbsp;，则在深度优先森林中，u 不是 v 的后代，v 也不是 u 的后代。</li>
<li>若 $[u.d, u.f]⊂[v.d, v.f]$，则在深度优先森林中，u 是 v 的后代。</li>
<li>若 $[v.d, v.f]⊂[u.d, u.f]$，则在深度优先森林中，v 是 u 是后代。<br><img src="https://telegraph-image-eja.pages.dev/file/26624ae22bfd773c415fa.png" alt="image"></li>
</ul>
<h3 id="Corollary-Nesting-of-descendants’-intervals"><a href="#Corollary-Nesting-of-descendants’-intervals" class="headerlink" title="Corollary(Nesting of descendants’ intervals)"></a>Corollary(Nesting of descendants’ intervals)</h3><p>在有向图或无向图 $G = (V, E)$ 的深度优先森林中，顶点 v 是顶点 u 的真后代当且仅当 $u.d &lt; v.d &lt; v.f &lt; u.f$。</p>
<h3 id="White-path-theorem"><a href="#White-path-theorem" class="headerlink" title="White-path theorem"></a>White-path theorem</h3><p>在有向图或无向图 $G=(V, E)$ 的深度优先森林中，顶点 v 是顶点 u 的后代当且仅当在搜索发现 u 的时刻 u.d&nbsp;，存在一条从 u 到 v 的全部由白色顶点构成的路径。</p>
<ul>
<li>$\Rightarrow$：如果 v = u，那么从 u 到 v 路径上只有一个顶点 u，当 u.d = time 时刻，u 还是白色；如果 v 是 u 的真后代，根据推论，有 $u.d &lt; v.d$， 因此 v 是白色。由于 v 可以是 u 的任意后代，所以在深度优先森林中从 u 到 v 的唯一简单路径上的所有顶点在时间 u.d 时为白色。</li>
<li>$\Leftarrow$：若在时刻 u.d，存在一条从 u 到 v 的全部由白色顶点构成的路径，先假设在深度优先森林中 v 不是 u 的后代。不失一般性，假设路径上除 v 以外的每个顶点都成为 u 的后代。(否则，假设 v 是在没有成为 u 的后代的路径上离 u 最近的顶点。) 设 w 是 v 在路径上的前驱，那么 w 就是 u 的后代 (w 和 u 实际上可能是同一个顶点)。由推论可知，$w.f  \leq u.f$。又因为 v 必须在 u 被发现之后被发现，但在 w 完成的时间戳之前，则有 $u.d &lt; v.d &lt; w.f \leq u.f$。根据括号化定理可知，$[v.d, v.f]⊂[u.d, u.f]$。由推论可知，v 必须为 u 的后代</li>
</ul>
<h3 id="Classification-of-edges"><a href="#Classification-of-edges" class="headerlink" title="Classification of edges"></a>Classification of edges</h3><ul>
<li>树边 (Tree edges)：$G_\pi$ 上的边，若顶点 v 是通过边 (u, v) 第一次被发现，则 (u, v) 是一条树边。</li>
<li>后向边 (Back edges)：若边 (u, v) 为连接 u 和它在深度优先树中的一个祖先 v 的边，包括自环 (即 u = v)，则 (u, v) 是一条后向边。</li>
<li>前向边 (Forward edges)：若边 (u, v) 为连接 u 和它的一个真后代 v 的非树边，则 (u, v) 是一条前向边。</li>
<li>横向边 (Cross edges)：其它所有边，它们可以连接同一深度优先树中的顶点，只要其中一个顶点不是另一个顶点的祖先；它们也可以连接不同深度优先树中的顶点。</li>
</ul>
<h2 id="Topological-sort"><a href="#Topological-sort" class="headerlink" title="Topological sort"></a>Topological sort</h2><p>对象是有向无环图 (directed acyclic graphs)，因此拓扑排序可以用来判断一个图有没有环，很多实际应用都需要使用有向无环图来指明时间的先后顺序。<br>拓扑排序是一种针对有向无环图（DAG）的排序算法，它不是基于元素之间的比较，而是基于它们之间的依赖关系。原理上，拓扑排序是对有向无环图进行深度优先搜索（DFS）或广度优先搜索（BFS）的一种应用。它通过这些搜索算法来确定图中节点的线性序列，这个序列满足：对于图中的每一条有向边 (u, v)（从节点 u 指向节点 v），u 在序列中都出现在 v 之前。这样的序列满足了图中节点间的所有依赖关系。</p>
<ul>
<li><strong>依赖关系</strong>：<br>图中的每个节点代表一个任务或活动，有向边代表一个任务必须在另一个任务之后完成。拓扑排序能够确保对于任何节点，它的所有前驱节点（即所有指向它的节点）都在它之前被访问。<blockquote>
<p>伪代码：<br>TOPOLOGICAL-SORT$(G)$<br>       call $DFS(G)$ to compute finish times v.f for each vertex v<br>       as each vertex is finished, insert it onto the front of a linked list<br>       return the linked list of vertices</p>
</blockquote>
</li>
</ul>
<h2 id="Strongly-connected-components"><a href="#Strongly-connected-components" class="headerlink" title="Strongly connected components"></a>Strongly connected components</h2><ul>
<li>有向图 $G = (V, E)$ 的一个强连通分量是一个最大顶点集 $C \subseteq V$，对于每一对顶点 $u, v \in C$，那么 u, v 相互可达。</li>
<li>$G 和 G^T$ 有完全相同的强连通分量。</li>
<li>分量图 $G^{SCC} = (V^{SCC},E^{SCC})$，为简化后的有向图，把每个强连通分量压缩成一个顶点，以便研究它们之间的关系。<br><img src="https://telegraph-image-eja.pages.dev/file/f02f4a1572ce744d646b2.png" alt="image"></li>
</ul>
<blockquote>
<p>伪代码：<br>$STRONGLY-CONNECTED-COMPONENTS(G)$<br>1 call DFS(G) to compute finish times u.f for each vertex u<br>2 create $G^T$<br>3 call DFS($G^T$) , but in the main loop of DFS, consider the vertices<br>in order of decreasing u.f (as computed in line 1)<br>4 output the vertices of each tree in the depth-ûrst forest formed in line 3 as a</p>
</blockquote>
<pre><code>    separate strongly connected component
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Command 自用</title>
    <url>/2025/08/06/Git-Command/</url>
    <content><![CDATA[<h2 id="项目模拟场景"><a href="#项目模拟场景" class="headerlink" title="项目模拟场景"></a>项目模拟场景</h2><h3 id="项目初始化阶段"><a href="#项目初始化阶段" class="headerlink" title="项目初始化阶段"></a>项目初始化阶段</h3><h4 id="1-创建远程仓库"><a href="#1-创建远程仓库" class="headerlink" title="1. 创建远程仓库"></a>1. 创建远程仓库</h4><ul>
<li>在 GitHub 创建 private 仓库</li>
<li>邀请协作者</li>
</ul>
<h4 id="2-初始化本地项目"><a href="#2-初始化本地项目" class="headerlink" title="2. 初始化本地项目"></a>2. 初始化本地项目</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mkdir ProjectName &amp;&amp; cd ProjectName</span><br><span class="line">echo "# ProjectName - 项目描述" &gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m "chore: initial project setup"</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建基础分支结构</span></span><br><span class="line">git switch -c develop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建初始目录结构</span></span><br><span class="line">mkdir -p backend frontend docs</span><br><span class="line">echo "后端服务" &gt; backend/README.md</span><br><span class="line">echo "前端应用" &gt; frontend/README.md</span><br><span class="line">echo "项目文档" &gt; docs/README.md</span><br><span class="line">git add .</span><br><span class="line">git commit -m "build: create project structure"</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送到远程</span></span><br><span class="line">git remote add origin https://github.com/username/ProjectName.git</span><br><span class="line">git push -u origin main develop</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-设置分支保护-仓库-settings"><a href="#3-设置分支保护-仓库-settings" class="headerlink" title="3. 设置分支保护(仓库 settings)"></a>3. 设置分支保护 (仓库 settings)</h4><ul>
<li><code>main</code> 分支：Require pull request, Require 1 approval, Require status checks</li>
<li><code>develop</code> 分支：Require pull request, Require status checks</li>
</ul>
<h3 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有团队成员克隆仓库</span></span><br><span class="line">git clone https://github.com/username/ProjectName.git</span><br><span class="line">cd ProjectName</span><br><span class="line">git switch develop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化后端项目</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 后端成员操作</span></span></span><br><span class="line">git pull origin develop</span><br><span class="line">cd backend</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具体技术栈初始化命令示例:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">spring init --dependencies=web,data-jpa,mysql,security --build=gradle -n BackendProject</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> BackendProject/* . &amp;&amp; <span class="built_in">rmdir</span> BackendProject</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m "build: initialize backend"</span><br><span class="line">git push origin develop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化前端项目</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 前端成员操作</span></span></span><br><span class="line">git pull origin develop</span><br><span class="line">cd frontend</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具体技术栈初始化命令示例:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm init vue@latest -- --projectName=<span class="string">"FrontendProject"</span> --typescript --pinia --vitest</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> FrontendProject/* . &amp;&amp; <span class="built_in">rmdir</span> FrontendProject</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m "build: initialize frontend"</span><br><span class="line">git push origin develop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果develop设置了分支保护，该push会失败，可以采用以下方法：</span></span><br><span class="line">git pull origin develop</span><br><span class="line">git switch -c feature/init-frontend</span><br><span class="line">cd frontend</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行前端初始化命令</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m "build: initialize frontend"</span><br><span class="line">git push -u origin feature/init-frontend</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前端成员去github网页创建PR，reviewer在网页处理PR，接着前端成员同步最新的develop</span></span><br><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line">git branch -d feature/init-frontend   # 删掉本地功能分支</span><br></pre></td></tr></tbody></table></figure>

<h2 id="项目开发阶段"><a href="#项目开发阶段" class="headerlink" title="项目开发阶段"></a>项目开发阶段</h2><h3 id="迭代-1：用户认证系统"><a href="#迭代-1：用户认证系统" class="headerlink" title="迭代 1：用户认证系统"></a>迭代 1：用户认证系统</h3><h4 id="后端成员开发认证-API"><a href="#后端成员开发认证-API" class="headerlink" title="后端成员开发认证 API"></a>后端成员开发认证 API</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line">git switch -c feature/backend-auth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发认证功能</span></span><br><span class="line"><span class="comment"># ... 编写JWT认证逻辑 ...</span></span><br><span class="line">git add backend/src/main/java/com/project/auth/**</span><br><span class="line">git commit -m <span class="string">"feat(auth): implement JWT authentication"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发API文档</span></span><br><span class="line"><span class="comment"># ... 添加Swagger注解 ...</span></span><br><span class="line">git add backend/src/main/java/com/project/controller/AuthController.java</span><br><span class="line">git commit -m <span class="string">"docs(auth): add swagger API documentation"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程</span></span><br><span class="line">git push -u origin feature/backend-auth</span><br></pre></td></tr></tbody></table></figure>

<h4 id="前端成员开发登录界面"><a href="#前端成员开发登录界面" class="headerlink" title="前端成员开发登录界面"></a>前端成员开发登录界面</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line">git switch -c feature/frontend-login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于后端Swagger生成TS类型</span></span><br><span class="line">npx openapi-typescript http://localhost:8080/v3/api-docs -o src/api-types.d.ts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发登录组件</span></span><br><span class="line"><span class="comment"># ... 创建Login.vue ...</span></span><br><span class="line">git add frontend/src/views/Login.vue</span><br><span class="line">git commit -m <span class="string">"feat(login): implement login page UI"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发认证逻辑</span></span><br><span class="line"><span class="comment"># ... 实现axios拦截器 ...</span></span><br><span class="line">git add frontend/src/services/auth.ts</span><br><span class="line">git commit -m <span class="string">"feat(auth): implement token management"</span></span><br><span class="line"></span><br><span class="line">git push -u origin feature/frontend-login</span><br></pre></td></tr></tbody></table></figure>

<h4 id="代码审查与合并"><a href="#代码审查与合并" class="headerlink" title="代码审查与合并"></a>代码审查与合并</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 后端成员创建PR: feature/backend-auth → develop</span></span><br><span class="line"><span class="comment"># 前端成员创建PR: feature/frontend-login → develop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 审查过程：</span></span><br><span class="line"><span class="comment">## 1. 前端成员验证后端API文档</span></span><br><span class="line"><span class="comment">## 2. 后端成员检查前端token处理逻辑</span></span><br><span class="line"><span class="comment">## 3. 项目经理批准合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并后操作（项目经理）：</span></span><br><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line"><span class="comment"># 如果不走网页PR，可在本地合并</span></span><br><span class="line">git merge --no-ff feature/backend-auth</span><br><span class="line">git merge --no-ff feature/frontend-login</span><br><span class="line">git push origin develop</span><br></pre></td></tr></tbody></table></figure>

<h3 id="迭代-2：数据分析看板"><a href="#迭代-2：数据分析看板" class="headerlink" title="迭代 2：数据分析看板"></a>迭代 2：数据分析看板</h3><h4 id="后端成员开发分析-API"><a href="#后端成员开发分析-API" class="headerlink" title="后端成员开发分析 API"></a>后端成员开发分析 API</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line">git switch -c feature/backend-analysis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库迁移脚本</span></span><br><span class="line"><span class="comment"># ... 使用Liquibase/Flyway等 ...</span></span><br><span class="line">git add backend/src/main/resources/db/changelog/v1.1__analysis_tables.xml</span><br><span class="line">git commit -m <span class="string">"db: add analysis tables"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发分析算法</span></span><br><span class="line"><span class="comment"># ... 集成数据分析模型 ...</span></span><br><span class="line">git add backend/src/main/java/com/project/service/AnalysisService.java</span><br><span class="line">git commit -m <span class="string">"feat(analysis): implement data analysis model"</span></span><br><span class="line"></span><br><span class="line">git push -u origin feature/backend-analysis</span><br></pre></td></tr></tbody></table></figure>

<h4 id="前端成员开发可视化看板"><a href="#前端成员开发可视化看板" class="headerlink" title="前端成员开发可视化看板"></a>前端成员开发可视化看板</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line">git switch -c feature/frontend-dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装可视化库</span></span><br><span class="line">npm install echarts vue-echarts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发看板组件</span></span><br><span class="line"><span class="comment"># ... 创建Dashboard.vue ...</span></span><br><span class="line">git add frontend/src/views/Dashboard.vue</span><br><span class="line">git commit -m <span class="string">"feat(dashboard): implement analysis charts"</span></span><br><span class="line"></span><br><span class="line">git push -u origin feature/frontend-dashboard</span><br></pre></td></tr></tbody></table></figure>

<h4 id="遇到问题：API-变更冲突"><a href="#遇到问题：API-变更冲突" class="headerlink" title="遇到问题：API 变更冲突"></a>遇到问题：API 变更冲突</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 后端成员修改了API响应格式</span></span><br><span class="line">git add backend/src/main/java/com/project/controller/DataController.java</span><br><span class="line">git commit -m <span class="string">"refactor(api): update response format for frontend"</span></span><br><span class="line">git push origin feature/backend-analysis --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前端成员需要同步变更</span></span><br><span class="line">git switch feature/frontend-dashboard</span><br><span class="line">git fetch origin</span><br><span class="line">git rebase origin/develop  <span class="comment"># 获取最新API变更</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决前端适配问题</span></span><br><span class="line"><span class="comment"># ... 更新数据处理逻辑 ...</span></span><br><span class="line">git add frontend/src/views/Dashboard.vue</span><br><span class="line">git commit -m <span class="string">"fix(dashboard): adapt to new API response format"</span></span><br><span class="line">git push origin feature/frontend-dashboard --force</span><br></pre></td></tr></tbody></table></figure>

<h3 id="迭代-3：推荐系统"><a href="#迭代-3：推荐系统" class="headerlink" title="迭代 3：推荐系统"></a>迭代 3：推荐系统</h3><h4 id="多人协作开发"><a href="#多人协作开发" class="headerlink" title="多人协作开发"></a>多人协作开发</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 后端成员A开发数据管理</span></span><br><span class="line">git switch develop</span><br><span class="line">git switch -c feature/backend-data-mgmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前端成员开发推荐界面</span></span><br><span class="line">git switch develop</span><br><span class="line">git switch -c feature/frontend-recommendation</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后端成员B开发推荐算法</span></span><br><span class="line">git switch develop</span><br><span class="line">git switch -c feature/backend-recommend-engine</span><br></pre></td></tr></tbody></table></figure>

<h4 id="遇到数据库冲突"><a href="#遇到数据库冲突" class="headerlink" title="遇到数据库冲突"></a>遇到数据库冲突</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 后端成员A提交了数据表变更</span></span><br><span class="line">git add backend/src/main/resources/db/changelog/v1.2__data_tables.xml</span><br><span class="line">git commit -m <span class="string">"db: add data tables"</span></span><br><span class="line">git push origin feature/backend-data-mgmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后端成员B也需要修改数据库</span></span><br><span class="line">git switch feature/backend-recommend-engine</span><br><span class="line">git fetch origin</span><br><span class="line">git rebase origin/develop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遇到冲突：db/changelog/changelog-master.yaml</span></span><br><span class="line"><span class="comment"># 解决冲突后</span></span><br><span class="line">git add backend/src/main/resources/db/changelog/</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line">git push origin feature/backend-recommend-engine --force</span><br></pre></td></tr></tbody></table></figure>

<h2 id="测试与发布阶段"><a href="#测试与发布阶段" class="headerlink" title="测试与发布阶段"></a>测试与发布阶段</h2><h3 id="预发布准备"><a href="#预发布准备" class="headerlink" title="预发布准备"></a>预发布准备</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 创建发布分支</span></span><br><span class="line">git switch develop</span><br><span class="line">git pull origin develop</span><br><span class="line">git switch -c release/v1.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新版本号</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1.0.0"</span> &gt; VERSION</span><br><span class="line">git add VERSION</span><br><span class="line">git commit -m <span class="string">"chore: prepare release v1.0.0"</span></span><br><span class="line">git push -u origin release/v1.0.0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="测试问题修复"><a href="#测试问题修复" class="headerlink" title="测试问题修复"></a>测试问题修复</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 发现权限问题</span></span><br><span class="line">git switch release/v1.0.0</span><br><span class="line">git switch -c fix/permission-issue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复后端权限验证</span></span><br><span class="line"><span class="comment"># ... 修改SecurityConfig等 ...</span></span><br><span class="line">git add backend/src/main/java/com/project/config/SecurityConfig.java</span><br><span class="line">git commit -m <span class="string">"fix(auth): correct role permissions"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并回发布分支</span></span><br><span class="line">git switch release/v1.0.0</span><br><span class="line">git merge --no-ff fix/permission-issue</span><br><span class="line">git push origin release/v1.0.0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="正式发布"><a href="#正式发布" class="headerlink" title="正式发布"></a>正式发布</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 合并到main分支</span></span><br><span class="line">git switch main</span><br><span class="line">git pull origin main</span><br><span class="line">git merge --no-ff release/v1.0.0</span><br><span class="line">git tag -a v1.0.0 -m <span class="string">"Initial release with core features"</span></span><br><span class="line">git push origin main --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新develop分支</span></span><br><span class="line">git switch develop</span><br><span class="line">git merge release/v1.0.0</span><br><span class="line">git push origin develop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除发布分支</span></span><br><span class="line">git branch -d release/v1.0.0</span><br><span class="line">git push origin --delete release/v1.0.0</span><br></pre></td></tr></tbody></table></figure>

<h2 id="生产环境问题处理"><a href="#生产环境问题处理" class="headerlink" title="生产环境问题处理"></a>生产环境问题处理</h2><h3 id="紧急修复示例"><a href="#紧急修复示例" class="headerlink" title="紧急修复示例"></a>紧急修复示例</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 从main创建热修复分支</span></span><br><span class="line">git switch main</span><br><span class="line">git pull origin main</span><br><span class="line">git switch -c hotfix/critical-bug-fix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复问题</span></span><br><span class="line"><span class="comment"># ... 修改相关服务 ...</span></span><br><span class="line">git add backend/src/main/java/com/project/service/DataService.java</span><br><span class="line">git commit -m <span class="string">"fix(service): handle large dataset processing"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并到main和develop</span></span><br><span class="line">git switch main</span><br><span class="line">git merge --no-ff hotfix/critical-bug-fix</span><br><span class="line">git tag -a v1.0.1 -m <span class="string">"Hotfix for critical bug"</span></span><br><span class="line">git push origin main --tags</span><br><span class="line"></span><br><span class="line">git switch develop</span><br><span class="line">git merge hotfix/critical-bug-fix</span><br><span class="line">git push origin develop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除热修复分支</span></span><br><span class="line">git branch -d hotfix/critical-bug-fix</span><br></pre></td></tr></tbody></table></figure>

<h2 id="checkout-和-switch-的区别"><a href="#checkout-和-switch-的区别" class="headerlink" title="checkout 和 switch 的区别"></a>checkout 和 switch 的区别</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分支切换</span></span><br><span class="line">git checkout existing-branch</span><br><span class="line">git switch existing-branch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建并切换分支</span></span><br><span class="line">git checkout -b feature/new-feature</span><br><span class="line">git switch -c feature/new-feature</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件恢复</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">核心场景：你还没提交，但把某个文件改坏了，想撤销所有未暂存的本地修改，让它立刻回到上一次提交时的样子（误删也用这个）</span></span><br><span class="line">git checkout -- src/components/Component.vue</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果已暂存，先用`git reset HEAD &lt;file&gt;`取消暂存，再用checkout</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看历史提交（只读模式）</span></span><br><span class="line">git checkout HEAD~3</span><br><span class="line">git switch --detach HEAD~3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安全机制</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当有未提交更改时尝试切换分支，switch会报错，而checkout会尝试自动合并，可能会导致数据丢失</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="pull-fetch-的区别"><a href="#pull-fetch-的区别" class="headerlink" title="pull &amp; fetch 的区别"></a>pull &amp; fetch 的区别</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pull = fetch + merge</span></span><br><span class="line">git pull origin develop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分步操作更安全</span></span><br><span class="line">git fetch origin           # 获取远程更新但不合并</span><br><span class="line">git log origin/develop..HEAD  # 查看差异</span><br><span class="line">git merge origin/develop    # 手动合并</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rebase方式拉取（保持线性历史）</span></span><br><span class="line">git pull --rebase origin develop</span><br></pre></td></tr></tbody></table></figure>

<h2 id="rebase-merge-的区别"><a href="#rebase-merge-的区别" class="headerlink" title="rebase &amp; merge 的区别"></a>rebase &amp; merge 的区别</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">merge方式：保留分支历史</span></span><br><span class="line">git switch main</span><br><span class="line">git merge feature/login     # 创建合并提交</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rebase方式：线性历史更整洁</span></span><br><span class="line">git switch feature/login</span><br><span class="line">git rebase main            # 重新应用提交</span><br><span class="line">git switch main</span><br><span class="line">git merge feature/login    # 快进合并</span><br></pre></td></tr></tbody></table></figure>

<h2 id="常用命令速查"><a href="#常用命令速查" class="headerlink" title="常用命令速查"></a>常用命令速查</h2><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>查看分支</td>
<td><code>git branch -a</code></td>
<td>显示所有分支</td>
</tr>
<tr>
<td>切换分支</td>
<td><code>git switch branch-name</code></td>
<td>推荐用法</td>
</tr>
<tr>
<td>创建切换</td>
<td><code>git switch -c new-branch</code></td>
<td>创建并切换到新分支</td>
</tr>
<tr>
<td>删除分支</td>
<td><code>git branch -d branch-name</code></td>
<td>删除已合并分支</td>
</tr>
<tr>
<td>强制删除</td>
<td><code>git branch -D branch-name</code></td>
<td>强制删除分支</td>
</tr>
</tbody></table>
<h3 id="同步操作"><a href="#同步操作" class="headerlink" title="同步操作"></a>同步操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>拉取更新</td>
<td><code>git pull origin main</code></td>
<td>拉取并合并</td>
</tr>
<tr>
<td>获取更新</td>
<td><code>git fetch origin</code></td>
<td>只获取不合并</td>
</tr>
<tr>
<td>推送分支</td>
<td><code>git push -u origin HEAD</code></td>
<td>推送当前分支</td>
</tr>
<tr>
<td>强制推送</td>
<td><code>git push --force-with-lease</code></td>
<td>安全强推</td>
</tr>
</tbody></table>
<h3 id="提交管理"><a href="#提交管理" class="headerlink" title="提交管理"></a>提交管理</h3><table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>查看状态</td>
<td><code>git status</code></td>
<td>检查工作区状态</td>
</tr>
<tr>
<td>暂存文件</td>
<td><code>git add .</code></td>
<td>暂存所有变更</td>
</tr>
<tr>
<td>提交变更</td>
<td><code>git commit -m "message"</code></td>
<td>提交暂存区</td>
</tr>
<tr>
<td>修改提交</td>
<td><code>git commit --amend</code></td>
<td>修改最后一次提交</td>
</tr>
<tr>
<td>撤销提交</td>
<td><code>git reset --soft HEAD~1</code></td>
<td>撤销但保留更改</td>
</tr>
</tbody></table>
<h3 id="历史查看"><a href="#历史查看" class="headerlink" title="历史查看"></a>历史查看</h3><table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>查看历史</td>
<td><code>git log --oneline</code></td>
<td>简洁历史</td>
</tr>
<tr>
<td>图形化历史</td>
<td><code>git log --graph --all</code></td>
<td>分支图</td>
</tr>
<tr>
<td>文件历史</td>
<td><code>git log -p filename</code></td>
<td>文件变更历史</td>
</tr>
<tr>
<td>查看差异</td>
<td><code>git diff HEAD~1</code></td>
<td>与上次提交比较</td>
</tr>
</tbody></table>
<h2 id="关键-git-命令速查表"><a href="#关键-git-命令速查表" class="headerlink" title="关键 git 命令速查表"></a>关键 git 命令速查表</h2><table>
<thead>
<tr>
<th align="center">场景</th>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开始新功能</td>
<td align="center"> git switch develop &amp;&amp; git pull &amp;&amp; git switch -c feature/[name]</td>
<td align="center"> 从 develop 创建新功能分支</td>
</tr>
<tr>
<td align="center">每日同步</td>
<td align="center"> git fetch origin &amp;&amp; git rebase origin/develop</td>
<td align="center"> 保持与 develop 同步</td>
</tr>
<tr>
<td align="center">提交变更</td>
<td align="center"> git add . &amp;&amp; git commit -m “…” &amp;&amp; git push -u origin HEAD</td>
<td align="center"> 推送当前分支</td>
</tr>
<tr>
<td align="center">解决冲突</td>
<td align="center"> git rebase –continue 或 git rebase –abort</td>
<td align="center"> 变基操作控制</td>
</tr>
<tr>
<td align="center">撤销错误提交</td>
<td align="center"> git reset –soft HEAD~1</td>
<td align="center"> 撤销最后一次提交</td>
</tr>
<tr>
<td align="center">查看分支关系</td>
<td align="center"> git log –all –graph –oneline</td>
<td align="center"> 可视化分支历史</td>
</tr>
</tbody></table>
<h2 id="git-提交规范"><a href="#git-提交规范" class="headerlink" title="git 提交规范"></a>git 提交规范</h2><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">feat: 添加新功能</span><br><span class="line">fix: 修复 bug</span><br><span class="line">docs: 文档变更</span><br><span class="line">style: 代码格式/样式调整</span><br><span class="line">refactor: 代码重构</span><br><span class="line">test: 添加或修改测试</span><br><span class="line">chore: 构建过程或辅助工具变更</span><br></pre></td></tr></tbody></table></figure>

<h2 id="常用场景补充"><a href="#常用场景补充" class="headerlink" title="常用场景补充"></a>常用场景补充</h2><h3 id="储藏工作进度"><a href="#储藏工作进度" class="headerlink" title="储藏工作进度"></a>储藏工作进度</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时保存当前工作</span></span><br><span class="line">git stash push -m "work in progress"</span><br><span class="line">git stash list               # 查看储藏列表</span><br><span class="line">git stash pop               # 恢复最新储藏</span><br><span class="line">git stash apply stash@{1}   # 恢复指定储藏</span><br></pre></td></tr></tbody></table></figure>

<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">撤销已暂存的文件</span></span><br><span class="line">git reset HEAD filename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">撤销本地修改</span></span><br><span class="line">git checkout -- filename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件修改者</span></span><br><span class="line">git blame filename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复已删除的文件</span></span><br><span class="line">git checkout HEAD~1 -- deleted-file.js</span><br></pre></td></tr></tbody></table></figure>

<h3 id="历史查看-1"><a href="#历史查看-1" class="headerlink" title="历史查看"></a>历史查看</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看简洁历史</span></span><br><span class="line">git log --oneline</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看分支图</span></span><br><span class="line">git log --all --graph --oneline</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件变更历史</span></span><br><span class="line">git log -p -- filename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索提交信息</span></span><br><span class="line">git log --grep="fix"</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
        <tag>命令笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimum Spanning Trees</title>
    <url>/2024/04/25/Minimum%20Spanning%20Trees/</url>
    <content><![CDATA[<h1 id="Minimum-Spanning-Trees"><a href="#Minimum-Spanning-Trees" class="headerlink" title="Minimum Spanning Trees"></a>Minimum Spanning Trees</h1><p>对于无向图 $𝐺=(𝑉,𝐸)$，存在一个能够连接所有顶点的无环子集 $𝑇⊆𝐸$，由于 &nbsp;𝑇&nbsp; 无环且连接所有顶点，因此 &nbsp;𝑇&nbsp; 一定为一棵树 (树是特殊的图，为无环连通图)，被称为生成树 (spanning tree)。无向图 $𝐺=(𝑉,𝐸)$ 的所有生成树都恰有 $|𝑉|−1$ 条边。</p>
<p>设边 $(𝑢,𝑣)∈𝐸$ 的权重为 $𝑤(𝑢,𝑣)$，生成树权重为 $𝑤(𝑇) = \sum_{(𝑢,𝑣)∈𝑇} 𝑤(𝑢,𝑣)$，所有生成树中权重最小的生成树被称为最小权重生成树 (minimum-weight spanning tree)，简称最小生成树 (minimum spanning tree)。</p>
<h2 id="Growing-a-minimum-spanning-tree"><a href="#Growing-a-minimum-spanning-tree" class="headerlink" title="Growing a minimum spanning tree"></a>Growing a minimum spanning tree</h2><p>最小生成树问题的输入为一个无向连通图 &nbsp;$𝐺=(𝑉,𝐸)$, 伪代码如下：</p>
<blockquote>
<p>$GENERIC-MST(G, w)$<br>1 $A = \not 0$<br>2 while A does not form a spanning tree<br>3 find an edge (u, v) that is safe for A<br>4 $A = A \cup {(u, v)}$<br>5 return A</p>
</blockquote>
<p>能够被加入 &nbsp;𝐴&nbsp; 的边 &nbsp;(𝑢,𝑣)&nbsp; 被称为 &nbsp;𝐴&nbsp; 的安全边 (safe edge)。通过 &nbsp;𝐴&nbsp; 维持了循环不变量可证明过程 &nbsp;GENERIC-MST&nbsp; 的正确性。在讨论如何识别安全边之前，我们需要了解一些定义。<br><img src="https://telegraph-image-eja.pages.dev/file/d85f5a52655f0d41a977d.png" alt="image"></p>
<ul>
<li>$cut$：无向图 $𝐺=(𝑉,𝐸)$ 的一个切割 (cut)&nbsp;$(𝑆,𝑉−𝑆)$ 是对顶点 𝑉 的一个划分，分成两个区域</li>
<li> $cross$：若边 $(𝑢,𝑣)∈𝐸$ 的一个端点属于 &nbsp;𝑆&nbsp;，另一个端点属于 𝑉−𝑆&nbsp;，则称边 (𝑢,𝑣)&nbsp; 横跨 (cross) cut (𝑆,𝑉−𝑆)，看图的话就是跟红色分割线相交的边都是 cross 的边</li>
<li> $respect$：若集合 &nbsp;𝐴&nbsp; 中不存在横跨切割 &nbsp;(𝑆,𝑉−𝑆)&nbsp; 的边，则称该切割不影响 (respect)&nbsp;𝐴</li>
<li>$light\ edge$：权重最小的 cross 边即是轻量边 (light edge)<br>原文如下：<br><img src="https://telegraph-image-eja.pages.dev/file/1833dbc2edcac6e9a8fb9.png" alt="image"><br>当然最好还得知道树的性质：添加一条边就会构成环，删除一条边就会分裂成两棵树。</li>
</ul>
<h3 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h3><blockquote>
<p>设 &nbsp;𝐺=(𝑉, 𝐸)&nbsp; 为一个无向连通图，其权重函数为 &nbsp;𝑤: $𝐸\to𝑅$&nbsp;，设 &nbsp;𝐴⊆𝐸&nbsp;，且 &nbsp;𝐴&nbsp; 包含于 &nbsp;𝐺&nbsp; 的一棵最小生成树中。设 &nbsp;(𝑆, 𝑉−𝑆)&nbsp; 为 &nbsp;𝐺&nbsp; 中不影响 &nbsp;𝐴&nbsp; 的任意一个切割，若 &nbsp;(𝑢, 𝑣)&nbsp; 为横跨 &nbsp;(𝑆, 𝑉−𝑆)&nbsp; 的一条轻量边，则对于 &nbsp;𝐴&nbsp;，(𝑢, 𝑣)&nbsp; 是安全的。</p>
</blockquote>
<p><img src="https://telegraph-image-eja.pages.dev/file/bd123ede0b571e7df22aa.png" alt="image"></p>
<p>// 图中橙色顶点属于 S，其它顶点属于 V-S，蓝色边就是 A 中的边</p>
<p>证明如下：</p>
<ul>
<li>首先假设 T 是包含 A 的最小生成树，并假设 T 不包含轻量边 (u, v)，因为如果包含了，我们就不用证了。接着我们可以通过构造另一棵最小生成树 T’，其中 $A \cup {(u, v)} ⊆ T’$, 从而表明，边 &nbsp;(𝑢, 𝑣)&nbsp; 对于 &nbsp;𝐴&nbsp; 是安全的。</li>
<li>由图可知边 (u, v) 与 $u \to v$ 的简单路径构成环路。因为 u, v 在 cut (𝑆, 𝑉−𝑆) 下分属两边，因此 &nbsp;𝑇&nbsp; 中至少有一条边属于简单路径 &nbsp;𝑝&nbsp; 并且横跨该切割，设 &nbsp;(𝑥, 𝑦)&nbsp; 为这样一条边。因为切割 &nbsp;(𝑆, 𝑉−𝑆)&nbsp; 不影响 𝐴&nbsp;，所以 &nbsp;(𝑥, 𝑦) ∉ 𝐴。又因为边 &nbsp;(𝑥, 𝑦)&nbsp; 位于 &nbsp;𝑇&nbsp; 中从 &nbsp;𝑢&nbsp; 到 &nbsp;𝑣&nbsp; 的唯一的简单路径上，所以移除 &nbsp;(𝑥, 𝑦)&nbsp; 会导致 &nbsp;𝑇&nbsp; 分裂成两部分。此时添加 &nbsp;(𝑢, 𝑣)&nbsp; 将这两部分重新连接成一棵新的生成树 ：𝑇′=(𝑇−{(𝑥,𝑦)})∪{(𝑢,𝑣)}&nbsp;。</li>
<li>我们接下来要证明 T’是最小生成树。由于 &nbsp;(𝑢, 𝑣)&nbsp; 为横跨 &nbsp;(𝑆, 𝑉−𝑆)&nbsp; 的一条轻量边且 &nbsp;(𝑥, 𝑦)&nbsp; 为横跨 &nbsp;(𝑆, 𝑉−𝑆)&nbsp; 的一条边，即 &nbsp;𝑤(𝑢, 𝑣)≤𝑤(𝑥, 𝑦)&nbsp;，因此：<br>$w(T’) = w(T) - w(x, y) + w(u, v)$<br>$\leq w(T)$<br>但是 &nbsp;𝑇&nbsp; 为一棵最小生成树，有 &nbsp;𝑤(𝑇)≤𝑤(𝑇′)&nbsp;。因此，有 &nbsp;𝑤(𝑇) = 𝑤(𝑇′)&nbsp;，所以 &nbsp;𝑇′&nbsp; 也是一棵最小生成树。</li>
<li>最后，我们还需要说明边 &nbsp;(𝑢, 𝑣)&nbsp; 对于 &nbsp;𝐴&nbsp; 是安全的。因为 &nbsp;𝐴⊆𝑇&nbsp; 且 &nbsp;(𝑥, 𝑦)∉𝐴&nbsp;，所以 &nbsp;𝐴⊆𝑇′&nbsp;，所以 &nbsp;(𝐴∪{(𝑢,𝑣)})⊆𝑇′&nbsp;。由于 &nbsp;𝑇′&nbsp; 是一棵最小生成树，因此对于 &nbsp;𝐴&nbsp;，(𝑢, 𝑣)&nbsp; 是安全的。</li>
</ul>
<p>感觉有点难咀嚼的话可以看看下面的另一种证明 (算法 4)：<br><img src="https://telegraph-image-eja.pages.dev/file/ef60c9e50f8c87db41f0d.png" alt="image"></p>
<blockquote>
<p>在算法执行的任何时候，图 $G_A = (V, A)$ 是一个森林，$G_A$ 中每一个连通分量都是一棵树 (一些树可能只包含一个顶点，例如在算法开始时，A 是空的，因为还没开始加入安全边，并且此时森林包含了 | V | 棵树，每棵树都只有一个顶点)。此外，因为 $A \cup {(u, v)}$ 必须是无环的，因此每一条安全边 (u, v) 都连接着 $G_A$ 中的不同分量。</p>
</blockquote>
<h3 id="Corollary"><a href="#Corollary" class="headerlink" title="Corollary"></a>Corollary</h3><p>设 &nbsp;𝐺=(𝑉, 𝐸)&nbsp; 为一个无向连通图，其权重函数为 $𝑤:𝐸\to𝑅$，设 &nbsp;𝐴⊆𝐸&nbsp;，且 &nbsp;𝐴&nbsp; 包含于 &nbsp;𝐺&nbsp; 的一棵最小生成树中。设 $𝐶=(𝑉_𝐶, 𝐸_𝐶)$ 为森林 $𝐺_𝐴=(𝑉,𝐴)$ 中的一个连通分量（一棵树）。若 &nbsp;(𝑢,𝑣)&nbsp; 是连接 &nbsp;𝐶&nbsp; 和 $𝐺_𝐴$ 中某一个其它的连通分量的一条轻量边，则对于 &nbsp;𝐴&nbsp;，(𝑢, 𝑣)&nbsp; 是安全边。</p>
<blockquote>
<p>Proof：<br>切割 $(V_C,V-V_C)$ 不影响 A，又因为 (u, v) 是该切割的轻量边，因此，对于 A，(u, v) 是安全的。</p>
</blockquote>
<h2 id="The-algorithms-of-Kruskal-and-Prim"><a href="#The-algorithms-of-Kruskal-and-Prim" class="headerlink" title="The algorithms of Kruskal and Prim"></a>The algorithms of Kruskal and Prim</h2><p>这里描述的两种最小生成树算法详细介绍了上面的通用方法。它们各自使用一个特殊的规则来确定 $GENERIC-MST (G, w)$ 的第 3 行中的 find an edge (u, v) that is safe for A。在 Kruskal 算法中，集合 A 是一个森林，其顶点都是给定图的顶点。添加到 A 中的安全边总是图中连接两个不同分量的最低权重边。在 Prim 算法中，集合 A 形成了一棵树，算法执行过程中始终为一棵树。添加到 A 中的安全边始终是连接树和树中以外的顶点的最低权重边。下面的介绍中，两种算法都假设输入图是连通的，并由邻接列表表示。</p>
<h3 id="Kruskal’s-algorithm"><a href="#Kruskal’s-algorithm" class="headerlink" title="Kruskal’s algorithm"></a>Kruskal’s algorithm</h3><p><img src="https://telegraph-image-eja.pages.dev/file/a9d9c05f942462df59992.png" alt="image"><br><img src="https://telegraph-image-eja.pages.dev/file/f2dcf3043bd0577717a43.png" alt="image"></p>
<blockquote>
<p>大家可以先通过上图感受一下该算法，蓝色边属于森林 A，透过上图我们还可以观察到被添加到 A 中的安全边的权重是从小到大的，所以容易发现 Kruskal 算法是贪心算法，每次都加入权重最小的安全边，以此来保证总权重最小。该算法以按权重排序的顺序来考虑每条边，因此正在考虑的那条边已经是当前未加入生成树的边中的轻量边，只需再判断是否产生环而决定是否将它加入 A，红色的箭头则指向在算法的每一步中所考虑的边。如果边 (u, v) 连接森林中两棵不同的树 (注意单一的顶点也是树），则将其添加到森林中，从而合并两棵树。</p>
</blockquote>
<ul>
<li>设 $C_1$ 和 $C_2$ 表示由 (u, v) 连接的两棵树。因为 (u, v) 必须是连接 $C_1$ 和其他树的轻量边，根据推论 (Corollary)，&nbsp;(𝑢, 𝑣)&nbsp; 是 $𝐶_1$ 的一条安全边。<br>伪代码如下：<blockquote>
<p>// 时间复杂度：𝑂(𝐸 lg⁡ 𝑉)<br>$MST-KRUSKAL(G, w)$<br>1 A = $\not 0$ // 初始化空集合<br>2 for each vertex $v \in G.V$<br>3 MAKE-SET (v) // 使用并查集 (disjoint-set) 的数据结构来维护几个不相交的元素集， 每个集合都包含当前林的一棵树中的顶点，初始化即一个顶点一棵树<br>4 create a single list of the edges in G.E<br>5 sort the list of edges into monotonically increasing order by weight w<br>6 for each edge (u, v) taken from the sorted list in order<br>7 if FIND-SET (u) $\not =$ FIND-SET (v) // 确定两个顶点是否属于同一棵树，同一棵树就会 成环<br>8 $A = A \cup {(u, v)}$ // 把边 (u, v) 加入到 A<br>9 UNION (u, v) // 合并树<br>10 return A</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>上面说到了并查集数据结构，下面简要说一下，已掌握可跳过。</p>
</blockquote>
<h4 id="Disjoint-set"><a href="#Disjoint-set" class="headerlink" title="Disjoint-set"></a>Disjoint-set</h4><p>首先并查集用数组来实现，数组的值代表其父节点的位置，在上面代码中的初始化中，一个顶点就是一棵树，因此没有父节点，可以把所有顶点的数组值标为 - 1。<br>并查集支持两个操作：</p>
<ul>
<li>查找 (Find)：确定某个元素属于哪个子集，它可以用来确定两个元素是否属于同一个子集。</li>
<li>合并 (Union)：将两个子集合并成一个集合<br>上面代码中的 FIND-SET 即是查找操作，对某个顶点 i 查找，即循环查找当前位置 i 的父节点，直到 arr [i] = -1 为止，返回 i，如果两个顶点的 FIND-SET 返回结果一样，即两个顶点属于同一棵树。<br>合并操作即是先分别找到 u，v 的根节点，然后将其中一个根节点的父节点设为另一个顶点。这是最基础的并查集实现，要提高效率的话就要进行路径压缩和按秩合并。</li>
<li>路径压缩：在 Find 过程中在返回之前，路径中的顶点的父节点直接设为根节点，毕竟 Find 返回的就是根节点，这有利于下一次查询的效率。</li>
<li>按秩合并：上面所说的合并操作是将其中一个根节点的父节点设为另一个顶点，这未免有点随便。比如现在有一棵简单的树，一棵复杂的树，那么是将简单的往复杂的合并好还是复杂的往简单的合并好？答案是前者，如果把复杂的往简单的合并，那么原来在复杂树中的每个元素到根节点的距离都变长了，影响后面 Find 的效率；而如果把简单的往复杂的合并，到根节点距离变长的节点个数比较少。所以就引入秩，初始时每个顶点的秩设为 1，那么什么时候秩会增加呢？这发生在合并时，如果两棵树深度相同，则新的根节点的秩 + 1。秩越高，树 (或子树) 就越复杂。</li>
</ul>
<h3 id="Prim’s-algorithm"><a href="#Prim’s-algorithm" class="headerlink" title="Prim’s algorithm"></a>Prim’s algorithm</h3><p>跟上面一样，我们可以先通过过程图感受一下：<br><img src="https://telegraph-image-eja.pages.dev/file/0149f1a64ebab26f61bdd.png" alt="image"><br>// 从上图可以明显感受到与 Kruskal 算法不一样的是，蓝色边之间都是连通的，这里就揭露了 Prim 算法具有的一个性质是 &nbsp;𝐴&nbsp; 中的边总是构成一棵树，我们还可以发现添加边的权重是没有像 Kruskal 算法一样按权重排序的。</p>
<p>如图所示，这棵树以任意一个顶点 &nbsp;𝑟&nbsp; 为根节点，不断生长直到包含 &nbsp;𝑉&nbsp; 中所有顶点。每次加入到 &nbsp;𝐴&nbsp; 中的安全边永远是 (𝐴, 𝑉−𝐴) 切割的轻量边。根据 Corollary，每次加入 &nbsp;𝐴&nbsp; 的边一定是安全边。该算法也满足贪心性质，因为在每一步它向树添加的一条边，都为树的权重贡献可能的最小量。</p>
<p>伪代码如下：</p>
<blockquote>
<p>$MST-PRIM(G, w, r)$<br>1 for each vertex $u \in G.V$<br>2 $u.key = \infty$ //&nbsp;u.𝑘𝑒𝑦 保存连接 u 和树中任一其它节点的所有边中最小的边的权 重，若不存在这样的边，即设为 $\infty$，初始化时都设为 $\infty$。<br>3 $u.\pi = NIL$ //u.𝜋&nbsp; 保存 u 在树中的父节点<br>4 $r.key = 0$ // 把根节点 r 的 key 设为 0，方便第 9 行第一个处理 r<br>5 $Q = \not 0$ // 创建基于 &nbsp;𝑘𝑒𝑦&nbsp; 属性的优先队列<br>6 for each vertex $u \in G.V$<br>7 INSERT (Q, u)<br>8 while $Q \not = \not 0$ // 只要队列非空<br>9 u = EXTRACT-MIN (Q) // 把 u 加到树 (A) 中<br>10 for each vertex v in $G.Adj [u]$ // 更新 u 的非树邻居的 key<br>11 if $v \in Q$ and w(u, v) &lt; v.key<br>12 $v.\pi = u$<br>13 v.key = w(u, v)<br>14 DECREASE-KEY (Q, v, w (u, v)) // 调整 Q 中 v 的 key 值</p>
</blockquote>
<p>该算法保持以下三个循环不变量：</p>
<ul>
<li>$𝐴={(𝑣, 𝑣.𝜋): 𝑣∈𝑉−{𝑟}−𝑄}$，(算法终止时，&nbsp;𝑄=∅，因此 G 的最小生成树 $𝐴={(𝑣, 𝑣.𝜋): 𝑣∈𝑉−{𝑟}}$。)</li>
<li> 已经放在最小生成树中的顶点都是 V - Q 中的顶点。</li>
<li>对于图中所有的顶点 v∈Q，如果 $v.\pi$ 不等于 NIL，那么 v.key 小于正无穷大，v.key 是连接 v 到已经放置在最小生成树中的某个顶点的轻量边 $(v,v.\pi)$ 的权重。</li>
</ul>
<p>Prim 算法的运行时间取决于最小优先级队列 Q 的实现：</p>
<ul>
<li>二叉堆：时间复杂度：$𝑂(𝐸lg⁡𝑉)$</li>
<li> 斐波那契堆：时间复杂度：$O (E+V lg V)$</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>算法</tag>
        <tag>最小生成树</tag>
        <tag>Kruskal</tag>
        <tag>Prim</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
</search>
